---
title: 整数运算详解
date: '2025-03-30 14:04:58'
updated: '2025-07-05 14:09:43'
permalink: /post/detailed-explanation-of-integer-operation-uoqsz.html
comments: true
toc: true
---



# 整数运算详解

‍

### **计算机中整数的运算详解**

在计算机中，整数的运算主要基于二进制表示和数字逻辑电路实现。运算包括**算术运算（加、减、乘、除）** 和**位运算（与、或、非、移位等）** 。由于计算机使用固定位宽存储整数，运算时需考虑**溢出、符号处理**等问题。以下是详细说明：

---

## **整数的存储表示**

计算机中的整数通常以**补码（Two's Complement）** 形式存储（现代计算机通用方案），其特点包括：

* **正数**：与原码相同。
* **负数**：其绝对值的二进制表示**取反后加 1**。
* **优势**：加减法统一，无需额外处理符号位。

|**示例（8位整数）：**||||
|十进制|原码（Sign-Magnitude）|反码（Ones' Complement）|补码（Two's Complement）|
| ----| ------| ------| ------|
|+5|​`00000101`​|​`00000101`​|​`00000101`​|
|-5|​`10000101`​|​`11111010`​|​`11111011`​|

**补码范围（n位）：**

* 有符号整数：\( -2<sup>{n-1}</sup> <sup>)</sup> <sup>到</sup> <sup>(</sup> <sup>2</sup>{n-1}-1 \)（如 8位：-128 ~ 127）
* 无符号整数：\( 0 \) 到 \( 2^{n}-1 \)（如 8位：0 ~ 255）

---

## **算术运算**

###  **(1) 加法（Addition）**

计算机使用**加法器（Adder）** 实现二进制加法，补码运算直接相加，符号位参与计算。

**运算步骤：**

1. 两个数按位相加（包括符号位）。
2. 若最高位产生进位，则丢弃（溢出处理）。
3. 检查是否溢出（两个正数相加得负数，或两个负数相加得正数）。

**示例（8位补码）：**

* **计算** **​`5 + (-3)`​** ​
  `5`​ = `00000101`​
  `-3`​ = `11111101`​

  ```
    00000101 (5)
  + 11111101 (-3)
  ------------
   100000010 (2) → 丢弃溢出位，结果为 `00000010`（2）
  ```
* **溢出示例（127 + 1）** 
  `127`​ = `01111111`​
  `1`​ = `00000001`​

  ```
    01111111 (127)
  + 00000001 (1)
  ------------
    10000000 (-128) → 溢出（结果错误）
  ```

---

###  **(2) 减法（Subtraction）**

减法可转换为加法：
\( A - B = A + (-B) \)
即：**取 B 的补码，再与 A 相加**。

**示例（8位补码）：**

* **计算** **​`7 - 5`​**​
  `7`​ = `00000111`​
  `-5`​ = `11111011`​（5的补码：`00000101`​ → 取反 `11111010`​ → 加 `1`​）

  ```
    00000111 (7)
  + 11111011 (-5)
  ------------
    00000010 (2) → 正确
  ```

---

**整数的乘法与除法运算**

在计算机中，乘法和除法是两种基本的算术运算，但由于硬件实现的复杂性，它们的计算方式与加减法不同。现代处理器通常使用**硬件乘法器（Multiplier）** 和**除法器（Divider）** 来加速运算，但在底层，它们仍然基于**移位（Shifting）** 和**加法/减法**的组合来实现。以下是详细的解释：

---

## **1. 乘法运算（Multiplication）**

计算机中的乘法运算通常比加法复杂，主要方法包括：

* **无符号乘法**（Unsigned Multiplication）
* **有符号乘法**（Signed Multiplication，通常使用 **Booth 算法**优化）
* **硬件优化**（如 Wallace Tree、Dadda Tree 等）

###  **(1) 无符号乘法（Unsigned Binary Multiplication）**

**基本原理**：模拟手算乘法，通过**移位-加法（Shift-Add）** 实现。

**算法步骤（以 4 位乘法** **​`5 × 3`​**​ **为例）：**

1. **初始化**：

    * 被乘数 `A = 0101`​（5）
    * 乘数 `B = 0011`​（3）
    * 结果 `P = 0000 0000`​（8 位，初始为 0）
2. **逐位检查乘数** **​`B`​**​：

    * 如果当前最低位 `B[0] = 1`​，则 `P = P + A`​。
    * 否则，不做加法。
3. **右移** **​`B`​**​ **，左移** **​`A`​**​：

    * ​`B`​ 右移 1 位（相当于检查下一位）。
    * ​`A`​ 左移 1 位（相当于权重 ×2）。
4. **重复直到** **​`B = 0`​**​。

|**计算过程：**|||||
|步骤|​`A`​（左移）|​`B`​（右移）|​`P`​（累加）|操作|
| ------| ------| -------| ------| --------------------|
|初始|​`0101`​|​`0011`​|​`00000000`​|-|
|1|​`0101`​|​`001`​1|​`00000101`​|​`P += A`​（因为 `B[0]=1`​）|
||​`1010`​|​`0001`​||​`A << 1`​, `B >> 1`​|
|2|​`1010`​|​`000`​1|​`00001111`​|​`P += A`​（`B[0]=1`​）|
||​`1100`​|​`0000`​||​`A << 1`​, `B >> 1`​|
|结束|-|​`0000`​|​`00001111`​|结果 `15`​（5×3=15）|

**特点**：

* 适用于无符号整数。
* 需要 `2n`​ 位存储结果（`n`​ 位 × `n`​ 位 → `2n`​ 位）。

---

###  **(2) 有符号乘法（Signed Multiplication）**

由于补码的符号位会影响乘法，直接使用无符号乘法会导致错误。**Booth 算法** 是一种优化方法，可以减少乘法步骤并正确处理符号。

**Booth 算法（Radix-2）步骤**：

1. **初始化**：

    * 被乘数 `M`​，乘数 `Q`​，辅助位 `Q_{-1} = 0`​。
    * 累加器 `A = 0`​，位数 `n`​。
2. **检查** **​`Q[0]`​** ​ **和** **​`Q_{-1}`​** ​：

    * ​`10`​ → `A = A - M`​（减去被乘数）
    * ​`01`​ → `A = A + M`​（加上被乘数）
    * ​`00`​ 或 `11`​ → 不操作
3. **算术右移** **​`A`​**​ **和** **​`Q`​**​（保留符号位）。
4. **重复** **​`n`​**​ **次**。

**示例（4 位补码乘法**  **​`-3 × 2`​**​ **）：**

* ​`M = 1101`​（-3 的补码）
* ​`Q = 0010`​（2 的补码）
* ​`A = 0000`​, `Q_{-1} = 0`​

|步骤|​`A`​|​`Q`​|​`Q_{-1}`​|操作|
| ------| ------| ------| ------| ---------------------|
|初始|​`0000`​|​`0010`​|​`0`​|-|
|1|​`0000`​|​`0010`​|​`0`​|​`Q[0]Q_{-1}=00`​ → 无操作|
||​`0000`​|​`0001`​|​`0`​|右移|
|2|​`0000`​|​`0001`​|​`0`​|​`Q[0]Q_{-1}=10`​ → `A = A - M = 0011`​|
||​`0011`​|​`0001`​|​`0`​|右移 → `A = 0001`​, `Q = 1000`​|
|3|​`0001`​|​`1000`​|​`1`​|​`Q[0]Q_{-1}=01`​ → `A = A + M = 1110`​|
||​`1110`​|​`1000`​|​`1`​|右移 → `A = 1111`​, `Q = 0100`​|
|4|​`1111`​|​`0100`​|​`0`​|​`Q[0]Q_{-1}=00`​ → 无操作|
||​`1111`​|​`0010`​|​`0`​|右移 → 最终 `A = 1111`​, `Q = 0010`​|

**结果**：`1111 0010`​（高 4 位 `1111`​ = -1，低 4 位 `0010`​ = 2，实际应为 `-6`​，这里需要调整位数）

**Booth 算法的优势**：

* 减少加法次数（特别是连续 `1`​ 时）。
* 适用于补码乘法。

---

## **2. 除法运算（Division）**

除法比乘法更复杂，计算机通常采用**恢复余数法（Restoring Division）** 或**非恢复余数法（Non-Restoring Division）** 。

###  **(1) 无符号除法（Unsigned Binary Division）**

**恢复余数法（Restoring Division）步骤**：

1. **初始化**：

    * 被除数 `D`​（`2n`​ 位），除数 `d`​（`n`​ 位）。
    * 商 `Q = 0`​，余数 `R = 0`​。
2. **循环** **​`n`​**​ **次**：

    * 左移 `D`​，最高位进入 `R`​。
    * ​`R = R - d`​（尝试减去除数）。
    * 如果 `R ≥ 0`​，则 `Q[0] = 1`​（商置 1）。
    * 否则，恢复 `R = R + d`​（恢复余数），`Q[0] = 0`​。
3. **最终商在** **​`Q`​**​ **，余数在** **​`R`​**​。

**示例（8 位无符号除法** **​`10 / 3`​**​ **）：**

* ​`D = 00001010`​（10），`d = 00000011`​（3）
* ​`Q = 0000`​, `R = 0000`​

|步骤|​`D`​（左移）|​`R`​（尝试减）|​`Q`​（商）|操作|
| ------| --------------| ----------------| ------------| ---------------|
|1|​`00010100`​|​`00000001`​|​`0000`​|​`R = 1 - 3 = -2`​（恢复）|
|||​`00000001`​|​`0000`​|​`R`​ 恢复，`Q[0]=0`​|
|2|​`00101000`​|​`00000010`​|​`0000`​|​`R = 2 - 3 = -1`​（恢复）|
|||​`00000010`​|​`0000`​|​`R`​ 恢复，`Q[0]=0`​|
|3|​`01010000`​|​`00000101`​|​`0000`​|​`R = 5 - 3 = 2`​（成功）|
|||​`00000010`​|​`0001`​|​`Q[0]=1`​|
|4|​`10100000`​|​`00000100`​|​`0010`​|​`R = 4 - 3 = 1`​（成功）|
|||​`00000001`​|​`0011`​|​`Q[0]=1`​|

**结果**：

* 商 `Q = 0011`​（3）
* 余数 `R = 0001`​（1）

---

###  **(2) 有符号除法（Signed Division）**

有符号除法通常：

1. 记录符号（`被除数_sign XOR 除数_sign`​）。
2. 对被除数和除数取绝对值，进行无符号除法。
3. 根据符号调整商和余数。

**示例（**​ **​`-10 / 3`​**​ **）：**

1. 符号：`1 XOR 0 = 1`​（结果为负）。
2. 计算 `10 / 3`​：

    * 商 `3`​，余数 `1`​。
3. 最终：

    * 商 `-3`​，余数 `-1`​（或 `+1`​，取决于定义）。

---

## **硬件优化**

现代 CPU 使用专用硬件加速乘除法：

* **乘法器**：

  * **阵列乘法器（Array Multiplier）** ：并行计算部分积。
  * **Wallace Tree**：优化部分积累加。
* **除法器**：

  * **SRT 算法**：非恢复余数法的变种，用于高性能除法。

---

## **编程语言中的乘除法**

|语言|乘法|除法|特点|
| --------| ------------------| ------------------| -------------------|
|C/C++|​`*`​（可能溢出）|​`/`​（整数截断）|无溢出检查|
|Java|​`*`​（溢出回绕）|​`/`​（向零取整）|严格定义|
|Python|​`*`​（自动扩展）|​`/`​（浮点结果）|​`//`​ 用于整数除法|
|Rust|​`wrapping_mul`​（防溢出）|​`checked_div`​（防除零）|显式溢出控制|

---

##  **关键问题**

|问题|原因|解决方法|
| ------| ----------------------| ---------------------------|
|**乘法溢出**|结果超出位数|使用更大类型（如 `int64_t`​）|
|**除法除零**|除数为零|运行时检查或异常处理|
|**符号错误**|补码直接运算导致错误|使用 Booth 算法或调整符号|

---

## **总结**

* **乘法**：

  * 无符号：移位-加法。
  * 有符号：Booth 算法优化。
* **除法**：

  * 无符号：恢复余数法。
  * 有符号：先取绝对值再调整符号。
* **硬件**：现代 CPU 有专用乘法器/除法器。
* **编程**：注意溢出和除零问题。

理解这些底层原理有助于：

* 优化计算密集型代码（如避免慢速除法）。
* 调试数值异常（如溢出错误）。
* 设计高效算法（如快速幂运算）。

## **位运算（Bitwise Operations）**

位运算直接操作二进制位，常用于高效计算和底层优化：

|运算|符号（C/Java）|示例（8位）|
| -------------| ----------------| ----------------------------|
|与（AND）|​`&`​|​`1100 & 1010 = 1000`​|
|或（OR）|​`\|`​|​`1100 \| 1010 = 1110`​|
|异或（XOR）|​`^`​|​`1100 ^ 1010 = 0110`​|
|非（NOT）|​`~`​|​`~1100 = 0011`​（按位取反）|
|左移|​`<<`​|​`00010010 << 2 = 01001000`​|
|右移|​`>>`​|​`10010010 >> 1 = 11001001`​（算术右移保留符号位）|

---

## **4. 溢出与异常处理**

* **溢出（Overflow）** ：运算结果超出表示范围。

  * **检测方法**：

    * 若 `A + B`​ 的符号与 `A`​、`B`​ 均不同，则溢出。
    * 若 `A - B`​ 的符号与 `A`​ 不同且与 `-B`​ 相同，则溢出。
* **解决方法**：

  * 使用更大位宽（如 `int32`​ → `int64`​）。
  * 编程语言可能抛出异常（如Java的 `ArithmeticException`​）。

---

## **5. 编程语言中的整数运算**

|不同语言对整数运算的处理：||
|语言|特点|
| ----------------------------| ------------------------------------------------|
|C/C++|依赖编译器，溢出行为未定义（可能回绕）。|
|Java|严格定义位数（如 `int`​ 为32位补码），溢出时回绕。|
|Python|整数无固定位数，自动扩展（无溢出问题）。|
|Rust|提供`checked_add`​、`overflowing_add`​等方法显式处理溢出。|

---

## **6. 总结**

|运算类型|实现方式|关键问题|
| ----------| ----------------------------| --------------------|
|加法|补码直接相加|溢出检测|
|减法|转换为加法（A + (-B)）|补码取反|
|乘法|移位-加法（Booth算法优化）|高位溢出|
|除法|移位-减法（非恢复余数法）|除零异常|
|位运算|直接按位操作|符号位处理（右移）|

理解整数运算的底层原理有助于：

* 编写高效、安全的代码（如避免溢出）。
* 优化算法（如用位运算替代乘除）。
* 调试底层问题（如内存中的二进制数据解析）。

同时附上练习题：![微信截图_20250330134351](http://127.0.0.1:10184/assets/微信截图_20250330134351-20250330134403-sbhdfr3.png)

**比特操作例子:** 

### **如何正确交换一个** **​`short`​**​ **的两个字节（16位整数字节翻转）**

在 C/C++ 中，`short`​ 通常是 **2字节（16位）** 。如果需要交换它的高字节和低字节（例如 `0x1234`​ → `0x3412`​），可以通过以下方法实现：

---

###  **❌ 错误的宏定义（问题分析）**

```c
#define flip2(a) (((a) & 0xFF00) >> 8) | (((a) & 0xFF) << 8)
```

* **问题**：

  * 缺少最外层的括号，导致在复杂表达式中可能出现 **运算符优先级错误**。
  * 例子：

    ```c
    short x = 0x1234;
    short y = flip2(x) + 1;  // 可能因缺少外层括号而错误计算
    ```

---

###  **✅ 正确的宏定义（修复版）**

```c
#define flip2(a) ( ((a) << 8) | (((a) >> 8) & 0xFF) )
```

#### **为什么这样写是正确的？**

1. ​ **​`(a) << 8`​**​

    * 将 **低字节** 移到 **高字节位置**（如 `0x0034`​ → `0x3400`​）。
2. ​ **​`(a) >> 8`​**​

    * 将 **高字节** 移到 **低字节位置**（如 `0x1234`​ → `0x0012`​）。
    * ​ **​`& 0xFF`​**​ **确保只保留低8位**（避免有符号 `short`​ 右移时的符号位扩展问题）。
3. **按位或**  **​`|`​** ​

    * 合并交换后的两个字节（如 `0x3400 | 0x0012`​ → `0x3412`​）。

#### **使用示例**

```c
#include <stdio.h>

#define flip2(a) ( ((a) << 8) | (((a) >> 8) & 0xFF) )

int main() {
    short x = 0x1234;
    short y = flip2(x);  // y = 0x3412
    printf("0x%04X -> 0x%04X\n", x, y);
    return 0;
}
```

**输出**：

```
0x1234 -> 0x3412
```

---

###  **⚠️ 注意事项**

1. **括号的重要性**

    * 宏的参数和整个表达式必须用 `()`​ 包裹，避免运算符优先级问题。
    * 例如 `flip2(x + y)`​ 会被正确展开为 `( ((x + y) << 8) | ... )`​。
2. **有符号** **​`short`​**​ **的符号扩展问题**

    * 右移有符号数时，高位会补符号位（算术右移）。
    * ​`& 0xFF`​ 确保只保留低8位，丢弃符号位。
3. **替代方案（使用联合体** **​`union`​**​ **）**

    ```c
    short flip2(short a) {
        union { short s; unsigned char b[2]; } u;
        u.s = a;
        unsigned char tmp = u.b[0];
        u.b[0] = u.b[1];
        u.b[1] = tmp;
        return u.s;
    }
    ```

    * **优点**：代码更清晰，不依赖位运算。
    * **缺点**：某些编译器可能不如宏优化得好。

---

### **最终建议**

* **对性能要求高的代码**：使用宏定义。
* **对可读性要求高的代码**：使用 `union`​ 方法。
* **测试边界情况**：如 `0x00FF`​、`0xFF00`​、负数等。

---

### **关键总结**

|问题|解决方案|
| ----------| ---------------------------|
|缺少括号|用 `()`​ 包裹整个宏|
|符号扩展|右移后使用 `& 0xFF`​ 屏蔽高8位|
|可移植性|如需避免符号问题，可用 `unsigned short`​|

这样可以确保 **正确、高效且安全** 地交换 `short`​ 的高低字节。
