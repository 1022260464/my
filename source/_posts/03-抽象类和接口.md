---
title: 03抽象类和接口
date: '2026-01-27 21:42:52'
updated: '2026-01-27 23:18:22'
permalink: /post/03abstract-classes-and-interfaces-z1gq00b.html
comments: true
toc: true
---



# 03抽象类和接口

- [X] final
- [X] 单例类
- [X] 枚举类
- [ ] 抽象类
- [ ] 接口
- [ ] 综合案例

‍

# final：

​`final` 在英文中是“最终的”、“不可更改的”意思。在 Java 中，它主要用于限制类、方法和变量的行为，以此来保证数据的安全性和逻辑的确定性。

以下是关于 `final`​ 的系统化总结，分为​**核心用法**​、**常量详解**和**知识点总结**三个部分。

---

## 1. 认识 `final` 的三种用法

​`final` 可以用来修饰类、方法和变量，在不同的位置有不同的含义。

### ① 修饰变量 (Variables)

这是最常见的情况。被 `final`​ 修饰的变量，​**一旦赋值，就不能再次改变**。

- **基本数据类型 (Primitive Types):**  数值本身不可变。

  - 例如：`final int x = 10;`​ 之后无法执行 `x = 20;`。
- **引用数据类型 (Reference Types):**  **引用地址**不可变，但**对象内部的内容**可以变。

  - 这是初学者最容易混淆的地方。你不能让这个变量指向另一个对象，但你可以修改该对象里面的属性。
- 在java中变量在栈中初始化，存储的是变量的地址，先为其在堆中分配内存，然后通过挂载引用（指针），变量 （在栈内存中）获得了一个指向堆内存地址的**指针然后通过构造器初始化**：**构造器开始工作，** 它的任务不是去挂载 `u`​ 这个指针，而是去填充 `u` 指向的那块内存空间里的具体内容。

> **示例：**
>
> Java
>
> ```java
> final int[] arr = {1, 2, 3};//只是一个引用，指向堆内存中的一个数组
> arr[0] = 99;  // 合法！修改的是对象内部的数据
> // arr = new int[]{4, 5, 6}; // 非法！试图修改引用地址，编译报错
> //这里就是一个新的数组了，所以会报错
> ```

### ② 修饰方法 (Methods)

被 `final`​ 修饰的方法​**不能被子类重写 (Override)** 。

- **目的：**  确保方法的逻辑在继承体系中保持一致，防止子类修改核心算法。
- *注：类的* *​`private`​*​ *方法会被隐式地指定为* *​`final`​*​ *。*

### ③ 修饰类 (Classes)

被 `final`​ 修饰的类​**不能被继承**。

- **意味着：**  该类没有子类，该类的所有方法也默认是 `final` 的。
- **典型案例：**  Java 中的 `String`​ 类、`Math`​ 类都是 `final` 的，以此保证安全性。

---

## 2. 常量 (Constants)

在 Java 中，我们通常使用 `final`​ 配合 `static`​ 来定义​**常量**。

### 全局常量 (`static final`)

当一个变量被 `static`​ 和 `final`​ 同时修饰时，它就变成了一个​**全局常量**。

- **存储位置：**  也就是通常说的“常量池”或静态存储区，只有一份拷贝。
- **命名规范：**  所有字母大写，单词之间用下划线连接。
- PI-VALUE  APP-VALUE

Java

```java
public class Config {
    // 这是一个标准的全局常量
    public static final double PI_VALUE = 3.14159;
    public static final String APP_NAME = "MySuperApp";
}
```

### 	编译期常量 vs 运行期常量

- **编译期常量：**  在编译阶段就能确定值（如上面写的 `3.14159`）。编译器会进行优化，直接把值替换到代码中。
- **运行期常量：**  虽然是 `final`​，但值是在运行时计算出来的（例如 `final int x = new Random().nextInt();`）。

---

- ## 1. 运行速度与编译速度 (Performance)

  #### 编译速度

  **几乎没有区别。**  编译器确实需要多做一步检查（检查是否被重复赋值），但这对现代计算机来说可以忽略不计。

  #### 运行速度（重点）

  这里有显著区别，但主要体现在**编译期常量**上。

  **情况 A：编译期常量 (Static Final + 基本类型/String)** 如果你定义 `public static final int MAX_VALUE = 100;`：

  - **速度更快：**  编译器会进行​**宏替换 (Macro Substitution)** 。
  - **原理：**  在编译后的 `.class`​ 文件中，所有用到 `MAX_VALUE`​ 的地方，都会直接被替换成数字 `100`。
  - **优势：**  运行时不需要去内存里查找这个变量，直接用立即数，效率极高。

  **情况 B：普通 Final 变量 (Instance Final)** 如果你定义 `final int x = 100;` (没有 static)：

  - **速度基本一样：**  JVM 还是需要去堆内存（Heap）里的对象中读取这个值。
  - **微小优化：**  现在的 JVM (JIT 编译器) 非常聪明。如果它确定一个变量是 `final` 的，它可能会进行一些激进的优化（例如内联优化），因为它确信这个值不会变。但这属于微观层面的优化，宏观上区别不大。
- ## 2. 内存加载：是只加载一份吗？(Memory)

  这个问题的答案是：**不一定，看是否有** **​`static`​**​ **。**

  这是一个非常容易混淆的误区，很多人认为加了 `final` 就只存一份，其实不然。

  #### 情况 A：仅有 `final`​ (成员变量) -\> **多份**

  Java

  ```java
  class User {
      final int id = 10; // 这是一个实例变量
  }

  // 代码执行：
  User u1 = new User(); // 堆内存中生成一个对象，里面包含一个 id=10
  User u2 = new User(); // 堆内存中生成另一个对象，里面包含另一个 id=10
  ```

  - **结论：**  **每** **​`new`​**​ **一个对象，就会在堆内存里产生一份新的拷贝。**
  - **原因：**  虽然它们的值都是10且不可变，但它们属于不同的对象实例。

  #### 情况 B：`static final`​ (全局常量) -\> **一份**

  Java

  ```java
  class User {
      static final int MAX_AGE = 120; // 类变量
  }
  ```

  - **结论：**  **只加载一份。**
  - **原因：**  `static`​ 决定了它属于**类 (Class)**  而不是对象。当类被加载（ClassLoader）时，它会被存储在**方法区 (Method Area / Metaspace)** ，全局只有这一份。
- ## **3.一个致命的“坑”：重新编译陷阱**

  由于上面提到的  **“宏替换”**  (直接把值写死在代码里)，`static final` 变量在跨类使用时有一个著名的坑。

  **场景模拟：**

  1. 类 A 定义：`public static final int PRICE = 10;`
  2. 类 B 使用：`System.out.println(A.PRICE);`
  3. **编译：**  此时类 B 的字节码里，`A.PRICE`​ 已经被替换成了 `10`。
  4. **修改：**  你把类 A 改为 `PRICE = 20`​，并​**只重新编译了类 A**，没有重新编译类 B。
  5. **运行：**  运行类 B，你会发现打印出来的​**依然是 10**！

  **原因：**  类 B 在编译时已经把 `10`​ “烧录”进去了，它根本不看类 A 新的值。**解决：**  修改了 `static final`​ 常量后，必须​**重新编译所有引用了该常量的类**​（通常 `Clean & Build` 整个项目）。

---

## 3. 总结 `final` 知识 (Cheat Sheet)

为了方便记忆，我为你整理了一张核心知识对比表：

|**修饰目标**|**核心限制**|**补充说明**||||
| --| --| --------------------------------------------| --| --| --|
|**类 (Class)**|**不可继承**|例如`String`类。断绝了子类修改的可能性。||||
|**方法 (Method)**|**不可重写**|父类锁定该方法的逻辑，子类只能用，不能改。||||
|**基本变量**|**数值不可变**|必须在定义时或构造器/代码块中初始化。||||
|**引用变量**|**地址不可变**|**重点：** 对象内部的状态（属性）依然可以被修改。||||

### 面试高频考点（AI给出，后续背八股的时候补充，这个有点细了）

1. **Blank Final (空白 final):**  `final` 变量可以先声明不赋值，但必须在构造器或初始化块中完成赋值，且只能赋值一次。
2. **不可变性 (Immutability):**  虽然 `final` 引用指向的对象内容可变，但如果想要创建一个真正的“不可变类”（如 String），需要将类声明为 final，并将所有成员变量也设为 private final，且不提供 Setter 方法。

---

# 设计模式？总结出来的一种最优的解决问题的解法，称之为设计模式

单例模式的目标非常简单：**保证一个类在内存中只有一个对象（实例），并提供一个全局访问点。**

结合刚才我们讨论的知识，我为你剖析两种最典型的写法，看看 `final` 在其中扮演了什么角色。

---

### 1. 饿汉式 (Hungry Mode) —— `static final` 的最佳舞台

这是最简单、最安全（线程安全）且最容易理解的单例写法。它直接利用了 JVM 的类加载机制。

1. 把类的构造器私有。
2. 定义一个静态变量记住类的一个对象。
3. 定义一个静态方法，返回对象。

Java

```java
// final 修饰类：不允许被继承，防止子类破坏单例逻辑
public final class Singleton {

    // 1. 私有构造器：防止外部 new Singleton()，只有内部类可以访问
    private Singleton() {}

    // 2. 核心点：static final
    // static -> 保证只有一份 ，属于类
    // final -> 保证引用不可变，永远指向这个对象，不能被改为 null 
//private 当前变量私有，但是我的外部如何去新建实例呢？此时写一个静态方法，去提供接口
    private static final Singleton INSTANCE = new Singleton();
//singletion 是当前对象，instance是变量名

    // 3. 公共获取方法
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

```java
或者如下
public final class Singletion{
	private Singletion();
	//私有化构造器，防止外部新建多个对象，等于是关上了大门，将整个类封装起来了
	public static final Singletion INSTANCE = new Singletion();

}
```

**这里的** **​`final`​**​ **起了什么作用？**

1. **修饰变量 (**​**​`INSTANCE`​**​ **)：**  这是一个​**引用变量**​。加上 `final`​ 后，保证了 `INSTANCE` 即使在类内部也不会被意外修改指向。它像钉子一样把这个唯一的对象“钉”在了内存里。
2. **修饰类 (**​**​`class Singleton`​**​ **)：**  虽然不是必须的，但强烈建议加上。如果允许单例类被继承，子类可能会通过构造器链调用父类构造器，从而产生多个实例，破坏单例的唯一性。

总结如下：

- 如果要用public修饰成员变量，那么就要加上final修饰，防止我的外部去修改变量的值，导致我的变量失效（地址被修改）
- 如果用private修饰，那么就需要添加静态方法，对外开放我的对象获取接口
- 私有化构造器，实际上是对我的对象进行了限制，防止其创建过多的对象，确保一个类只有一个对象，且不能被随意修改

---

### 2. 枚举单例 (Enum Singleton) —— 天然的 `final`  较为推荐的写法：

这是《Effective Java》作者 Joshua Bloch 极力推荐的写法，被称为\*\*“最完美的单例”\*\*。

```java
public enum SingletonEnum {
    INSTANCE; // 这就是一个天然的单例对象

    public void doSomething() {
        System.out.println("我是单例的方法");
    }
}

// 使用：
// SingletonEnum.INSTANCE.doSomething();
```

**为什么它最完美？**

1. **天然** **​`final`​**​ **：**  在 Java 中，`enum`​ 类型实际上是继承自 `java.lang.Enum`​ 的类，并且它​**默认就是** **​`final`​**​ **的**（无法被继承）。
2. **防反射攻击：**  普通的单例（即使是饿汉式）可以通过反射机制（Reflection）强行调用 `private` 构造器来生成新对象。但 Java 规定反射不能创建枚举实例，从底层堵死了这条路。
3. **防序列化破坏：**  普通单例在序列化再反序列化后会生成新对象，而枚举由 JVM 保证序列化也是单例的。

---

### 3. 懒汉式 (Lazy Mode) —— 为什么不能用 `final`？

懒汉式的特点是：**只有当第一次调用** **​`getInstance()`​** ​ **时才创建对象**（为了省内存）。

- AI写的太复杂了，其实就是在饿汉式单例的基础上，我去在初始化变量的时候不去加final，而是在静态方法中去进行条件判断，再对其进行初始化
- 为什么一定要用static修饰方法，应为我的构造器是私有的，我无法去new一个新的对象（实例），通过static将方法提升到了class层面，去点方法就可以实现调用

```java
public class LazySingleton {
    // 这里不能加 final！
    // 因为一开始是 null，后面才赋值。final 变量必须在初始化时赋值。
    private static volatile LazySingleton instance; 

    private LazySingleton() {}

    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```

**知识点串联：**

- 这里无法使用 `final`​ 修饰 `instance`​ 变量，因为它的值会发生变化（从 `null`​ 变成 `object`）。
- 这里引入了另一个关键字 ​**​`volatile`​**。它的作用是禁止指令重排序，防止多线程环境下对象初始化不完全的问题。

---

### 总结：`final` 在单例中的地位

|**单例类型**|**final 的作用**|**评价**||||
| --| --------------------------------------------------------| ----------------------------------------------| --| --| --|
|**饿汉式**|核心主力。`static final`配合，确保对象在类加载时创建且引用不可变。|​**面试推荐**（除非明确要求懒加载），简单且从不犯错。||||
|**枚举式**|隐式主力。枚举类本身就是`final`的，且 JVM 强制保证唯一。|​**生产环境推荐**，安全性最高。||||
|**懒汉式**|无法修饰变量。只能用来修饰类（防止继承）。|写法复杂，容易写错（DCL双重检查锁）。||||

**一句话总结：**

如果你想要一个**不可变、不可继承、只加载一份**的完美单例，**​`static final`​**​（饿汉式）或者 **​`enum`​** 是你的最佳选择。

---

# 枚举类：

一句话就能揭示枚举的本质：**枚举就是一个把构造器私有化、并且实例数量固定的特殊的类。**

它是 Java 为了让你不再到处定义乱七八糟的常量（比如 `public static final int TYPE_A = 1`）而专门设计的一种语法糖。

---

## 1. 什么是枚举？

枚举（Enumeration）顾名思义，就是\*\*“一一列举” **。 当一个事物的**取值范围是有限的、固定的\*\*时候，就应该用枚举。 ***<u> **（用于进行分类和标签）** </u>***

**典型场景：**

- **季节：**  春、夏、秋、冬（只有这4个，不可能有第5个）。
- **方向：**  东、南、西、北。
- **订单状态：**  待支付、已支付、发货中、已完成、已退款。

---

## 2. 透过现象看本质（硬核部分）

很多初学者只知道怎么写枚举，但不知道它底层长什么样。既然你懂了前面的知识，我们可以直接看“反编译”后的代码。

**你写的代码：**

```java
public enum Season {
    SPRING, SUMMER, AUTUMN, WINTER;
}
```

**编译器眼中的代码（近似逻辑）：**

Java

```java
// 1. 它是 class，而且继承自 Java 标准库的 Enum 类
public final class Season extends java.lang.Enum<Season> {

    // 2. 这里的每个枚举项，本质上都是本类的一个【静态常量实例】
    // 也就是：public static final
    public static final Season SPRING = new Season("SPRING", 0);
    public static final Season SUMMER = new Season("SUMMER", 1);
    public static final Season AUTUMN = new Season("AUTUMN", 2);
    public static final Season WINTER = new Season("WINTER", 3);

    // 3. 构造器被强制私有化了 (外部不能 new)
    private Season(String name, int ordinal) {
        super(name, ordinal);//调用父类构造器
    }
}
```

**知识点串联：**

- ​**​`final`​**​ **类**：枚举类默认不能被继承。
- ​**​`static final`​**​ **实例**​：每个枚举项（如 `SPRING`）都是一个全局唯一的单例对象。
- ​**私有构造器**：保证了只有这 4 个季节，别人造不出第 5 个。

---

## 3. 枚举的进阶用法：它真的是个类！

既然它是类，那它就可以有​**成员变量**​、**构造器**和​**方法**。这在实际开发（比如处理错误码、状态码）中非常有用。

**场景：**  我们定义一个“HTTP响应状态”的枚举。

Java

```java
public enum HttpStatus {
    // 定义枚举项，同时传入参数，这里是通过构造器进行初始化的
    SUCCESS(200, "操作成功"),
    NOT_FOUND(404, "资源未找到"),
    ERROR(500, "服务器内部错误");
//实际如下
//public static final HttpStatus SUCCESS = new HttpStatus(200, "操作成功");
//3. 这个过程是怎么发生的？
/*3. 这个过程是怎么发生的？
让我们慢动作回放一下枚举类的加载过程：
类加载： JVM 加载 HttpStatus 类。
初始化静态常量： 发现有 SUCCESS、NOT_FOUND 等枚举项。
执行构造器：
遇到 SUCCESS(200, "...") -> 自动调用构造器，把 code 设为 200，msg 设为 "..."。
遇到 NOT_FOUND(404, "...") -> 自动调用构造器，把 code 设为 404...

封存： 这些对象创建好后，就被 static final 钉死在内存里了，以后谁也改不了它们内部的值（因为成员变量也是 final 的）。*/
    // 自定义成员变量
    private final int code;
    private final String msg;

    // 自定义构造器 (必须是 private，默认也是 private)
    HttpStatus(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    // 自定义方法
    public int getCode() {
        return code;
    }
    
    public String getMsg() {
        return msg;
    }
}
```

**怎么用？**

Java

```
HttpStatus status = HttpStatus.SUCCESS;
System.out.println(status.getCode()); // 输出 200
System.out.println(status.getMsg());  // 输出 "操作成功"
```

---

## 4. 为什么要用枚举，而不用常量？

以前我们可能会这样写常量：

Java

```
public static final int SPRING = 1;
public static final int SUMMER = 2;
```

**枚举的优势（Type Safety 类型安全）：**

- **常量的问题：**  如果你的方法接收 `int`​，我可以传 `1`​，也可以传 `999`（虽然没有999这个季节），编译器不会报错，运行才会出Bug。
- **枚举的优势：**  如果方法定义为 `void setSeason(Season s)`​，那你**只能**传 `Season.SPRING` 等那四个对象。传别的？编译器直接红线报错，连运行的机会都不给你。

---

## 5. 常用 API 速查^^

Java 默认为枚举提供了一些好用的方法：^^

- ​**​`name()`​** : 获取枚举项的名字（字符串）。^^

  - ​`Season.SPRING.name()`​ -\> `"SPRING"`
- ​**​`ordinal()`​** : 获取枚举项的索引（从0开始）。^^

  - ​`Season.SUMMER.ordinal()`​ -\> `1`
  - *注意：尽量少用这个，因为如果你在代码里调整了枚举的顺序，这个值会变，容易引发Bu^^g。*
- ​**​`values()`​** : 返回包含所有枚举项的数组（用于遍历）。

  - ​`for (Season s : Season.values()) { ... }`
- ​**​`valueOf(String)`​** : 把字符串转回枚举对象。

  - ​`Season s = Season.valueOf("SPRING");`

---

### 总结

枚举类就是：**受限的、预定义的、自带单例属性的类。**

它比普通整数常量更安全，比普通类更简洁。

---

# 抽象类：

## 1. 认识抽象类 (Abstract Class)

想象你在设计一套“交通工具”系统。你知道所有的车都能“跑”，但“跑”的方式不一样（汽车烧油、电动车耗电）。

如果你写一个普通的 `Vehicle`​ 类，里面的 `run()` 方法该怎么写？写空着不好，写具体的又怕写错。

这时候，**抽象类**就派上用场了。

### 核心定义

- **关键字：**  `abstract`
- **本质：**  它是一个\*\*“半成品”图纸\*\*。它定义了大体结构，但留了一些关键细节不写，交给子类去填空。
- **规则：**

  1. **不能被实例化：**  你不能 `new AbstractClass()`。因为它是不完整的，没法用。
  2. **包含抽象方法：**  使用 `abstract`​ 修饰的方法只有声明，​**没有方法体**​（没有 `{}`），直接以分号结束。
  3. **子类负责填坑：**  继承抽象类的子类，**必须重写（实现）**  所有的抽象方法，除非子类自己也是抽象类。

Java

```
// 这是一个抽象类
public abstract class Animal {
    
    // 1. 普通方法：所有动物都会睡觉，逻辑一样，直接写好
    public void sleep() {
        System.out.println("闭上眼睛睡觉...");
    }

    // 2. 抽象方法：所有动物都会吃，但吃什么不一样，留给子类实现
    // 注意：没有大括号，直接分号结束
    public abstract void eat(); 
}
```

---

## 2. 使用抽象类的好处

为什么不直接用普通类？或者干脆都用接口？抽象类有它独特的生存空间：

### ① 代码复用 (Don't Repeat Yourself)

将子类中共性的代码（属性、普通方法）提取到抽象父类中。

- **例子：**  `sleep()` 方法大家逻辑都一样，写在父类里，子类直接继承，不用每人写一遍。

### ② 强制规范 (Enforcement)

通过定义 `abstract`​ 方法，父类就像一个严厉的工头，它在说：“不管你是谁，想继承我，就必须把 `eat()` 这个功能给我实现了！”

- 这就保证了所有子类都拥有某些特定的行为，虽然具体实现不同。

### ③ 多态的基石 (Polymorphism)

我们可以使用抽象类作为变量类型，指向具体的子类对象。

- ​`Animal a = new Dog();`
- ​`a.eat();` (调用的是狗的吃法)  
  这也是后续设计模式的基础。
- 更好的支持多态

> 1.抽象类中不一定要有抽象方法，有抽象方法的类必须是抽象类。  
> 2.类有的成员：成员变量、方法、构造器，抽象类都可以有。  
> 3.抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。  
> 4.一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。

---

## 3. 模板方法设计模式 (Template Method Pattern)

这是抽象类**最经典、最实战**的应用场景。几乎所有的框架（Spring, Servlet 等）都在用它。

### 什么是模板方法？

它定义了一个算法的​**骨架**，将一些步骤延迟到子类中实现。

简单说：**父类把流程定好了（第一步干啥，第二步干啥），子类只负责填具体的细节，不能改流程。**

### 场景模拟：制作热饮

不管是泡茶还是冲咖啡，流程其实是一样的：

1. 把水烧开 (通用)
2. **泡东西** (不同：泡茶/冲咖啡粉) -\> *抽象点*
3. 倒进杯子 (通用)
4. **加调料** (不同：加柠檬/加糖奶) -\> *抽象点*

### 代码实现

Java

```
public abstract class CaffeineBeverage {

    // 1. 模板方法：定义了核心流程
    // 重点：加上 final，防止子类修改这个流程！
    public final void prepareRecipe() {
        boilWater();      // 步骤1
        brew();           // 步骤2 (抽象)
        pourInCup();      // 步骤3
        addCondiments();  // 步骤4 (抽象)
    }

    // 通用具体方法
    void boilWater() {
        System.out.println("将水煮沸");
    }

    void pourInCup() {
        System.out.println("倒进杯子里");
    }

    // 抽象方法（留给子类填空）
    abstract void brew();
    abstract void addCondiments();
}
```

**具体的子类（比如茶）：**

Java

```
public class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("浸泡茶叶");
    }

    @Override
    void addCondiments() {
        System.out.println("加柠檬");
    }
}
```

**使用：**

Java

```
CaffeineBeverage myTea = new Tea();
// 你只需要调用模板方法，整个流程自动执行
myTea.prepareRecipe(); 
```

# 建议使用final关键字修饰模板方法，为什么？

- 模板方法是给子类直接使用的，不能被子类重写。一旦子类重写了模板方法，模板方法就失效了。

# 总结模板方法的好处

1. **流程封装：**  父类控制了“怎么做”（算法结构）。
2. **细节扩展：**  子类决定了“做什么”（具体实现）。
3. **符合“开闭原则”：**  想要增加一种新饮料（如热可可），只需新增一个子类，不需要修改父类的代码。

---

**下一步建议：**

你现在已经看到了抽象类的威力。但在 Java 中，还有一个和它很像的概念叫 ​ **“接口 (Interface)”** 。

**面试中被问烂了的问题：抽象类和接口到底有什么区别？什么时候该用哪个？**  你想攻克这个难点吗？

‍
