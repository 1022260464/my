---
title: day27
date: '2026-02-07 20:05:37'
updated: '2026-02-07 20:19:22'
permalink: /post/day27-z1k5ims.html
comments: true
toc: true
---



# day27

# 第八章 贪心算法 part02

### 122.买卖股票的最佳时机II

本题解法很巧妙，**本题大家可以先自己思考一下然后再看题解，会有惊喜！ **

<u>[https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html)</u>

###  55. 跳跃游戏

本题如果没接触过，很难想到，所以不要自己憋时间太久，读题思考一会，没思路立刻看题解

<u>[https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html](https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html)</u>

###  45.跳跃游戏II

本题同样不容易想出来。贪心就是这样，有的时候 会感觉简单到离谱，有时候，难的不行，主要是不容易想到。

<u>[https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html](https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html)</u>

### 1005.K次取反后最大化的数组和

本题简单一些，估计大家不用想着贪心 ，用自己直觉也会有思路。

<u>[https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html](https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html)</u>

‍

# 122.买卖股票的最佳时机II

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

```java
class Solution {
    private int[] prices;
    private int[][] memo;

    public int maxProfit(int[] prices) {
        this.prices = prices;
        int n = prices.length;
        memo = new int[n][2];
        for (int[] row : memo) {
            Arrays.fill(row, Integer.MIN_VALUE); // MIN_VALUE 表示还没有计算过
        }
        return dfs(n - 1, 0);
    }

    private int dfs(int i, int hold) {
        if (i < 0) {
            return hold == 1 ? Integer.MIN_VALUE / 2 : 0;
        }

        if (memo[i][hold] != Integer.MIN_VALUE) { // 之前计算过
            return memo[i][hold];
        }

        if (hold == 1) {
            return memo[i][hold] = Math.max(dfs(i - 1, 1), dfs(i - 1, 0) - prices[i]);
        }
        return memo[i][hold] = Math.max(dfs(i - 1, 0), dfs(i - 1, 1) + prices[i]);
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/2201406/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-o3y4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这段代码是 **LeetCode 122. 买卖股票的最佳时机 II** 的一种非常通用的解法：​**记忆化搜索（自顶向下的动态规划）** 。

  这是灵茶山艾府（EndlessCheng）非常推崇的解题模板。相比于直接写出晦涩的 `for` 循环（自底向上），这种写法更符合人类的“递归”思维，更容易推导状态转移方程。

  下面我为你详细拆解这段代码的逻辑：

  ---

  ### 1. 核心思想：状态机模型

  我们站在**第** **​`i`​**​ **天**结束时，只有两种状态：

  1. ​**持有股票 (**​**​`hold = 1`​**​ **)** ：手里有一只股票。
  2. ​**不持有股票 (**​**​`hold = 0`​**​ **)** ：手里没有股票（可能刚卖掉，或者一直没买）。

  我们的目标是：求第 `n-1`​ 天（最后一天）结束时，且​**不持有股票**​（`hold = 0`​）的情况下的最大利润。即 `dfs(n - 1, 0)`。

  ### 2. 代码逻辑逐行解析

  #### A. 状态定义与入口

  Java

  ```
  // dfs(i, hold) 表示：
  // 在第 i 天结束时，处于 hold 状态（1=持有，0=未持有）所能获得的最大累积利润。
  return dfs(n - 1, 0); 
  ```

  - 我们从最后一天往回推。最后一定要把股票卖了才划算，所以初始调用是 `dfs(n-1, 0)`。

  #### B. 递归基（边界条件）

  Java

  ```
  if (i < 0) {
      // 第 -1 天（开局之前）
      // 如果状态是“持有”，这是不可能的（还没开始怎么可能有股？），返回负无穷表示非法。
      // 除以 2 是为了防止后面计算时 overflow。
      return hold == 1 ? Integer.MIN_VALUE / 2 : 0; 
  }
  ```

  - ​`hold == 1`​: 返回 `-∞`。表示这条路走不通。
  - ​`hold == 0`​: 返回 `0`。表示还没开始交易，利润为 0。

  #### C. 记忆化（查表）

  Java

  ```
  if (memo[i][hold] != Integer.MIN_VALUE) { 
      return memo[i][hold];
  }
  ```

  - 这就是“记忆化”的核心。因为递归会有很多重复计算（比如第 3 天持有股票的状态，可能从第 4 天卖出推过来，也可能从第 4 天买入推过来），算过了就直接返回，避免超时。

  #### D. 状态转移（核心逻辑）

  **情况一：今天结束时持有股票 (**​**​`hold == 1`​**​ **)**

  Java

  ```
  if (hold == 1) {
      // 两种可能导致今天持有：
      // 1. 昨天就持有，今天啥也没干（继续持有）。 -> dfs(i-1, 1)
      // 2. 昨天没持有，今天刚买入的。 -> dfs(i-1, 0) - prices[i]
      return memo[i][hold] = Math.max(dfs(i - 1, 1), dfs(i - 1, 0) - prices[i]);
  }
  ```

  - ​**决策**：在“继续持有”和“买入”中选利润更大的。
  - ​**注意**​：本题可以多次买卖，所以买入时是 `dfs(i-1, 0) - prices[i]`​（基于之前的利润减去成本）。如果是只能买卖一次（LeetCode 121），这里就是直接 `-prices[i]`。

  **情况二：今天结束时不持有股票 (**​**​`hold == 0`​**​ **)**

  Java

  ```
  // 隐含的 else (hold == 0)
  // 两种可能导致今天不持有：
  // 1. 昨天就不持有，今天啥也没干（观望）。 -> dfs(i-1, 0)
  // 2. 昨天持有，今天刚卖出的。 -> dfs(i-1, 1) + prices[i]
  return memo[i][hold] = Math.max(dfs(i - 1, 0), dfs(i - 1, 1) + prices[i]);
  ```

  - ​**决策**：在“观望”和“卖出”中选利润更大的。

  ---

  ### 3. 图解状态转移

  我们可以把这个逻辑画成一个简单的状态机图：

  - ​**Rest (休息)** : 状态不变。
  - ​**Buy (买入)** ​: 从 `0`​ 变 `1`，利润减少（扣除股价）。
  - ​**Sell (卖出)** ​: 从 `1`​ 变 `0`，利润增加（获得股价）。

  ### 4. 为什么要用 `Integer.MIN_VALUE / 2`？

  这是一个常见的编程技巧。

  - 如果直接返回 `Integer.MIN_VALUE`（大约 -21亿）。
  - 当代码执行 `dfs(i - 1, 0) - prices[i]`​ 时，如果 `dfs`​ 返回了 -21亿，再减去一个正数 `prices[i]`​，就会发生 ​**整数溢出 (Underflow)** ，变成一个很大的正数，导致逻辑错误。
  - 除以 2 后，它依然是一个足够小的负数，可以安全地进行加减运算而不溢出。

  ### 5. 总结与复杂度

  - ​**时间复杂度**: $O(N)$。

    - 一共有 $N$ 天，每天有 2 种状态（持有/不持有）。
    - 状态总数是 $2N$，每个状态只计算一次。
  - ​**空间复杂度**: $O(N)$。

    - 需要 `memo` 数组存储状态，以及递归栈的深度。

  **灵神的这个模板的强大之处在于：**

  它不仅仅解决了这道题，只要稍微修改状态转移方程，它能通杀 LeetCode 上​**所有的股票买卖问题**（如：只能买卖一次、买卖含手续费、买卖含冷冻期、最多买卖 k 次等）。

  **下一步建议：**

  你现在看懂了**自顶向下（递归）的写法。为了面试，通常建议将其改写为自底向上（迭代 DP）的写法，然后进一步优化为空间 O(1)**  的写法（滚动变量）。你想看这两个优化版本吗？

# 55. 跳跃游戏

[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/description/)

```java
class Solution {
    public boolean canJump(int[] nums) {
        int mx = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > mx) { // 无法到达 i
                return false;
            }
            mx = Math.max(mx, i + nums[i]); // 从 i 最右可以跳到 i + nums[i]
        }
        return true;
    }
}

class Solution {
    public boolean canJump(int[] nums) {
        int mx = 0;
        for (int i = 0; mx < nums.length - 1; i++) {
            if (i > mx) { // 无法到达 i
                return false;
            }
            mx = Math.max(mx, i + nums[i]); // 从 i 最右可以跳到 i + nums[i]
        }
        return true;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/jump-game/solutions/2798996/liang-chong-li-jie-fang-shi-wei-hu-zui-y-q67s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这两段代码是 **LeetCode 55. 跳跃游戏 (Jump Game)**  的两种非常精妙的 **贪心算法 (Greedy Algorithm)**  实现。

  作者 **灵茶山艾府 (EndlessCheng)**  再次展示了他对代码逻辑的极致压缩和优化。

  核心思想其实非常简单：**不要纠结具体怎么跳（走哪一步），只关心“最远能跳到哪里”。**

  我为你对比解析这两段代码的异同和精髓。

  ---

  ### 1. 核心逻辑：维护最远到达距离 (`mx`)

  不管哪种写法，它们共享同一个贪心策略：

  1. ​**维护变量** **​`mx`​**​：表示当前能到达的​**最右边的索引**。
  2. ​**遍历数组**​：我们假设自己依次走过数组的每个位置 `i`。
  3. ​**生死判断 (**​**​`i > mx`​**​ **)** ：

     - 如果我们当前遍历到了位置 `i`​，但是 `mx < i`​，说明之前的跳跃力不够，​**根本跳不到位置** **​`i`​**。
     - 既然连 `i`​ 都到不了，更别提终点了，直接返回 `false`。
  4. ​**更新最远距离 (**​**​`mx = max(...)`​** ​ **)** ：

     - 如果能到达 `i`​，那么站在 `i` 这个位置，我们要看看能不能跳得更远。
     - 从 `i`​ 起跳能到的最远位置是 `i + nums[i]`。
     - 我们更新 `mx`。

  ---

  ### 2. 写法一：标准遍历 (Standard Traversal)

  Java

  ```
  public boolean canJump(int[] nums) {
      int mx = 0;
      for (int i = 0; i < nums.length; i++) { // 遍历每一个位置
          if (i > mx) { // 悲剧发生：当前位置 i 已经超出了最远能达到的范围
              return false;
          }
          mx = Math.max(mx, i + nums[i]); // 更新最远射程
      }
      return true; // 居然坚持遍历完了数组，说明中间没有断档，肯定能到最后
  }
  ```

  - ​**逻辑**：老老实实地从第 0 个格子走到最后一个格子。
  - ​**特点**​：只要中间没断档（`i <= mx`​），它就会一直检查直到数组结束。即使 `mx` 早就超过终点了，它也会把剩下的循环跑完。

  ---

  ### 3. 写法二：提前退出优化 (Early Exit Optimization)

  这是灵神对贪心逻辑的进一步优化，非常秀：

  Java

  ```
  public boolean canJump(int[] nums) {
      int mx = 0;
      // 循环条件变了！只要 mx 还没覆盖到终点 (nums.length - 1)，就继续循环
      for (int i = 0; mx < nums.length - 1; i++) {
          if (i > mx) { // 同样的生死判断
              return false;
          }
          mx = Math.max(mx, i + nums[i]);
      }
      return true;
  }
  ```

  - ​**逻辑变化**：

    - ​`mx < nums.length - 1`​：这个循环条件的意思是——“只要我能跳的最远距离 `mx` 还没有覆盖到最后一个下标，我就得继续找跳板。”
    - ​**反之**​：一旦某一步更新后，`mx >= nums.length - 1`​，说明​**我已经能跳到终点（甚至更远）了**​。那剩下的格子就不用看了，直接退出循环，返回 `true`。
  - ​**举个例子**​：  
    ​`nums = [10, 1, 1, 1, 1]`

    - ​**写法一**：会遍历完后面所有的 1。
    - ​**写法二**​：在 `i=0`​ 时，`mx`​ 变成了 10 (也就是 `0 + 10`​)。此时 `10 >= 4`​，直接结束循环返回 `true`。效率更高。

  ### 4. 总结与复杂度

  这道题是 **贪心算法** 的教科书级案例。

  - **为什么是贪心？**

    - 我们不需要知道具体的跳跃路径（比如是 0-\>2-\>4 还是 0-\>1-\>4）。
    - 我们只贪心地维护一个\*\*“当前能覆盖的最大范围”\*\*。只要这个范围能覆盖到终点，就赢了。
  - ​**复杂度分析**：

    - ​**时间复杂度**：$O(N)$。写法一遍历一次数组；写法二最好情况 $O(1)$，最坏情况 $O(N)$。
    - ​**空间复杂度**：$O(1)$。只用了一个变量 `mx`。

  **下一步建议：**

  这道题是 ​**Jump Game I**。

  它的进阶版 **LeetCode 45. 跳跃游戏 II (Jump Game II)**  要求的是“最少跳几次能到达终点”。

  那道题的贪心策略稍微不同（需要维护当前步的边界 `end`​ 和下一步的最远边界 `maxPos`）。你想看看那道题的解法吗？

# 45.跳跃游戏 II

[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/description/)

```java
class Solution {
    public int jump(int[] nums) {
        int ans = 0;
        int curRight = 0; // 已建造的桥的右端点
        int nextRight = 0; // 下一座桥的右端点的最大值
        for (int i = 0; i < nums.length - 1; i++) {
            // 遍历的过程中，记录下一座桥的最远点
            nextRight = Math.max(nextRight, i + nums[i]);
            if (i == curRight) { // 无路可走，必须建桥
                curRight = nextRight; // 建桥后，最远可以到达 next_right
                ans++;
            }
        }
        return ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/jump-game-ii/solutions/2926993/tu-jie-yi-zhang-tu-miao-dong-tiao-yue-yo-h2d4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这段代码是 **LeetCode 45. 跳跃游戏 II (Jump Game II)**  的解法。

  相比于上一题（55题）只问“能不能跳到”，这道题问的是  **“最少跳几次”** 。

  灵茶山艾府（灵神）在这里使用了一个非常生动的  **“造桥” (Building Bridges)**  的隐喻，把 **贪心算法** 的逻辑具象化了。这本质上也是 **BFS（广度优先搜索）**  的一种贪心优化形式。

  ### 1. 核心隐喻：造桥铺路

  想象你在玩一个铺路游戏：

  - ​**​`curRight`​**​  **(当前桥的右端点)** ：你现在已经造好的桥，最远能让你走到哪里。也就是  **“第 k 步能到达的最远位置”** 。
  - ​**​`nextRight`​**​  **(下一座桥的极限)** ：如果你决定再多造一座桥（再多跳一步），利用当前范围内的任意一点起跳，你最远能铺到哪里。
  - ​**​`ans`​**​  **(造桥数量)** ：必须造几座桥才能覆盖全程。

  ### 2. 代码逻辑逐行拆解

  ```java
  // 循环范围：只遍历到 nums.length - 2
  // 为什么？因为如果 i 到了最后一个位置，我们已经到了终点，不需要再起跳了。
  for (int i = 0; i < nums.length - 1; i++) {
      
      // 1. 贪心搜索：在当前覆盖范围内，寻找下一跳能到达的最远距离
      // 这就像是在当前这根桥上走的时候，不断在看“下一根桥”最远能架到哪
      nextRight = Math.max(nextRight, i + nums[i]);

      // 2. 边界判断：走到当前桥的尽头了
      if (i == curRight) { 
          // 既然路走完了，必须强制造一座新桥（跳一步）
          curRight = nextRight; // 更新当前能到达的最远边界
          ans++; // 步数 + 1
      }
  }

  ```

  ### 3. 图解演示

  假设 `nums = [2, 3, 1, 1, 4]`。

  1. **初始状态**：`ans=0`​, `curRight=0`​, `nextRight=0`。
  2. **i = 0 (值2)** :

  - ​`nextRight`​ 更新为 `0 + 2 = 2`。
  - ​`i == curRight (0)`​：**必须起跳**。
  - ​`ans`​ 变为 1，`curRight` 变为 2。
  - **含义**：第 1 步最远能覆盖到索引 2。

  3. **i = 1 (值3)** :

  - ​`nextRight`​ 更新为 `1 + 3 = 4` (更远了！)。
  - ​`i != curRight (2)`：还没到边界，继续走。

  4. **i = 2 (值1)** :

  - ​`nextRight`​ 更新为 `max(4, 2+1) = 4`。
  - ​`i == curRight (2)`​：**走到第 1 步的边界了，必须跳第 2 步**。
  - ​`ans`​ 变为 2，`curRight` 变为 4。
  - **含义**：第 2 步最远能覆盖到索引 4。

  5. **结束**：循环只到 `len-2`​ (索引3)。因为 `curRight` 已经是 4（终点），我们实际上已经覆盖了终点。

  ### 4. 关键点：为什么只遍历到 `nums.length - 2`？

  这是这段代码最容易让人困惑，也最精妙的地方。

  - **题目保证能到达终点**。
  - 如果我们遍历到了最后一个元素 `nums.length - 1`：
  - 假设在 `i = nums.length - 1`​ 时，刚好 `i == curRight`。
  - 此时代码会执行 `ans++`。
  - **但这步是多余的！**  因为我们人已经站在终点了，不需要再跳一步了。
  - **结论**：我们在起跳点（索引 `i`）做决策。最后一个位置是目的地，不是起跳点，所以不需要遍历它。

  ### 5. 总结

  这道题的贪心策略是：  
   **“每次到了边界不得不跳的时候，才把步数加一，并且跳到当前能触及的最远位置。”**

  - **时间复杂度**: 。只遍历一次数组。
  - **空间复杂度**: 。

  至此，**贪心算法 (Greedy)**  的几个经典题目你都看过了：

  1. **分发饼干**：简单贪心（排序匹配）。
  2. **摆动序列**：找峰值（忽略中间过程）。
  3. **跳跃游戏 I**：覆盖范围（能不能到）。
  4. **跳跃游戏 II**：最小步数（BFS 思想的贪心）。

  **下一步建议：**   
  如果你想换个口味，可以开始接触 **动态规划 (Dynamic Programming)**  中最经典的  **“打家劫舍” (House Robber)**  系列。那是理解 DP 状态转移方程的最佳起点。需要我为你介绍吗？

# 1005.K次取反后最大化的数组和

[1005. K 次取反后最大化的数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/solutions/)

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums); // 从小到大排序

        int sum = 0;
        int mn = Integer.MAX_VALUE;
        for (int x : nums) { // 优先改最小的
            if (k > 0 && x < 0) { // 还有修改次数，且 x 是负数
                x = -x; // 取反
                k--; // 消耗一次修改次数
            }
            sum += x;
            mn = Math.min(mn, x);
        }

        // 如果剩余的 k 是奇数，选最小的数取反
        return sum - (k % 2 > 0 ? mn * 2 : 0);
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/solutions/3752775/jian-dan-ti-jian-dan-zuo-pythonjavaccgoj-uj5k/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

‍

- 这段代码是 **LeetCode 1005. K 次取反后最大化的数组和** 的解法。

  作者灵茶山艾府（EndlessCheng）依然稳定发挥，这段代码非常精炼地展示了 **贪心算法 (Greedy Algorithm)**  的应用。

  这道题的核心逻辑可以概括为：​ **“两害相权取其轻”** 。

  我为你拆解这段代码的三个关键步骤。

  ---

  ### 1. 第一步：贪心策略 —— 优先拯救“负得最多”的数

  Java

  ```
  Arrays.sort(nums); // 从小到大排序
  ```
  **为什么排序？**

  我们要把负数变成正数，才能让总和变大。

  - 比如 `[-10, -1, 5]`​，如果你把 `-1`​ 变成 `1`，总和增加 2。
  - 如果你把 `-10`​ 变成 `10`，总和增加 20。
  - ​**结论**​：我们要优先反转那些 ​ **“最小的负数”** （绝对值最大的负数）。排序后，负数都会排在最前面，从小到大处理即可。

  ### 2. 第二步：消除负数 & 维护最小值

  Java

  ```
  int sum = 0;
  int mn = Integer.MAX_VALUE; // 用于记录当前数组中绝对值最小的数

  for (int x : nums) {
      // 贪心核心：只要还有次数(k>0)，且当前是负数(x<0)，就把它反转
      if (k > 0 && x < 0) {
          x = -x; // 负变正
          k--;    // 消耗一次次数
      }
      
      sum += x; // 累加当前的数（可能是被反转过的正数，也可能是原样）
      mn = Math.min(mn, x); // 关键：记录当前所有数中，最小的那个非负数
  }
  ```
  **这里的** **​`mn`​**​ **是做什么的？**

  这是一个伏笔。

  假设 `nums = [-5, -2, 3], k = 4`。

  1. ​`-5`​ 变 `5`，k 剩 3。
  2. ​`-2`​ 变 `2`，k 剩 2。
  3. ​`3`​ 还是 `3`​。  
     此时数组变成了 `[5, 2, 3]`​，负数都没了，但 `k`​ 还剩 2 次。我们需要在剩下的数组里找一个“替罪羊”来消耗这剩下的 `k`​ 次。为了让损失最小，我们必须找 ​**当前数组中最小的非负数**（这里是 2）。

  ### 3. 第三步：处理剩余次数 (收尾)

  Java

  ```
  // 如果剩余的 k 是奇数，选最小的数取反
  return sum - (k % 2 > 0 ? mn * 2 : 0);
  ```
  **逻辑推导：**

  此时我们已经遍历完数组，所有的负数（在 `k` 足够的情况下）都变成了正数。

  - **情况 A：**​**​`k`​**​ **剩偶数次 (例如 2, 4...)**

    - 我们可以对着同一个数反转两次（正 -\> 负 -\> 正）。
    - 结果不变。直接返回 `sum`。
  - **情况 B：**​**​`k`​**​ **剩奇数次 (例如 1, 3...)**

    - 我们必须把某个数变号一次。
    - 为了让总和损失最小，我们选刚才记录的 **​`mn`​**​  **(最小的正数)**  把它变成负数。
    - ​**数学计算**​：当前的 `sum`​ 里是包含了 `+mn`​ 的。如果我们把它变成 `-mn`，总和的变化是：

      $$
      NewSum = Sum - mn + (-mn) = Sum - 2 \cdot mn
      $$
    - 这就是代码中 `- mn * 2` 的由来。

  ---

  ### 示例演示

  输入：`nums = [2, -3, -1, 5, -4]`​, `k = 2`

  1. ​**排序**​：`[-4, -3, -1, 2, 5]`
  2. ​**遍历**：

     - 遇到 `-4`​：`k>0`​, 变 `4`​。`k=1`​。`sum+=4`​。`mn=4`。
     - 遇到 `-3`​：`k>0`​, 变 `3`​。`k=0`​。`sum+=3`​。`mn=3`。
     - 遇到 `-1`​：`k=0`​, 不变。`sum+=(-1)`​。`mn`​ 更新为 `Math.min(3, -1)`​ \=  **-1** (注意：这里的 mn 实际上代码逻辑里如果 k 用完了，mn 记录的可能是剩下的负数，但在本题逻辑中，如果 k 用完了，mn 其实就不重要了，因为 k%2\=\=0，后面不会用到 mn)。

  ​**修正理解（针对 k 没用完的情况）** ：

  假设 `nums = [-4, -3], k = 3`。

  1. 排序：`[-4, -3]`。
  2. 遇到 `-4`​：变 `4`​，`k=2`​，`sum=4`​，`mn=4`。
  3. 遇到 `-3`​：变 `3`​，`k=1`​，`sum=7`​，`mn=3`。
  4. 结束循环。此时 `sum=7`​，`mn=3`​ (数组其实是 `[4, 3]`​)，`k=1`。
  5. ​`k`​ 是奇数，必须消耗一次。挑最小的 `mn=3` 反转。
  6. 结果：`7 - 3*2 = 1`​。 (相当于数组变成 `[4, -3]`)。

  ### 总结

  这段代码的巧妙之处在于它 **一次遍历** 完成了三件事：

  1. 负责把负数翻正。
  2. 负责计算总和。
  3. 负责寻找“如果不小心 k 剩下了，该牺牲谁”。

  - ​**时间复杂度**：$O(N \log N)$，主要在排序。
  - ​**空间复杂度**：$O(1)$。

  **下一步：**

  这道题有一个稍微高级一点的版本：如果不允许排序，或者数据范围很大（桶排序），怎么做？不过在通常面试中，这种 $O(N \log N)$ 的解法已经是标准答案了。

  至此，你已经看完了 **贪心算法** 的几个重要切面：

  1. **区间/分配问题** (饼干)
  2. **序列波动** (摆动序列)
  3. **覆盖范围** (跳跃游戏)
  4. **数值修饰** (K次取反 - 本题)

  接下来，我们可以换一个全新的领域，比如 **二分查找 (Binary Search)**  的花式变种，或者继续深入 ​**动态规划 (DP)** ？
