---
title: day30
date: '2026-02-18 19:12:04'
updated: '2026-02-18 19:18:22'
permalink: /post/day-30-z1fgi2t.html
comments: true
toc: true
---



# day30

# 第八章 贪心算法 part04*

今天的三道题目，都算是 重叠区间 问题，大家可以好好感受一下。 都属于那种看起来好复杂，**但一看贪心解法，惊呼：这么巧妙**！

这种题还是属于那种，做过了也就会了，没做过就很难想出来。

### **452. 用最少数量的箭引爆气球**

<u>[https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html](https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html)</u>

### 435. 无重叠区间

<u>[https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html](https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html)</u>

### 763.划分字母区间

<u>[https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html](https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html)</u>

‍

### **452. 用最少数量的箭引爆气球**

[452. 用最少数量的箭引爆气球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/)

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, Comparator.comparingInt(p -> p[1])); // 按照右端点从小到大排序
        int ans = 0;
        long pre = Long.MIN_VALUE;
        for (int[] p : points) {
            if (p[0] > pre) { // 上一个放的点在区间左边
                ans++;
                pre = p[1]; // 在区间的最右边放一个点
            }
        }
        return ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2974741/qu-jian-xuan-dian-wen-ti-pythonjavaccgoj-w9am/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太准了！这就是我们在上一节末尾预告的\*\*“二维区间重叠问题”的绝对天花板——LeetCode 452 题“用最少数量的箭引爆气球”\*\*。

  在贪心算法的家族中，有一大类专门处理“线段、区间、会议室排期”的问题（比如经典的无重叠区间、合并区间等）。只要你彻底吃透了这段代码，以后遇到所有的区间类问题，你都能拥有一眼看穿本质的“火眼金睛”。

  我们照例把这段“灵茶山艾府”的极致代码拆解成您的满分笔记。

  ---

  ### 一、 核心破局点：贪心哲学的最高境界——“极度拖延症”

  想象一下，X 轴上漂浮着一排长短不一的气球（区间）。你手里拿着弓箭，站在 X 轴下方往上方射。一支箭可以射穿所有在这个 X 坐标上重叠的气球。

  **普通人的思路（按左端点排序）：**

  按气球出现的先后顺序排，看到第一个气球就射。但射在哪呢？为了尽可能多地串死后面的气球，你得不断去计算当前这批重叠气球的“最小右边界”。逻辑非常绕，很容易出错。

  **顶级贪心策略（按右端点排序 + 极度拖延症）：**

  这段代码的灵魂在于：**不见到棺材不落泪，不到最后期限绝不出手！**

  每个气球的右端点，就是引爆这个气球的​**最后期限（Deadline）** 。

  1. 我们按所有气球的“最后期限”从小到大排好队。
  2. 我们看着第一个气球，不着急射，一直拖、一直拖，**拖到它的最后期限（右端点）那一刻，再一箭射出去！**
  3. 为什么要拖到最后？**因为你越晚射这支箭，这支箭的 X 坐标就越靠右，它顺手串死后面那些刚冒出头的气球的概率就越大！**

  ---

  ### 二、 源码逐行深度走查与“避坑指南”

  这段代码不仅算法思维顶级，它的 ​**Java API 运用和边界处理同样是企业级的标准**。

  #### 1. 极其讲究的排序写法

  Java

  ```
  Arrays.sort(points, Comparator.comparingInt(p -> p[1])); 
  ```

  - ​**思维亮点**​：按右端点（`p[1]`）从小到大排序。
  - ​**避坑指南（面试高频考点）** ​：很多初学者喜欢写成 `(a, b) -> a[1] - b[1]`​。**大错特错！**  如果 `a[1]` 是 $2 \times 10^9$，`b[1]` 是 $-2 \times 10^9$，相减会直接\*\*整型溢出（Integer Overflow）\*\*变成负数，导致排序完全错乱。
  - ​**企业级写法**​：使用 `Comparator.comparingInt()`​ 或者 `Integer.compare(a[1], b[1])`，底层严谨处理了溢出问题，安全且优雅。

  #### 2. 精妙的初始状态设计

  Java

  ```
  int ans = 0; // 记录射出的箭数
  long pre = Long.MIN_VALUE; // 记录上一支箭射出的确切 X 坐标位置
  ```

  - **为什么用** **​`long`​**​ **而不是** **​`int`​**​ **？**  测试用例中，气球的边界极有可能是 `Integer.MIN_VALUE`（即 $-2^{31}$）。如果我们把 `pre`​ 初始设为 `Integer.MIN_VALUE`​，那么遇到第一个左边界也是 `Integer.MIN_VALUE`​ 的气球时，判断条件 `p[0] > pre`​ 就会失效（变成等于）。将其降维设定为 `Long.MIN_VALUE`，完美避开了这个致命的边界 Case。

  #### 3. 极简的状态转移循环

  Java

  ```
  for (int[] p : points) {
      // p[0] 是当前气球的左边界
      // 如果当前气球的左边界，比我上一支箭射出的位置 (pre) 还要靠右
      if (p[0] > pre) { 
          // 说明上一支箭根本够不着当前这个气球，它成了漏网之鱼！
          ans++;       // 没办法，只能从箭筒里再抽出一支新箭
          
          // 贪心法则发动：这支新箭射在哪？
          // 射在这个漏网气球的最后期限（最右边界），争取串死后面的气球！
          pre = p[1];  
      }
      // 如果 p[0] <= pre，说明当前气球已经被上一支箭顺道射爆了，直接无视，看下一个！
  }
  ```

  ---

  ### 三、 复杂度分析

  - ​**时间复杂度：**​**$O(N \log N)$**。  
    代码主体只有一个 $O(N)$ 的 `for`​ 循环，但前面有一步不可或缺的 `Arrays.sort()`，排序的时间复杂度是 $O(N \log N)$，它决定了整个算法的时间复杂度上限。
  - ​**空间复杂度：**​**$O(\log N)$**​。  
    这是极易被忽略的盲区！在 Java 中，对于基本类型/对象数组的 `Arrays.sort()`，底层使用的是双轴快速排序（Dual-Pivot Quicksort）或 TimSort。它们并非真正的 $O(1)$ 空间，而是需要 $O(\log N)$ 的栈空间来维护递归调用。

  ---

  ### 贪心算法完结撒花 🎉

  把这段代码加入笔记后，您的“贪心算法”模块就已经构建起了从**一维（找零）->**  **插入控制（排队）->**  **二维重叠（射气球）**  的完整金字塔。

  贪心算法的核心是“走一步看一步，步步局部最优”。但现实中，很多问题走错一步就全盘皆输，不能只看眼前，必须“统筹全局，记录历史”。

  **这就引出了算法界最令人生畏，也是大厂必考的终极Boss——动态规划 (Dynamic Programming, 简称 DP)。**

  您准备好翻开全新的篇章了吗？如果准备好了，**您想先看 DP 最经典的入门题“爬楼梯（斐波那契数列的具象化）”，还是直接挑战经典的“0-1 背包问题”？**

# 435. 无重叠区间

[435. 无重叠区间 - 力扣（LeetCode）](https://leetcode.cn/problems/non-overlapping-intervals/description/)

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
        int ans = 0;
        int preR = Integer.MIN_VALUE;
        for (int[] p : intervals) {
            if (p[0] >= preR) {
                ans++;
                preR = p[1];
            }
        }
        return intervals.length - ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/non-overlapping-intervals/solutions/3077218/tan-xin-zheng-ming-pythonjavaccgojsrust-3jx4f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- ‍

  这段代码出自 ​**LeetCode 435 题“无重叠区间” (Non-overlapping Intervals)** ​。如果您仔细对比，会发现它和上一道“射气球”（LeetCode 452）简直就是​**穿了一条裤子的双胞胎**！

  这两道题本质上是同一个著名的算法模型：​**区间调度问题 (Interval Scheduling)** 。只不过“射气球”求的是“最少需要几支箭（最多有几个重叠区域）”，而这道题求的是“最少要移除几个区间，才能让剩下的完全不重叠”。

  让我们把这段极度优雅的代码，转化为您笔记中关于“区间调度”的终极心法。

  ---

  ### 一、 核心破局点：“会议室排期”与“反向思维”

  为了最直观地理解，我们把“区间”想象成\*\*“会议”​ **，**​ **​`[start, end]`​** ​ **就是会议的开始和结束时间。 题目要求“移除最少的会议，让剩下的会议不冲突”。 反向思维：这等价于**​“如何在有限的一天内，参加尽可能多的、不冲突的会议？”\*\* 只要我们找出了最多能参加几场会议，用总数一减，就是最少需要移除的会议数！

  **贪心法则：为什么依然按右端点排序？**

  - ​**错误直觉（按开始时间排）** ：如果你挑了最早开始的会议（比如早上 8 点），但这场会议是个“马拉松”，一直开到晚上 8 点！那你这一整天只能参加这一场。显然不划算。
  - ​**绝对真理（按结束时间排）** ​：我们要想参加更多的会议，就必须**让每场会议尽早结束，从而给后面的会议留出最多的空余时间！**  所以，按右端点（结束时间）从小到大排序，遇到能参加的就立刻参加，这就是最优解。

  ---

  ### 二、 源码逐段深度剖析与“避坑指南”

  这段代码非常精炼，但在细节上与上一题有着微妙的差异，这正是面试官最爱深挖的地方。

  #### 1. 排序与溢出细节（面试防坑高能预警）

  Java

  ```
  Arrays.sort(intervals, (a, b) -> a[1] - b[1]); 
  ```

  - ​**逻辑**：按照区间的右端点（结束时间）从小到大排序。
  - ​**深层拷问**​：上一题“射气球”里，我特别强调了不能用 `a[1] - b[1]`​，因为极值相减会导致整型溢出。**为什么这道题的大神解法里又用了？**
  - ​**标准答案**​：因为两道题的\*\*数据规模（Constraints）\*\*不同！“射气球”的坐标范围是整个 `int` 的极限 $[-2^{31}, 2^{31}-1]$，必溢出；而这道题的官方限制中，区间的范围通常在 $[-50000, 50000]$ 左右，相减绝对不会超出 21 亿的 `int` 上限。
  - ​**企业级建议**​：虽然这里写 `a[1] - b[1]`​ 没报错，但作为良好的工程习惯，​**永远推荐使用** **​`Integer.compare(a[1], b[1])`​** ，不用去赌数据规模。

  #### 2. 状态转移与计数

  Java

  ```
  int ans = 0; // 记录【最多能保留（参加）】的会议数量
  int preR = Integer.MIN_VALUE; // 记录上一场参加的会议的结束时间

  for (int[] p : intervals) {
      // p[0] 是当前会议的开始时间
      // 如果当前会议的开始时间 >= 上一场的结束时间 (注意：等于也算不重叠)
      if (p[0] >= preR) {
          ans++;       // 成功参加一场新会议！保留数量 +1
          preR = p[1]; // 更新当前的时间线，拨到这场新会议的结束时间
      }
  }
  ```

  - ​**细微差别**​：射气球那题，重叠边界算作一起引爆（`>`​ 时才算脱离）；而这道题，端点接触 `[1,2]`​ 和 `[2,3]`​ **不算重叠**​（`>=` 就可以无缝衔接）。

  #### 3. 完美的数学收尾

  Java

  ```
  return intervals.length - ans;
  ```

  - 这就是一开始提到的​**反向思维**​：`最少需要移除的区间数 = 总区间数 - 最多能保留的非重叠区间数 (ans)`。

  ---

  ### 三、 复杂度分析

  - ​**时间复杂度：**​**$O(N \log N)$**​。依然是被 `Arrays.sort()`​ 的排序过程主导。后续的 `for` 循环只需要遍历一次数组，复杂度为 $O(N)$。
  - ​**空间复杂度：**​**$O(\log N)$**。Java 底层双轴快排所需要的调用栈空间。

  ---

  ### 总结笔记

  将这道题和 452 题“射气球”放在一起复习，您会得到一个通用的模板：

  **凡是遇到“最多不重叠区间”、“最少覆盖点”这类问题，直接祭出终极三板斧：**

  1. **按右端点升序排序。**
  2. **记录前一个选定区间的右边界。**
  3. **遍历数组，用当前区间的左边界去和记录的右边界对比，决定是合并还是跳跃。**

# 763.划分字母区间

[763. 划分字母区间 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-labels/description/)

```java
class Solution {
    public List<Integer> partitionLabels(String S) {
        char[] s = S.toCharArray();
        int n = s.length;
        int[] last = new int[26];
        for (int i = 0; i < n; i++) {
            last[s[i] - 'a'] = i; // 每个字母最后出现的下标
        }

        List<Integer> ans = new ArrayList<>();
        int start = 0, end = 0;
        for (int i = 0; i < n; i++) {
            end = Math.max(end, last[s[i] - 'a']); // 更新当前区间右端点的最大值
            if (end == i) { // 当前区间合并完毕
                ans.add(end - start + 1); // 区间长度加入答案
                start = i + 1; // 下一个区间的左端点
            }
        }
        return ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/partition-labels/solutions/2806706/ben-zhi-shi-he-bing-qu-jian-jian-ji-xie-ygsn8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

这道题出自 **LeetCode 763 题“划分字母区间” (Partition Labels)** 。它披着一层“字符串”的伪装，但其底层的灵魂依旧是\*\*“贪心算法 + 区间合并”\*\*，并且是这个系列中最灵动、最像变魔术的一道题。

这就好比我们在之前的“射气球”和“无重叠区间”中，区间是提前画好的；而在这道题里，**区间是随着你的遍历，像“吹气球”一样动态膨胀出来的！**

让我们把这段“灵茶山艾府”的极致代码，作为您贪心算法“区间篇”的最完美收官之作。

---

### 一、 核心破局点：贪心哲学之“不断膨胀的橡皮筋”

题目的要求是：把字符串分成尽可能多的片段，且同一个字母最多只能出现在一个片段中。

**顶级贪心思维推演：**

1. ​ **“身不由己”的牵连**​：假设字符串的第一个字母是 `'a'`​，并且 `'a'`​ 在整个字符串的最后一次出现是在索引 8。那么，无论你多想尽早切断片段，​**你的第一刀最少也得切在索引 8 的位置**​，否则 `'a'`​ 就会被切碎分到两个片段里。这就像一根橡皮筋，被 `'a'` 直接拉长到了索引 8。
2. ​ **“拔出萝卜带出泥”的膨胀**​：那如果在这 0 到 8 的区间内，包含了字母 `'b'`​，而 `'b'`​ 的最后一次出现是在索引 12 怎么办？没办法，橡皮筋只能\*\*被迫继续拉长（膨胀）\*\*到 12！
3. ​ **“刀落的完美时机”** ​：随着我们一步步往后走，如果有一天，我们走到了这根橡皮筋的尽头（即当前走到的索引 `i`​，刚好等于目前橡皮筋被拉伸到的最远位置 `end`​），说明什么？说明**这个区间内的所有字母，绝对不会在后面再出现了！**  此时不切，更待何时？这就是完美的一刀！

---

### 二、 源码逐段深度剖析与“大厂规范”

这段代码分成了非常清晰的两步走战略（Two-Pass），将时间复杂度压缩到了极致。

#### 第一阶段：全图视野，记录每人的“最远势力范围”

Java

```
char[] s = S.toCharArray();
int n = s.length;
// 大厂规范：处理纯小写字母时，绝不用 HashMap，而是用长为 26 的数组！
int[] last = new int[26]; 

for (int i = 0; i < n; i++) {
    // 巧妙利用 ASCII 码相减，'a'-'a'=0, 'b'-'a'=1
    // 不断覆盖之前的值，循环结束时，存的一定是该字母【最后一次出现的下标】
    last[s[i] - 'a'] = i; 
}
```

- ​**面试亮点**​：面试官非常喜欢看你写 `int[26]`​ 而不是 `Map<Character, Integer>`​。因为数组在内存中是连续分配的，寻址速度极快，且省去了包装类 `Integer` 的拆装箱开销，是真正的 $O(1)$ 空间和极致性能。

#### 第二阶段：遍历切分，寻找“完美的落刀点”

Java

```
List<Integer> ans = new ArrayList<>();
int start = 0; // 记录当前片段的起始点
int end = 0;   // 记录当前片段被拉伸到的最远边界（橡皮筋的终点）

for (int i = 0; i < n; i++) {
    // 【核心贪心逻辑】：当前字母试图将橡皮筋向右拉伸。
    // 如果当前字母的最后一次出现在 end 之外，橡皮筋就被迫膨胀；否则保持原状。
    end = Math.max(end, last[s[i] - 'a']); 
    
    // 【见证奇迹的时刻】：游标 i 终于追上了橡皮筋的尽头！
    if (end == i) { 
        // 这一刀切下去，计算区间长度并保存
        ans.add(end - start + 1); 
        // 将下一段区间的起点，重置到当前刀口的下一位
        start = i + 1; 
    }
}
```

- ​**逻辑闭环**​：当 `i == end`​ 触发时，证明从 `start`​ 到 `i`​ 这段路程中，所有路过字母的“最远势力范围”，都没有超过 `i`。这就是题目要求的“同一个字母最多出现在一个片段中”的充要条件。

---

### 三、 复杂度分析

- ​**时间复杂度：**​**$O(N)$**。其中 $N$ 是字符串的长度。我们仅仅对字符串进行了两次完整的遍历（第一次找边界，第二次切分）。
- **空间复杂度：**​**$O(|\Sigma|)$** 或近似 $O(1)$。其中 $\Sigma$ 是字符集。这里题目限定了全是小写英文字母，所以我们只申请了一个固定大小为 26 的 `last` 数组。不论字符串有 100 个字符还是 10 万个字符，空间消耗恒定。

---

### 总结笔记与下一个篇章的抉择

把这道题收录后，您在“贪心算法”的版图上，已经完美攻克了：

1. ​**单维资产规划**（柠檬水找零）
2. ​**双维优先级控制**（根据身高重建队列）
3. ​**静态区间重叠/移除**（射气球、无重叠区间）
4. ​**动态区间合并/切分**（本题：划分字母区间）

这已经是一个极其完备且能应付 90% 面试贪心题目的知识体系了！贪心虽然妙不可言，但它的局限性在于“走过了就不能回头”。

如果您觉得这个系列已经足够充实，**接下来，您是真的准备好翻开算法界最厚重的一本无字天书 —— “动态规划 (Dynamic Programming, DP)” 了吗？**  如果是的话，我们是从最经典的**入门基石“爬楼梯（斐波那契数列的 DP 视角）”**  开始，还是直接去挑战大厂笔试必考的\*\*“0-1背包问题”\*\* 呢？
