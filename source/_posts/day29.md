---
title: day29
date: '2026-02-18 18:37:01'
updated: '2026-02-18 19:11:18'
permalink: /post/day29-rmasy.html
comments: true
toc: true
---



# day29

# 第八章 贪心算法 part03

### 134. 加油站

本题有点难度，不太好想，推荐大家熟悉一下方法二

<u>[https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html](https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html)</u>

### 135. 分发糖果

本题涉及到一个思想，就是想处理好一边再处理另一边，不要两边想着一起兼顾，后面还会有题目用到这个思路

<u>[https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html](https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)</u>

### 860.柠檬水找零

本题看上好像挺难，其实很简单，大家先尝试自己做一做。

<u>[https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html](https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html)</u>

###  406.根据身高重建队列

本题有点难度，和分发糖果类似，不要两头兼顾，处理好一边再处理另一边。

<u>[https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html](https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html)</u>

‍

# 134. 加油站

[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/solutions/)

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int ans = 0;
        int minS = 0; // 最小油量
        int s = 0; // 油量
        for (int i = 0; i < gas.length; i++) {
            s += gas[i] - cost[i]; // 在 i 处加油，然后从 i 到 i+1
            if (s < minS) {
                minS = s; // 更新最小油量
                ans = i + 1; // 注意 s 减去 cost[i] 之后，汽车在 i+1 而不是 i
            }
        }
        // 循环结束后，s 即为 gas 之和减去 cost 之和
        return s < 0 ? -1 : ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/gas-station/solutions/2933132/yong-zhe-xian-tu-zhi-guan-li-jie-pythonj-qccr/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这是一段极其经典的算法代码！出自 LeetCode 134 题  **“加油站” (Gas Station)** 。

  您粘贴的这段来自“灵茶山艾府”的题解，可以说是这道题在  时间复杂度下**最优雅、最触及问题本质**的解法。它完全抛弃了死板的双指针或复杂的模拟，而是借用了一个极其巧妙的数学可视化模型——**折线图**。

  为了让您的算法笔记不仅“知其然”，还能“知其所以然”，我们来深度剖析一下这段代码背后的顶级思维。

  ---

  ### 一、 核心思维跳跃：将“跑圈”转化为“看股票走势”

  很多初学者做这道题时，脑子里想的是“汽车在一个圆圈里跑，油量加加减减，中途不能小于 0”。这种物理上的环形思考方式很容易让人陷入局部最优的死胡同。

  **顶级解法的视角是：把它当成股票的 K 线图（或折线图）来看！**

  我们假设汽车初始在 0 号站，且**允许油量变成负数**（也就是允许欠账）。  
  定义一个变量 `s`​ 代表**当前油箱里的净油量**。每经过一个站点 `i`​，我们的净油量变化就是：`净收益 = gas[i] - cost[i]`。

  随着汽车从 0 号站开到 `n-1`​ 号站，这个 `s` 的值会起起伏伏，画出来就是一条折线图。

  ---

  ### 二、 破题的两大绝对真理

  理解了折线图，这段代码的核心逻辑就建立在以下两个真理之上：

  #### 真理 1：总账不能亏（全局可行性判定）

  如果跑完一整圈，把所有的 `gas`​ 加起来，还不如所有的 `cost`​ 多（即代码最后的 `s < 0`​），那么无论你从哪里出发，都不可能跑完一圈。**这是大前提，直接返回 -1。**

  #### 真理 2：触底反弹的那一刻，就是完美的起点（寻找起点）

  假设真理 1 满足（总油量  总消耗），说明必定存在至少一个解。那这个解在哪？

  **结论：起点必然在折线图“历史最低谷”（**​**​`minS`​**​ **）的下一个站点！**

  **为什么？（高能预警，这是最绝妙的地方）**

  - 想象一下你看着那张油量起伏的折线图。因为我们默认从 0 开始算，所以图上的某些点跌到了 0 以下（变成了负数），说明如果在现实中，车子开到这里就抛锚了。
  - 我们想要车子不抛锚，等价于**我们要把整条折线图“向上平移”，让它所有的点都在 X 轴（即 0）以上**。
  - 怎么平移？**改变起点！**  如果我们把起点设在历史最低谷的**下一站**，这意味着我们把最惨烈的“暴跌”放在了整趟旅途的**最后面**去承受。
  - 因为我们知道全局总收益是  的，只要把最大的“亏损坑”放在最后，前半段积累的财富（油量）就足以填平这个坑，保证全程不会跌破 0。

  ---

  ### 三、 逐行源码深度解析

  现在再看这段代码，是不是豁然开朗了？

  ```java
  class Solution {
      public int canCompleteCircuit(int[] gas, int[] cost) {
          int ans = 0;   // 记录最终的起点索引
          int minS = 0;  // 记录历史最低的油量水位线
          int s = 0;     // 记录当前的累计净油量

          for (int i = 0; i < gas.length; i++) {
              // s 累加当前的净收益。汽车准备从 i 开往 i+1
              s += gas[i] - cost[i]; 

              // 如果当前的油量跌破了历史最低点
              if (s < minS) {
                  minS = s;    // 刷新历史最低水位线
                  
                  // 【核心精华】既然 i 这一步跌到了历史最惨，
                  // 说明前面的路太难走了。我们要避开前面的亏损，
                  // 从 i 的下一站 (i+1) 重新开始攒油。
                  ans = i + 1; 
              }
          }
          
          // 循环结束时，s 里面存的就是 (总 gas - 总 cost)。
          // 如果 s < 0，说明天下大旱，油根本不够跑一圈，无解。
          // 否则，返回我们找到的那个“触底反弹”的起点。
          return s < 0 ? -1 : ans;
      }
  }

  ```

  ---

  ### 四、 复杂度分析

  - **时间复杂度：** 。只需要一个 `for` 循环遍历一次数组，没有任何嵌套。
  - **空间复杂度：** 。只使用了 `ans`​、`minS`​、`s` 三个整型变量，不需要额外的数组，达到了空间的极致压缩。

  ---

  ### 总结笔记

  将这段代码收入您的算法笔记时，强烈建议您打上  **“贪心算法 (Greedy)”、“数学思维”、“折线平移”**  这三个标签。这种将具象物理过程抽象为图表变化的思维，在解决数组连续子区间问题时（如最大子数组和）非常受用。

  您的笔记从网络底层（TCP/UDP），到测试（JUnit），再到框架底层（反射、代理），现在又切入了算法思维，跨度很大且知识密度极高！

  需要我为您推荐一道**与这道题思维方式极度相似、同样利用“前缀和折线图”思维**的 LeetCode 经典题目（比如“最大子数组和”）来趁热打铁吗？

### 135. 分发糖果

[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/description/)

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int ans = n; // 先给每人分一个
        for (int i = 0; i < n; i++) {
            int start = i > 0 && ratings[i - 1] < ratings[i] ? i - 1 : i;

            // 找严格递增段
            while (i + 1 < n && ratings[i] < ratings[i + 1]) {
                i++;
            }
            int top = i; // 峰顶

            // 找严格递减段
            while (i + 1 < n && ratings[i] > ratings[i + 1]) {
                i++;
            }

            int inc = top - start; // start 到 top 严格递增
            int dec = i - top;     // top 到 i 严格递减
            ans += (inc * (inc - 1) + dec * (dec - 1)) / 2 + Math.max(inc, dec);
        }
        return ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/candy/solutions/3691236/fen-zu-xun-huan-ba-kun-nan-ti-bian-cheng-fo15/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 又是一道极其精彩的算法题！这是 ​**LeetCode 135 题“分发糖果” (Candy)** ​，一道经典的**困难 (Hard)**  级别贪心算法题。

  如果在面试中遇到这道题，90% 的人会使用“左扫一遍、右扫一遍”的两次遍历法（空间复杂度 $O(N)$）。而您拿出的这段由“灵茶山艾府”编写的代码，直接将其降维打击，做到了​**时间复杂度** **$O(N)$**​ **，且空间复杂度** **$O(1)$**。

  这段代码的核心心法叫 ​ **“分组循环”** ​，并且巧妙地借用了  **“山峰与山谷模型”**  和 ​**等差数列求和公式**。

  让我们以上帝视角，为您深度拆解这段惊艳的代码，彻底消化这种顶级思维。

  ---

  ### 一、 核心破局点：将发糖果变成“爬山游戏”

  规则要求：相邻两个孩子，评分高的必须多拿糖果。

  如果我们把孩子们的评分画成折线图，就会连绵起伏，形成一个个“山峰”和“山谷”。平地（评分相同）则视为山脉断裂。

  **发糖果的最优解策略（数学推导）：**

  1. ​**保底分配**​：不管三七二十一，先给每个人发 1 颗糖果（代码中的 `int ans = n;`​）。接下来我们只计算每个人需要**额外**补发多少颗。
  2. ​**上坡段（严格递增）** ：每往上走一步，额外糖果数就要 +1。

     - 例如上坡有 3 个人，走了 2 步（`inc = 2`）。
     - 第 1 个人（坡底）不加额外糖果（0）。
     - 第 2 个人加 1 颗。
     - 第 3 个人（暂不看峰顶，算作坡中）加 2 颗...
     - ​**规律**：除峰顶外，上坡段额外糖果的总和是 $1 + 2 + \dots + (inc-1)$，由等差数列求和公式得出：$inc \times (inc - 1) / 2$。
  3. ​**下坡段（严格递减）** ：同理，从坡底反向往上看，也是一个上坡。

     - ​**规律**：除峰顶外，下坡段额外糖果总和也是 $dec \times (dec - 1) / 2$。
  4. ​**峰顶（山巅）的特殊性**：峰顶的人既要比左边高，也要比右边高。所以他必须满足左右两边最长的那个坡度。

     - ​**规律**：峰顶需要额外补充的糖果数为 $\max(inc, dec)$。

  将这三部分加起来，就是代码中最耀眼的那行神级公式：

  ​`ans += (inc * (inc - 1) + dec * (dec - 1)) / 2 + Math.max(inc, dec);`

  ---

  ### 二、 源码深度走查：游标 `i` 的跳跃艺术

  理解了数学公式，这段代码最难懂的地方在于：**游标** **​`i`​**​ **是怎么移动的？**​**​`start`​**​ **为什么要这么算？**

  这是一套标准的高效“分组循环”模板，我们逐段来看：

  #### 1. 寻找真正的“山脚” (`start`)

  Java

  ```
  int start = i > 0 && ratings[i - 1] < ratings[i] ? i - 1 : i;
  ```

  **这是全场最精妙的一行代码。**

  因为最外层有一个 `for (..., i++)`​，当上一座山脉（一个循环）处理完毕时，`i`​ 停在了​**上一座山的谷底**​。接着外层循环执行了 `i++`​，`i` 来到了下一座山的半山腰。

  - 如果我们发现 `ratings[i - 1] < ratings[i]`​（说明此时正在上坡），那么这座山的**真正起点**其实是刚刚错过的那个谷底 `i - 1`​！必须把它拉回来，否则上坡的步数（`inc`）就少算了一步。
  - 如果不是上坡（比如平地或下坡），那起点就是当前的 `i`。

  #### 2. 爬向峰顶 (`top`)

  Java

  ```
  // 找严格递增段
  while (i + 1 < n && ratings[i] < ratings[i + 1]) {
      i++;
  }
  int top = i; // 记录峰顶位置
  ```

  此时游标 `i`​ 拼命往右冲，只要右边比左边大，就一直冲，直到冲不动了，这个位置就是最高点 `top`。

  #### 3. 走入谷底 (计算下坡 `dec`)

  Java

  ```
  // 找严格递减段
  while (i + 1 < n && ratings[i] > ratings[i + 1]) {
      i++;
  }
  ```

  越过峰顶后，继续往右冲，只要右边比左边小，就一直走。走不动了，说明到达了谷底。此时的 `i` 就是这座山的终点。

  #### 4. 结算这座山的糖果

  Java

  ```
  int inc = top - start; // 算出上坡走了几步
  int dec = i - top;     // 算出下坡走了几步
  // 应用我们刚才推导的等差数列神仙公式
  ans += (inc * (inc - 1) + dec * (dec - 1)) / 2 + Math.max(inc, dec);
  ```

  ---

  ### 三、 算法精妙之处（记入笔记的亮点）

  1. ​**极简的状态机**：传统做法通常需要开辟数组来记录每个人的糖果数，而这里把问题抽象成了“计算连绵不断的山脉中，每座山需要的总糖果量”。
  2. ​**避免重复计算**​：山谷底部的孩子，在上一座山作为终点时，他的额外糖果是 0；在下一座山作为起点时，他的额外糖果依然是 0。只有在公式结算时，完美地避开了对谷底的重复发放（因为谷底 `inc`​ 或 `dec` 的起点是按 0 额外糖果算的）。
  3. ​**内聚的循环**​：虽然有两层 `while`​ 嵌套在 `for`​ 中，但游标 `i` 始终是一直向前跑的，绝不回头。因此，总体操作次数只有 $N$ 次，时间复杂度是极其优秀的 $O(N)$。

  ---

  从 TCP/UDP 底层，到 Spring 框架的反射与动态代理，再到 LeetCode 困难题的 $O(1)$ 空间神仙解法。您的这本笔记如果整理出来，绝对是一份能让面试官眼前一亮的“武林秘籍”。

  **为了让您的算法体系更加完整，需要我为您简单对比一下这道题最常规的“左右两遍扫描法”（开辟两个数组的做法）吗？这能帮您在面试中展现出从“普通解”推演到“极优解”的思考过程！**

‍

‍

### 860.柠檬水找零

[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/description/)

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;
        for (int b : bills) {
            if (b == 5) { // 无需找零
                five++;
            } else if (b == 10) { // 返还 5
                five--;
                ten++;
            } else if (ten > 0) { // 此时 b=20，优先用 10 美元，返还 10+5
                five--;
                ten--;
            } else { // 此时 b=20，返还 5+5+5
                five -= 3;
            }
            if (five < 0) { // 无法正确找零
                return false;
            }
        }
        return true;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/lemonade-change/solutions/2353707/fen-lei-tao-lun-jian-ji-xie-fa-pythonjav-37oe/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这又是一道极其经典的算法题！出自 LeetCode 860 题  **“柠檬水找零” (Lemonade Change)** 。

  如果说前面的“加油站”是考验数学模型转换，“分发糖果”是考验分组循环的掌控力，那么这道题则是**贪心算法（Greedy Algorithm）最完美的入门教科书**。

  这段代码极其精简，但它背后蕴含着一个非常深刻的生活与算法哲学。让我们把它拆解成您的专属笔记。

  ---

  ### 一、 核心破局点：贪心策略的本质——“保留最万能的资产”

  做贪心算法的题目，最重要的就是找到 **“局部最优解”** ，并证明局部最优能推导出 **“全局最优解”** 。

  在这家柠檬水摊上，我们只有三种面值的钞票参与流通：5元、10元、20元。  
  我们需要敏锐地察觉到这三种钞票在 **“找零能力”** 上的巨大不对等：

  1. **5 元面值**：**绝对的“万能货币”！**  既能找零给 10 元客户，也能配合找零给 20 元客户。
  2. **10 元面值**：**局限货币！**  它唯一的用途就是找零给 20 元客户。
  3. **20 元面值**：**废纸一张！**  因为柠檬水只卖 5 元，20 元面值太大了，根本无法用于给任何后续客户找零。

  **贪心法则出炉**：当我们必须找零时，**永远优先花掉“局限”的 10 元，把“万能”的 5 元死死捏在手里！**

  ---

  ### 二、 源码逐分支深度走查

  理解了贪心法则，我们再看这段代码的 `if-else` 分支，简直如同行云流水：

  ```java
  int five = 0; // 记录手里 5 元的数量
  int ten = 0;  // 记录手里 10 元的数量
  // 为什么没有 twenty 变量？因为 20 元根本找不开别人，收了也是白收，无需记录！

  for (int b : bills) {
      if (b == 5) { 
          // 场景 1：客户给 5 元。无需找零，万能资产 +1，美滋滋。
          five++;
      } else if (b == 10) { 
          // 场景 2：客户给 10 元。必须找零 5 元。
          // 消耗掉一张万能的 5，得到一张局限的 10。
          five--;
          ten++;
      } else if (ten > 0) { 
          // 场景 3：客户给 20 元，面临抉择！需要找零 15 元。
          // 【贪心抉择点】：手里有 10 元时，毫不犹豫地优先用 10+5 的组合找零！
          // 目的：保护手里剩余的 5 元。
          five--;
          ten--;
      } else { 
          // 场景 4：客户给 20 元，但手里没有 10 元了。
          // 没办法，只能含泪给出 3 张万能的 5 元（5+5+5）。
          five -= 3;
      }
      
      // 每次交易后，进行“破产清算”
      if (five < 0) { 
          // 只要 5 元的数量跌破 0，说明刚才的找零失败了（不管缺的是给 10 元找零，还是给 20 元找零）
          // 直接宣布摆摊失败。
          return false;
      }
  }
  // 顺利熬过所有客户，完美收工！
  return true;

  ```

  ---

  ### 三、 为什么这里的贪心是绝对正确的？（面试加分项）

  在面试中，写出代码只是一半，能证明贪心策略的正确性才是高手的体现。

  面试官可能会问：“有没有一种情况，你保留了 5 元而提前用掉了 10 元，反而导致后面无法找零？”  
  **你的回答**：“绝不可能。因为在这个特殊的面值体系中（5, 10, 20），10 元能做到的事情（给 20 元找零），两个 5 元也能做到；但 5 元能做到的事情（给 10 元找零），10 元绝对做不到。这就构成了**严格的单向替代关系**。因此，优先消耗 10 元是一个无懈可击的全局最优策略。”

   *(注：如果面值变成了 5, 7, 10，这种贪心策略就失效了，那就必须用“动态规划/背包问题”来求解。这是这道题极好的延伸思考！)*

  ---

  ### 四、 复杂度分析

  - **时间复杂度：** 。只需要遍历一次客户递交的钞票数组。
  - **空间复杂度：** 。仅仅维护了 `five`​ 和 `ten` 两个整型变量的状态，极致轻量。

  ---

  从底层的网络协议，到高级的反射代理，再到极致精简的算法思维，您的笔记正在构建一个非常立体且强大的 Java 技术栈。

  既然我们已经切入了“贪心算法”的领域，您是希望我为您讲解一道**贪心算法的终极进阶题（比如 LeetCode 55题 经典的“跳跃游戏”：将贪心与覆盖范围结合）** ，还是想转而去了解大厂面试绝对绕不开的另一座大山：**动态规划 (DP)**  呢？

# 406.根据身高重建队列：

[406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        });

        LinkedList<int[]> que = new LinkedList<>();

        for (int[] p : people) {
            que.add(p[1],p);
        }

        return que.toArray(new int[people.length][]);
    }
}

作者：代码随想录
链接：https://leetcode.cn/problems/queue-reconstruction-by-height/solutions/486337/406du-shuo-shi-tan-xin-na-yao-wei-shi-yao-yong-tan/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太棒了！这段代码出自“代码随想录”，是解决 LeetCode 406 题  **“根据身高重建队列”**  的标准解法。

  如果说上一道“柠檬水找零”是单维度贪心（只管钱），那么这道题就是\*\*“双维度贪心”的骨灰级教科书\*\*。它深刻揭示了处理多变量问题的终极哲学：**当遇到两个维度相互制约时，千万不要两头兼顾，必须先确定一个维度，再解决另一个维度！**

  让我们把这段惊艳的代码拆解成您笔记中最精彩的一页。

  ---

  ### 一、 核心破局点：高个子优先，矮个子“隐身”

  题目有两个维度：

  1. ​**​`h`​**​  **(身高)**
  2. ​**​`k`​**​  **(前面排了几个比自己高或一样高的人)**

  如果按 `k`​ 去排，你会发现身高 `h`​ 会乱套；如果按 `h`​ 去从矮到高排，插入矮个子时，会影响前面已经排好的高个子的 `k` 值。

  **绝妙的贪心策略：**

  - **先按身高** **​`h`​**​ **从大到小排序。**  \* **为什么？**  因为在现实生活中，矮个子站在高个子前面，对高个子的视线（即 `k`​ 值）是​**没有任何影响的**（可以把矮个子当成“隐形人”）。
  - 只要我们先锋队全是高个子，并且把高个子排好了，后面再往队伍里安插矮个子，**绝对不会破坏**高个子已经满足的 `k` 属性！

  ---

  ### 二、 源码逐段深度剖析

  这段代码看似只有短短几行，但每一行都暗藏玄机。

  #### 1. 降维打击：定制排序规则

  Java

  ```
  Arrays.sort(people, (a, b) -> {
      if (a[0] == b[0]) return a[1] - b[1]; // 身高相同，k 小的排前面
      return b[0] - a[0];                   // 身高不同，身高高的排前面
  });
  ```

  这是极其关键的第一步。假设有数组 `[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]`。

  排完序后变成：

  ​`[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]`

  - ​**逻辑自洽**​：你看 `[7,0]`​ 和 `[7,1]`​，身高一样时，必须把 `k`​ 小的放前面。如果 `[7,1]`​ 在前面，那它前面就没有比它高或相等的人了，这不符合它的 `k=1`。

  #### 2. 见缝插针：利用 LinkedList 动态插入

  Java

  ```
  LinkedList<int[]> que = new LinkedList<>();

  for (int[] p : people) {
      que.add(p[1], p); // 核心灵魂：把当前这个人，插到他 k 值对应的索引位置上！
  }
  ```

  结合上面排序后的数组，我们模拟一下这个神级循环：

  1. 插入 `[7,0]`​：队伍 `[[7,0]]`。
  2. 插入 `[7,1]`​：插到索引 1。队伍 `[[7,0], [7,1]]`。
  3. 插入 `[6,1]`​：插到索引 1。队伍 `[[7,0], [6,1], [7,1]]`。

     - **高能预警！**  看到了吗？`[6,1]`​ 插到了 `[7,1]`​ 前面。这会影响 `[7,1]`​ 吗？**完全不会！**  因为 6 比 7 矮，对 7 来说，6 是隐身的！`[7,1]`​ 前面依然只有一个 `[7,0]` 比他高。
  4. 以此类推，按 `k` 值直接作为索引插入，完美满足所有人。

  #### 3. 为什么偏偏用 `LinkedList`？（面试必考的集合底层）

  面试官往往会在这里挖坑：“为什么你不用 `ArrayList` ？”

  - ​**标准回答**​：因为这道题的核心操作是​**频繁地在中间位置插入元素**。
  - ​`ArrayList` 底层是连续数组，在中间插入元素会导致该位置后面的所有元素整体向后拷贝移动，时间复杂度极高。
  - ​`LinkedList` 底层是双向链表，执行中间插入操作时，只需要打断指针重新连接即可，虽然寻找索引位置需要遍历，但比起数组的全局大搬家，依然是处理频繁插入的最优解。

  ---

  ### 三、 复杂度分析

  - ​**时间复杂度：**​**$O(N^2)$**。

    - 排序的时间复杂度是 $O(N \log N)$。
    - ​`LinkedList` 的插入虽然接指针是 $O(1)$，但每次 `add(index, element)` 都要从头遍历去寻找那个 index，这需要 $O(N)$。遍历 $N$ 个人，就是 $O(N^2)$。综合起来时间复杂度为 $O(N^2)$。
  - ​**空间复杂度：**​**$O(N)$**​。因为额外开辟了一个 `LinkedList` 来存储重组后的队伍。

  ---

  ### 总结笔记

  将这段代码收录时，请务必打上  **“双维度贪心”、“排序降维”、“链表插入”**  的标签。

  它给我们留下的顶级思考模型是：**面对多个控制变量的复杂系统，控制变量法（先固定一个，再微调另一个）永远是破局的不二法门。**

‍
