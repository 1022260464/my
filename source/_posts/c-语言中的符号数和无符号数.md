---
title: c语言中的符号数和无符号数
date: '2025-03-29 21:44:19'
updated: '2025-12-31 14:38:04'
permalink: /post/signed-and-unsigned-numbers-in-c-language-xa0i2.html
comments: true
toc: true
---



# c语言中的符号数和无符号数

在C语言中，**有符号数（Signed）** 和**无符号数（Unsigned）** 是两种基本的整数表示方式，它们的核心区别在于**是否用最高位表示符号**，这直接影响数值范围、运算行为和编译器优化。以下是详细解析：

---

### **1. 存储方式与范围**

####  **(1) 无符号数（Unsigned）**

- **最高位是数据位**，不表示符号，所有位均用于表示数值。
- **范围**：\(0 \sim 2^n-1\)（`n`为位数）。

  ```c
  uint8_t a = 255;  // 8位无符号：0~255
  ```

####  **(2) 有符号数（Signed）**

- **最高位是符号位**（0正，1负），剩余位表示数值（通常用**补码**存储）。
- **范围**：\(-2<sup>{n-1} \sim 2</sup>{n-1}-1\)。

  ```c
  int8_t b = -128;  // 8位有符号：-128~127
  ```

#### **补码表示负数的原理**

- 正数：与原码相同（如 `+5` = `00000101`）。
- 负数：符号位为 `1`，数值部分按位取反后加 `1`（如 `-5` = `11111011`）。

---

### **2. 关键区别与行为对比**

|**行为**|无符号数（Unsigned）|有符号数（Signed）|
| --| ------------------------------| ----------------------------------|
|**溢出**|明确回绕（模 \(2^n\)）|未定义行为（UB），可能崩溃或回绕|
|**右移操作**|逻辑右移（高位补 `0`）|算术右移（高位补符号位）|
|**比较运算**|直接按二进制比较|符号位影响结果|
|**与负数比较**|负数被隐式转换为大正数|正常比较|

---

### **3. 常见陷阱与示例**

####  **(1) 隐式类型转换**

C语言中，**混合运算时，有符号数会隐式转换为无符号数**，可能导致逻辑错误：

```c
int a = -1;
unsigned int b = 100;
if (a < b) { 
    // 实际为 false！因为 -1 被转为 0xFFFFFFFF（远大于 100）
}
```

####  **(2) 循环计数器**

无符号数递减到 `0` 后再减 `1` 会变为最大值，导致死循环：

```c
for (unsigned int i = 10; i >= 0; i--) {
    // 当 i=0 时，i-- 变为 0xFFFFFFFF，循环永不终止！
}
```

####  **(3) 数据截断**

将有符号数赋值给更小的无符号类型时，符号位被当作数据位：

```c
int32_t x = -1;
uint8_t y = x; // y = 255（0xFF）
```

---

### **4. 如何安全使用？**

####  **(1) 明确类型声明**

- 需要负数时用 `int`、`int32_t` 等有符号类型。
- 仅非负值时用 `unsigned int`、`uint32_t`。

####  **(2) 避免隐式转换**

- 显式强制类型转换：

  ```c
  int a = -1;
  unsigned int b = 100;
  if ((int)a < (int)b) { ... } // 强制转为有符号比较
  ```

####  **(3) 检查溢出**

- 无符号数加法检查：

  ```c
  unsigned int a = UINT_MAX - 10;
  if (a + 20 < a) { /* 溢出发生 */ }
  ```
- 有符号数溢出是UB，需手动判断：

  ```c
  int a = INT_MAX - 10;
  if (a > INT_MAX - 20) { /* 可能溢出 */ }
  ```

---

### **5. 代码示例**

####  **(1) 补码验证**

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    int8_t x = -5;
    // 输出二进制表示（补码）
    for (int i = 7; i >= 0; i--) {
        printf("%d", (x >> i) & 1);
    }
    // 输出：11111011
    return 0;
}
```

####  **(2) 无符号数回绕**

```c
#include <stdio.h>
#include <limits.h>

int main() {
    unsigned int a = UINT_MAX;
    printf("%u\n", a + 1); // 输出 0（回绕）
    return 0;
}
```

####  **(3) 有符号数右移**

```c
#include <stdio.h>

int main() {
    int8_t x = -8;      // 二进制：11111000
    int8_t y = x >> 1;  // 算术右移：11111100 (-4)
    printf("%d\n", y);  // 输出 -4
    return 0;
}
```

---

### **6. 总结**

- **无符号数**：适合位操作、非负值场景，溢出行为明确。
- **有符号数**：需表示负数时使用，但需警惕UB和隐式转换。
- **关键规则**：

  - 混合运算时，有符号数隐式转为无符号数。
  - 右移时，无符号数补 `0`，有符号数补符号位。
  - 有符号数溢出是未定义行为，需主动避免。

![微信截图_20250329213428](/source/images/微信截图_20250329213428-20250329215056-2t0gkqw.png)

![微信截图_20250329213448](/source/images/微信截图_20250329213448-20250329215056-kpk14eo.png)
