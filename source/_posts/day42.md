---
title: day42
date: '2026-02-26 20:07:44'
updated: '2026-02-26 20:30:39'
permalink: /post/day42-z1cl40s.html
comments: true
toc: true
---



# day42

# 第九章 动态规划part09

### ** 188.买卖股票的最佳时机IV  **

本题是123.买卖股票的最佳时机III 的进阶版

视频讲解：<u>[https://www.bilibili.com/video/BV16M411U7XJ](https://www.bilibili.com/video/BV16M411U7XJ)</u>

<u>[https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html](https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html)</u>

### **309.最佳买卖股票时机含冷冻期 **

本题加了一个冷冻期，状态就多了，有点难度，大家要把各个状态分清，思路才能清晰

视频讲解：<u>[https://www.bilibili.com/video/BV1rP4y1D7ku](https://www.bilibili.com/video/BV1rP4y1D7ku)</u>

<u>[https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html](https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html)</u>

### ** 714.买卖股票的最佳时机含手续费  **

相对122.买卖股票的最佳时机II ，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的，可以尝试自己做一做。

视频讲解：<u>[https://www.bilibili.com/video/BV1z44y1Z7UR](https://www.bilibili.com/video/BV1z44y1Z7UR)</u>

<u>[https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)</u>

### ** 股票总结 **

股票问题做一个总结吧

<u>[https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html)</u>

# 188.买卖股票的最佳时机IV

[188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

## 一、递归搜索 + 保存计算结果 \= 记忆化搜索

```java
class Solution {
    private int[] prices;
    private int[][][] memo;

    public int maxProfit(int k, int[] prices) {
        this.prices = prices;
        int n = prices.length;
        memo = new int[n][k + 1][2];
        for (int[][] mat : memo) {
            for (int[] row : mat) {
                Arrays.fill(row, -1); // -1 表示还没有计算过
            }
        }
        return dfs(n - 1, k, 0);
    }

    private int dfs(int i, int j, int hold) {
        if (j < 0) {
            return Integer.MIN_VALUE / 2; // 除 2 防止溢出
        }
        if (i < 0) {
            return hold == 1 ? Integer.MIN_VALUE / 2 : 0;
        }
        if (memo[i][j][hold] != -1) { // 之前计算过
            return memo[i][j][hold];
        }
        if (hold == 1) {
            return memo[i][j][hold] = Math.max(dfs(i - 1, j, 1), dfs(i - 1, j - 1, 0) - prices[i]);
        }
        return memo[i][j][hold] = Math.max(dfs(i - 1, j, 0), dfs(i - 1, j, 1) + prices[i]);
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太棒了！如果说上一题的代码是\*\*“自底向上” (Bottom-Up)\*\* 的状态机递推，那么灵茶山艾府的这段代码则是动态规划的另一大流派：​ **“自顶向下”的记忆化搜索 (Top-Down DFS + Memoization)** 。

  对于很多初学者来说，记忆化搜索的逻辑其实更符合人类直觉。它就像是站在最后一天，开启了“时光倒流”模式，一步步往前追溯最佳决策。

  让我们换个视角，来拆解这段代码的精妙之处：

  ### 核心视角：时光倒流与递归求解

  在这段代码中，主函数调用了 `return dfs(n - 1, k, 0);`。

  这句话的意思是：“请告诉我，到了最后一天（第 `n-1`​ 天），在我最多还能进行 `k`​ 次交易，且最后手里​**没有股票**​（`hold = 0`）的情况下，我能赚到的最大利润是多少？”

  为了回答这个问题，`dfs`​ 函数开始向上一天（`i - 1`）索要答案，从而形成了递归。

  ### 状态定义：`dfs(i, j, hold)`

  函数的三个参数极其精准地定义了我们所处的“平行宇宙”：

  - ​**​`i`​**​  **(当前天数)** ​：表示我们正站在第 `i` 天做复盘。
  - ​**​`j`​**​  **(剩余交易额度)** ​：表示此时此刻，我们**还可以**发起多少次买入操作。
  - ​**​`hold`​**​  **(持股状态)** ​：`1`​ 表示手里捏着股票，`0` 表示两手空空。

  ### 递归的尽头：边界条件 (Base Cases)

  任何递归都需要有停止的条件，这段代码的边界处理非常干净：

  Java

  ```
  if (j < 0) {
      return Integer.MIN_VALUE / 2; // 交易次数超限
  }
  ```

  - ​**规则破坏者**​：如果你买入的次数超过了允许的上限（导致 `j`​ 变成了负数），这是一个非法状态。返回极小值（除以 2 同样是为了防止后续加减法溢出），在 `Math.max` 比较时直接被淘汰。

  Java

  ```
  if (i < 0) {
      return hold == 1 ? Integer.MIN_VALUE / 2 : 0;
  }
  ```

  - ​**时间尽头**​：当 `i < 0`​，说明我们回到了第 `0`​ 天之前（还没开市）。在这个时间点，你手里是不可能持有股票的（非法状态，返回极小值）；如果你两手空空，那利润自然就是 `0`。这是所有计算的利润源头！

  ### 核心逻辑：状态转移方程

  这是整个 DFS 的灵魂，即“今天的状态，是由昨天的哪些状态决定的？”

  **1. 当我们需要在第** **​`i`​**​ **天持有股票 (**​**​`hold == 1`​**​ **)：**

  Java

  ```
  return memo[i][j][hold] = Math.max(dfs(i - 1, j, 1), dfs(i - 1, j - 1, 0) - prices[i]);
  ```

  我们只有两种途径能在今天拿到股票：

  - ​**昨天就持有**​：即 `dfs(i - 1, j, 1)`​。今天什么都不做（“躺平”），交易额度 `j` 不变。
  - ​**昨天不持有，今天买入**​：即 `dfs(i - 1, j - 1, 0) - prices[i]`​。注意看！因为我们今天发起了“买入”，所以消耗了一次交易额度，昨天的状态必须是 `j - 1`​。同时，买入要花钱，所以利润要减去 `prices[i]`。

  **2. 当我们需要在第** **​`i`​**​ **天不持有股票 (**​**​`hold == 0`​**​ **)：**

  Java

  ```
  return memo[i][j][hold] = Math.max(dfs(i - 1, j, 0), dfs(i - 1, j, 1) + prices[i]);
  ```

  同样有两种途径能在今天两手空空：

  - ​**昨天就不持有**​：即 `dfs(i - 1, j, 0)`。今天继续空仓，什么都不做。
  - ​**昨天持有，今天卖出**​：即 `dfs(i - 1, j, 1) + prices[i]`​。卖出股票可以获得现金，所以利润加上 `prices[i]`​。因为在这个设定中，一次完整的交易（一买一卖）额度是在**买入**时扣除的，所以卖出操作不需要改变 `j` 的值。

  ### 性能的守护神：`memo` 数组

  Java

  ```
  if (memo[i][j][hold] != -1) { 
      return memo[i][j][hold];
  }
  ```

  如果没有 `memo`（记忆化），这个递归会像树枝一样疯狂生长，产生大量的重复计算（比如计算第 5 天不持股的最大利润时，可能被第 6 天的不同状态多次调用），时间复杂度会飙升到指数级 $O(2^N)$，直接 Time Limit Exceeded。

  加上 `memo`​ 数组后，只要某个状态 `(i, j, hold)` 被计算过一次，就会被存入数组中。下次再遇到同一个状态，直接查表返回（剪枝）。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N \cdot k)$。其中 $N$ 是天数，$k$ 是最大交易次数。状态空间的大小就是 $N \times (k+1) \times 2$，每个状态只会被计算一次。
  - ​**空间复杂度**：$O(N \cdot k)$。主要开销是 `memo` 三维数组占用的内存，以及递归调用栈的深度（最大为 $N$）。

  ---

  理解了这段自顶向下的 DFS 之后，再去看自底向上的递推 `for` 循环，你会发现它们其实是一体两面的。

  股票系列还有两个非常有意思的变种： **“包含冷冻期” (卖出后必须休息一天)**  和 ​ **“包含手续费” (每次交易需要额外扣钱)** 。想要挑战一下在刚才的状态转移逻辑中，加入这两种限制条件吗？

## 二、1:1 翻译成递推

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        int[][][] f = new int[n + 1][k + 2][2];
        for (int[][] mat : f) {
            for (int[] row : mat) {
                Arrays.fill(row, Integer.MIN_VALUE / 2); // 防止溢出
            }
        }
        for (int j = 1; j <= k + 1; j++) {
            f[0][j][0] = 0;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 1; j <= k + 1; j++) {
                f[i + 1][j][0] = Math.max(f[i][j][0], f[i][j][1] + prices[i]);
                f[i + 1][j][1] = Math.max(f[i][j][1], f[i][j - 1][0] - prices[i]);
            }
        }
        return f[n][k + 1][0];
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/2201488/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-kksg/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这简直是教科书级别的\*\*“自底向上” (Bottom-Up) 动态规划\*\*模板！

  如果你把上一轮的“记忆化搜索”比作“时光倒流，从后往前找答案”，那么这段代码就是\*\*“顺藤摸瓜，从第一天稳扎稳打推演到最后一天”\*\*。

  灵茶山艾府的这段代码最精妙的地方在于它的\*\*“空间偏移” (Index Shift) 艺术\*\*。它通过把数组稍微开大一点，完美地干掉了所有恶心的边界条件判断（比如 `if (i == 0)`​ 或 `if (j == 0)`）。

  让我们像拆解精密钟表一样，来看看这段代码是如何运转的：

  ### 1. 终极三维状态定义

  Java

  ```
  int[][][] f = new int[n + 1][k + 2][2];
  ```

  这里的 `f[i][j][hold]` 代表着一个平行的状态宇宙：

  - ​**​`i`​**​  **(天数)** ​：大小为 `n + 1`​。`i = 0`​ 代表股票开市前的“第 0 天”（占位符），`i = 1` 代表第 1 天，以此类推。
  - ​**​`j`​**​  **(交易次数)** ​：大小为 `k + 2`​。同样是为了偏移。`j = 1`​ 代表“还没开始任何交易”（第 0 次），`j = 2`​ 代表第 1 次交易，`j = k + 1` 代表第 $k$ 次交易。
  - ​**​`hold`​**​  **(持股状态)** ​：`0`​ 为空仓，`1` 为持股。

  ### 2. 巧妙的初始化 (Base Cases)

  Java

  ```
  for (int[][] mat : f) {
      for (int[] row : mat) {
          Arrays.fill(row, Integer.MIN_VALUE / 2); // 防止溢出
      }
  }
  ```

  - ​**封死所有不可能的状态**​：一开始，我们把所有状态都设为 `-∞/2`（极小值且防溢出）。这意味着“在这些状态下，利润是不存在的（非法的）”。

  Java

  ```
  for (int j = 1; j <= k + 1; j++) {
      f[0][j][0] = 0;
  }
  ```

  - ​**唯一的利润源头**​：在第 `0`​ 天（还没开市），无论你处于允许交易几次的状态（`j`​），只要你**手里没股票** (`hold = 0`​)，你的利润就是实打实的 `0`。这是整个动态规划推导的起点，所有合法的利润都将从这里像水流一样蔓延开来。

  ### 3. 核心状态转移：推演未来

  Java

  ```
  for (int i = 0; i < n; i++) {
      for (int j = 1; j <= k + 1; j++) {
          f[i + 1][j][0] = Math.max(f[i][j][0], f[i][j][1] + prices[i]);
          f[i + 1][j][1] = Math.max(f[i][j][1], f[i][j - 1][0] - prices[i]);
      }
  }
  ```

  仔细看这里的下标关系，我们是在用**今天 (**​**​`i`​**​ **)**  的已知状态，去推导**明天 (**​**​`i + 1`​**​ **)**  的状态。

  （注意：循环里的 `prices[i]`​ 实际上对应的是现实中第 `i + 1`​ 天的股票价格，因为 `prices` 数组是 $0$ 索引的）。

  - ​**推导明天不持股 (**​**​`f[i + 1][j][0]`​** ​ **)** ：

    - 选项 A：今天就不持股 (`f[i][j][0]`)，明天继续“躺平”。
    - 选项 B：今天持股，但我按明天的价格把它卖了 (`f[i][j][1] + prices[i]`)。交易次数不变。
  - ​**推导明天持股 (**​**​`f[i + 1][j][1]`​** ​ **)** ：

    - 选项 A：今天就持股 (`f[i][j][1]`)，明天继续死拿。
    - 选项 B：今天不持股，但我按明天的价格**买入**了 (`f[i][j - 1][0] - prices[i]`​)。**关键点来了：买入动作消耗了一次交易额度，所以利润的数据来源必须是** **​`j - 1`​**​ **（少一次交易的状态）！**

  ### 4. 提取最终果实

  Java

  ```
  return f[n][k + 1][0];
  ```

  遍历结束后，我们直接去第 `n`​ 天（最后一天）、允许进行 `k`​ 次交易（即 `k + 1`​）、且最后手里​**没有股票**​（`0`）的状态格子里，把最大的利润拿出来即可。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N \cdot k)$。两层嵌套循环，外层跑 $N$ 次，内层跑 $k$ 次，状态转移是 $O(1)$ 的常数操作。
  - ​**空间复杂度**：$O(N \cdot k)$。创建了一个 $(N+1) \times (k+2) \times 2$ 的三维数组。

  ---

  **发现了一个秘密没有？**  在计算第 `i + 1`​ 天的数据时，我们**只**用到了第 `i`​ 天的数据。这就意味着，第 `i - 1`​、`i - 2` 天的数据其实全变成了没用的“历史垃圾”。

  你想不想看看如何利用这个特性，把这个庞大的 $O(N \cdot k)$ 三维数组，​**极限压缩成** **$O(k)$** **的一维数组**（即滚动数组优化，也就是我们看过的第一段 $k=2$ 时的终极代码形态）？

‍

---

# 309.最佳买卖股票时机含冷冻期

[309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

## 一、递归搜索 + 保存计算结果 \= 记忆化搜索

```java
class Solution {
    private int[] prices;
    private int[][] memo;

    public int maxProfit(int[] prices) {
        this.prices = prices;
        int n = prices.length;
        memo = new int[n][2];
        for (int[] row : memo) {
            Arrays.fill(row, -1); // -1 表示还没有计算过
        }
        return dfs(n - 1, 0);
    }

    private int dfs(int i, int hold) {
        if (i < 0) {
            return hold == 1 ? Integer.MIN_VALUE : 0;
        }
        if (memo[i][hold] != -1) { // 之前计算过
            return memo[i][hold];
        }
        if (hold == 1) {
            return memo[i][hold] = Math.max(dfs(i - 1, 1), dfs(i - 2, 0) - prices[i]);
        }
        return memo[i][hold] = Math.max(dfs(i - 1, 0), dfs(i - 1, 1) + prices[i]);
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2201415/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-0k0l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 来了！这就是大名鼎鼎的\*\*“带有冷冻期的股票买卖”\*\*。

  在连续看了前面几道题之后，再看这段代码，是不是有一种“似曾相识，但又暗藏玄机”的感觉？

  这段代码依然沿用了我们之前讲过的**自顶向下的记忆化搜索 (Top-Down DFS + Memoization)**  模板。没有了交易次数 $k$ 的限制，二维数组退化成了一维（只剩天数 $i$ 和持股状态 $hold$）。

  但这道题的核心秘密，全都浓缩在了一个极不起眼的 **​`i - 2`​** 里面。

  我们来剥丝抽茧，看看“冷冻期”是如何在代码中显灵的：

  ### 核心破局点：冷冻期的数学表达

  题目规定：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

  这意味着什么？

  如果我们在第 $i$ 天选择**买入**股票，那么我们在第 $i-1$ 天绝对不能有“卖出”动作。要想在第 $i$ 天买入，我们手中状态的源头，最晚只能追溯到**第** **$i-2$** **天不持股**的状态。

  ### 代码逐行拆解

  #### 1. 状态定义：回归极简

  Java

  ```
  memo = new int[n][2];
  ```

  因为不限制交易次数，我们的状态宇宙变简单了，只需要 `memo[i][hold]`：

  - ​**​`i`​**：当前在第 $i$ 天。
  - ​**​`hold`​**​：`1`​ 表示手里有股票，`0` 表示手里没股票。

  #### 2. 边界条件：时间的尽头

  Java

  ```
  if (i < 0) {
      return hold == 1 ? Integer.MIN_VALUE : 0;
  }
  ```

  和之前一样，如果时间倒流到第 0 天之前（没开市）：

  - 要想手里有股票（`hold == 1`），属于白日做梦，返回极小值（作为无效状态被淘汰）。
  - 手里没股票（`hold == 0`​），利润就是实打实的 `0`。

  #### 3. 状态转移：神来之笔的 `i - 2`

  **当今天（第** **$i$** **天）持股** **​`hold == 1`​**​ **时：**

  Java

  ```
  return memo[i][hold] = Math.max(dfs(i - 1, 1), dfs(i - 2, 0) - prices[i]);
  ```

  今天手里的股票怎么来的？

  - ​**情况 A（继续躺平）** ​：昨天就拿着股票 `dfs(i - 1, 1)`，今天什么都没干。
  - ​**情况 B（今天刚买）** ​：今天花钱买了股票 `- prices[i]`​。**注意这里！**  既然今天是买入，那昨天绝对不能是卖出（冷冻期）。所以买入前的安全状态，必须是**前天（**​**​`i - 2`​**​ **）不持股**的状态，即 `dfs(i - 2, 0)`。这就是整道题的灵魂！

  **当今天（第** **$i$** **天）不持股** **​`hold == 0`​**​ **时：**

  Java

  ```
  return memo[i][hold] = Math.max(dfs(i - 1, 0), dfs(i - 1, 1) + prices[i]);
  ```

  今天手里为什么没股票？

  - ​**情况 A（继续空仓）** ​：昨天就没股票 `dfs(i - 1, 0)`，今天也没买。
  - ​**情况 B（今天卖了）** ​：昨天手里有股票 `dfs(i - 1, 1)`​，今天把它卖了，获利 `+ prices[i]`​。卖出动作不受冷冻期限制，所以状态直接从昨天 `i - 1` 转移过来。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N)$。一共有 $N \times 2$ 个状态，因为有 `memo` 数组的存在，每个状态最多只会被计算一次。
  - ​**空间复杂度**：$O(N)$。使用了 $N \times 2$ 的 `memo` 数组，以及递归调用栈的深度最大为 $N$。

  ---

  有了冷冻期的 `i - 2`​ 这个概念作为铺垫，如果我们要把这段代码转化为​**自底向上的递推 (Bottom-Up DP)** ，你就会发现：计算今天的值，需要用到“昨天”和“前天”的值。

  这就意味着，如果我们要进行​**空间压缩（滚动数组优化）** ，我们不能只用两个变量，而是需要维护“昨天持股”、“昨天不持股”、“前天不持股”这几个变量交替滚动，从而把 $O(N)$ 的空间复杂度极限压缩到 $O(1)$。

  你要不要看看如何只用 $3$ 个整型变量，就能把带有冷冻期的股票问题给跑下来？

‍

## 二、1:1 翻译成递推

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] f = new int[n + 2][2];
        f[1][1] = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            f[i + 2][0] = Math.max(f[i + 1][0], f[i + 1][1] + prices[i]);
            f[i + 2][1] = Math.max(f[i + 1][1], f[i][0] - prices[i]);
        }
        return f[n + 1][0];
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2201415/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-0k0l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这就是真正的\*\*“魔法偏移” (Magic Index Shift)\*\*！

  你刚才看过了“自顶向下”版本中神来之笔的 `i - 2`​，而这段代码则是将同样的逻辑完美地翻转成了\*\*“自底向上” (Bottom-Up)\*\* 的递推。

  为了处理 `i - 2`​ 带来的“数组越界”问题，灵茶山艾府在这里展示了一种极其优雅的处理技巧：​**整体向右平移 2 格**。

  让我们一层层剥开这段极其精简的代码：

  ### 1. 为什么是 `n + 2`？(空间偏移艺术)

  Java

  ```
  int[][] f = new int[n + 2][2];
  ```

  在上一题的记忆化搜索中，如果我们在第 `0`​ 天或第 `1`​ 天买入股票，我们要去查第 `-2`​ 天或第 `-1`​ 天的状态，这就需要写 `if (i < 0)` 的判断逻辑。

  为了彻底消灭 `if` 语句，我们直接把整个时间轴向未来推迟了 2 天：

  - 现实中的 **前天** -\> 对应数组的 `f[i]`
  - 现实中的 **昨天** -\> 对应数组的 `f[i + 1]`
  - 现实中的 **今天** -\> 对应数组的 `f[i + 2]`

  这样一来，现实中的第 `0`​ 天，在数组中就变成了 `f[2]`​。它所依赖的前天，正好是 `f[0]`，完美避开了负数下标！

  ### 2. 极简的初始化 (Base Cases)

  由于 Java 初始化 `int`​ 数组时默认全为 `0`​，其实 `f`​ 数组里已经充满了 `0`。但我们需要处理一个非法状态：

  Java

  ```
  f[1][1] = Integer.MIN_VALUE;
  ```

  - ​**​`f[1][1]`​** ​ **代表什么？**  它代表现实中“开市前一天”（第 `-1`​ 天）手里持有股票的最大利润。这显然是不可能的，所以设为极小值（防止被 `Math.max` 选中）。
  - **为什么不初始化** **​`f[0][1]`​** ​ **？**  因为在递推公式中，`f[i+2][1]`​ 的计算只会用到 `f[i+1][1]`​。当 `i=0`​ 时，用到的是 `f[1][1]`​。`f[0][1]`​ 根本不会被访问到，属于死角空间，全是 `0` 也无所谓。
  - **空仓状态** **​`f[0][0]`​** ​ **和** **​`f[1][0]`​** ​ **呢？**  它们默认是 `0`，完美代表了“开市前手里没股票，利润为 0”的初始合法状态。

  ### 3. 核心状态转移：严丝合缝的推导

  Java

  ```
  for (int i = 0; i < n; i++) {
      // 今天的空仓状态 = max(昨天空仓, 昨天持股 + 今天按原价卖出)
      f[i + 2][0] = Math.max(f[i + 1][0], f[i + 1][1] + prices[i]);
      
      // 今天的持股状态 = max(昨天持股, 前天空仓 - 今天按原价买入)
      f[i + 2][1] = Math.max(f[i + 1][1], f[i][0] - prices[i]);
  }
  ```

  这里是最精妙的地方。注意看等号右边的下标：

  - ​`prices[i]` 就是现实中“今天”的价格。
  - 在计算今天持股 `f[i + 2][1]`​ 的时候，如果选择“买入”，减去 `prices[i]`​ 之前的本金来源是 ​**​`f[i][0]`​** 。
  - ​`f[i][0]`​ 相比于今天的 `f[i + 2]`​，正好差了 ​**2**​！这完美对应了“冷冻期”的限制：**如果要在这天买入，本金必须来自于前天（甚至更早）的空仓状态，昨天绝不能有卖出动作。**

  ### 4. 提取最终果实

  Java

  ```
  return f[n + 1][0];
  ```

  循环结束后，现实中的最后一天 `n - 1`​，对应在数组里就是 `n - 1 + 2 = n + 1`​。我们返回最后一天、且最后手里**没有股票** (`0`) 的最大利润即可。

  ### 复杂度分析

  - ​**时间复杂度**​：O(N)。一个 `for`​ 循环从头走到尾，每次执行常数级别的 `Math.max` 计算。
  - ​**空间复杂度**​：O(N)。开辟了一个大小为 `(N + 2) * 2` 的二维数组。

  ---

  现在，我们终于来到了这道题的最终形态！

  既然我们在计算 `f[i + 2]`​ 时，永远只会用到 `f[i + 1]`​（昨天）和 `f[i]`（前天）的数据，那更早之前的数据（比如大前天）其实全成了废数据。

  想要我向你展示如何利用 3 个简单的变量（代替整个二维数组），把这道冷冻期股票问题的空间复杂度极限压缩到 **O(1)**  吗？

‍

## 三、空间优化

```java
class Solution {
    public int maxProfit(int[] prices) {
        int pre0 = 0;
        int f0 = 0;
        int f1 = Integer.MIN_VALUE;
        for (int p : prices) {
            int newF0 = Math.max(f0, f1 + p); // f[i+2][0]
            f1 = Math.max(f1, pre0 - p); // f[i+2][1]
            pre0 = f0;
            f0 = newF0;
        }
        return f0;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2201415/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-0k0l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太惊艳了！恭喜你，终于成功解锁了这道题的\*\*“终极形态”——空间复杂度 $O(1)$ 的状态压缩（滚动数组优化）\*\*！

  从一开始只能买卖一次的贪心，到处理复杂限制的二维、三维状态机，再到现在硬生生把庞大的状态表压缩成了​**仅仅** **$3$** **个变量**。掌握这种把内存压榨到极致的代码技巧，绝对是你以后在写简历和应对技术面试时，能让面试官眼前一亮的“必杀技”！

  让我们来看看这段代码是如何像变魔术一样，用三个变量实现“时光交替”的：

  ### 核心奥秘：滑动窗口与状态滚动

  在上一版的二维数组中，我们发现计算“今天”的状态，​**最远只需要追溯到“前天”** 。大前天、大大前天的数据其实全变成了没用的历史垃圾。

  既然如此，我们为什么要保留整个数组呢？我们只需要维护一个​**长度为 3 天的“滑动窗口”** ，随着时间往后推移，不断用新数据覆盖老数据就行了。

  ### 变量的“物理意义”映射

  代码里的三个变量，完美对应了我们在上一版本推导出的三个核心状态：

  - ​**​`pre0`​**​ (对应之前的 `f[i][0]`​)：代表\*\*“前天”\*\*手里没股票时的最大利润。初始值为 $0$（开市前没操作）。
  - ​**​`f0`​**​ (对应之前的 `f[i + 1][0]`​)：代表\*\*“昨天”\*\*手里没股票时的最大利润。初始值为 $0$。
  - ​**​`f1`​**​ (对应之前的 `f[i + 1][1]`​)：代表\*\*“昨天”\*\*手里有股票时的最大利润。初始值为 `Integer.MIN_VALUE`（因为还没开市不可能有股票）。

  ### 代码逐行拆解：时光滚轮的转动

  Java

  ```
  for (int p : prices) {
  ```

  每一天（价格为 `p`），时间的齿轮开始转动：

  Java

  ```
      int newF0 = Math.max(f0, f1 + p); 
  ```

  - ​**第一步：计算“今天”空仓的利润 (**​**​`newF0`​**​ **)** 。

    - 比较：昨天就空仓 (`f0`​) vs 昨天持股今天卖掉 (`f1 + p`)。
    - *注意：这里必须用一个临时变量* *​`newF0`​*​ *存起来。因为如果直接覆盖* *​`f0`​*​ *，下面更新* *​`pre0`​*​ *的时候，就会拿到已经被污染的“今天”的数据，而不是我们要的“昨天”的数据。*

  Java

  ```
      f1 = Math.max(f1, pre0 - p); 
  ```

  - ​**第二步：计算“今天”持股的利润 (**​**​`f1`​**​ **)** 。

    - 比较：昨天就持股 (`f1`​ 继续保持) vs **前天**空仓今天刚买 (`pre0 - p`)。
    - 这就是冷冻期的灵魂所在，直接调用 `pre0` 完美避开昨天卖出的可能！

  Java

  ```
      pre0 = f0;
  ```

  - ​**第三步：时光向前推进（更新前天）** 。

    - 对于明天来说，今天的“昨天”（`f0`​），就变成了明天的“前天”。所以把 `f0`​ 的值赋给 `pre0`。

  Java

  ```
      f0 = newF0;
  ```

  - ​**第四步：时光向前推进（更新昨天）** 。

    - 对于明天来说，“今天”刚算出来的空仓利润（`newF0`​），就变成了明天的“昨天”。把 `newF0`​ 赋给 `f0`。

  Java

  ```
  }
  ```

  最后，循环结束，我们直接返回 `f0`​，因为这时候它代表的就是​**最后一天结束时，手里没股票的最大利润**！

  ### 复杂度分析

  - ​**时间复杂度**：$O(N)$。仅仅遍历了一次价格数组，每次遍历执行几次简单的加减和赋值操作。
  - ​**空间复杂度**：​**$O(1)$**​。只使用了 `pre0`​、`f0`​、`f1`​ 和临时变量 `newF0`，没有任何数组开销！极致的优雅。

  ---

  走到这里，可以说你已经把动态规划在“状态机”领域的精髓彻底拿捏了。

  股票系列还有一个非常经典的变种：​ **“包含手续费的股票买卖”** ​（每次卖出股票时需要支付一笔固定的手续费 `fee`，但没有冷冻期）。

  趁热打铁，要不要试试把这三个变量的滚动逻辑稍作修改，一举拿下这道股票系列的“大满贯”最后一块拼图？

‍

# 714.买卖股票的最佳时机含手续费

[714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

## 一、递归搜索 + 保存计算结果 \= 记忆化搜索

```java
class Solution {
    private int[] prices;
    private int[][] memo;
    private int fee;

    public int maxProfit(int[] prices, int fee) {
        this.prices = prices;
        this.fee = fee;
        int n = prices.length;
        memo = new int[n][2];
        for (int[] row : memo) {
            Arrays.fill(row, Integer.MIN_VALUE); // MIN_VALUE 表示还没有计算过
        }
        return dfs(n - 1, 0);
    }

    private int dfs(int i, int hold) {
        if (i < 0) {
            return hold == 1 ? Integer.MIN_VALUE / 2 : 0; // 防止溢出
        }

        if (memo[i][hold] != Integer.MIN_VALUE) { // 之前计算过
            return memo[i][hold];
        }

        if (hold == 1) {
            return memo[i][hold] = Math.max(dfs(i - 1, 1), dfs(i - 1, 0) - prices[i]);
        }
        return memo[i][hold] = Math.max(dfs(i - 1, 0), dfs(i - 1, 1) + prices[i] - fee);
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/2469505/shi-pin-gu-piao-mai-mai-tong-yong-fang-f-0u38/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 恭喜你，终于来到了股票系列大满贯的最后一块拼图——​ **“买卖股票的最佳时机含手续费”** ！

  在经历了交易次数限制（$k$ 次）和冷冻期（`i - 2`）的洗礼后，再回过头来看这道题，你会发现它的逻辑简直如履平地。它不仅退回到了最基础的相邻两天的状态转移，而且没有了复杂的下标偏移，仅仅是在利润结算时多了一个小小的常数项。

  这依然是我们熟悉的\*\*“自顶向下”的记忆化搜索\*\*模板。让我们来看看“手续费”这个概念是如何极其自然地融入到状态转移方程中的：

  ### 核心破局点：把手续费算在买入还是卖出？

  题目规定：每笔交易你都需要付手续费。一笔交易包含一次买入和一次卖出。

  在数学上，无论你是​**在买入时提前扣除手续费**​，还是​**在卖出时统一结算手续费**​，最终的总利润是完全一样的。灵茶山艾府在这段代码中，选择了​**在卖出时统一扣除**。

  ### 代码逐行拆解

  #### 1. 初始化与边界条件

  Java

  ```
  memo = new int[n][2];
  for (int[] row : memo) {
      Arrays.fill(row, Integer.MIN_VALUE); // MIN_VALUE 表示还没有计算过
  }
  ```

  - 这里巧妙地用整型的绝对最小值 `Integer.MIN_VALUE` 作为“未计算”的标志。

  Java

  ```
  if (i < 0) {
      return hold == 1 ? Integer.MIN_VALUE / 2 : 0; // 防止溢出
  }
  ```

  - ​**时间的尽头**：回到第 $0$ 天之前。持有股票是非法状态，返回 `-∞/2`（除以 $2$ 是为了防止后面减去买入价格时发生整型向下溢出变成正数）；空仓则是合法的，本金利润为 $0$。

  #### 2. 状态转移：手续费的现身

  **当今天（第** **$i$** **天）持股** **​`hold == 1`​**​ **时：**

  Java

  ```
  return memo[i][hold] = Math.max(dfs(i - 1, 1), dfs(i - 1, 0) - prices[i]);
  ```

  - 选项 A（继续死拿）：昨天就持股 `dfs(i - 1, 1)`，今天无事发生。
  - 选项 B（今天刚买）：昨天空仓 `dfs(i - 1, 0)`​，今天按市价买入，扣除本金 `prices[i]`​。**注意：这里没有扣除手续费，因为我们约定了在卖出时才扣。**

  **当今天（第** **$i$** **天）不持股** **​`hold == 0`​**​ **时：**

  Java

  ```
  return memo[i][hold] = Math.max(dfs(i - 1, 0), dfs(i - 1, 1) + prices[i] - fee);
  ```

  - 选项 A（继续空仓）：昨天就空仓 `dfs(i - 1, 0)`，今天继续观望。
  - 选项 B（今天卖了）：昨天持股 `dfs(i - 1, 1)`​，今天按市价卖出获得 `prices[i]`​ 的现金。**关键来了！既然卖出了，这笔交易就彻底闭环了，必须立刻给交易所交钱，所以要**  **​`- fee`​**​ **。**

  ### 复杂度分析

  - ​**时间复杂度**：$O(N)$。共有 $N \times 2$ 个状态，通过 `memo` 数组记忆化，每个状态只计算一次。
  - ​**空间复杂度**：$O(N)$。使用了大小为 $2N$ 的二维数组，加上递归调用栈的深度最大为 $N$。

  ---

  走到这里，你已经彻底看透了动态规划状态机在股票问题上的本质。从无限制、到限制次数、到冷冻期、再到手续费，核心永远是回答那三个问题：

  1. ​**我今天有哪些状态？** （持股、空仓）
  2. ​**今天这个状态，可能是由昨天的哪些状态演变来的？** （状态转移方程）
  3. ​**初始状态（第 0 天之前）的合法与非法值是什么？** （边界条件）

  既然这道题只依赖“昨天”的状态（即 `i - 1`​），那么它显然也可以像之前那样，使用**滚动数组**将空间复杂度极限压缩到 $O(1)$。

  要不要我直接把这道题 $O(1)$ 空间复杂度的“终极自底向上”代码写出来，为你这场酣畅淋漓的股票系列学习之旅画上一个完美的句号？

‍

---

## 二、1:1 翻译成递推

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int[][] f = new int[n + 1][2];
        f[0][1] = Integer.MIN_VALUE / 2;
        for (int i = 0; i < n; i++) {
            f[i + 1][0] = Math.max(f[i][0], f[i][1] + prices[i] - fee);
            f[i + 1][1] = Math.max(f[i][1], f[i][0] - prices[i]);
        }
        return f[n][0];
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/2469505/shi-pin-gu-piao-mai-mai-tong-yong-fang-f-0u38/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这就是将上一题的“自顶向下”逻辑，完美翻转为\*\*“自底向上” (Bottom-Up)\*\* 的标准递推模板！

  这段代码非常清爽，它再次运用了我们之前讨论过的\*\*“空间偏移” (Index Shift)\*\* 技巧，通过把数组容量加一，兵不血刃地干掉了所有恶心的边界判断。

  让我们最后一次，像拆解工艺品一样来看看这段代码的精妙之处：

  ### 1. 巧妙的“第 0 天” (占位与防溢出)

  Java

  ```
  int[][] f = new int[n + 1][2];
  f[0][1] = Integer.MIN_VALUE / 2;
  ```

  - ​**容量** **​`n + 1`​**​：数组大小开到 `n + 1`​，意味着 `f[1]`​ 对应现实中的第 1 天（索引 0），而 `f[0]` 变成了一个虚拟的“开市前状态”。
  - ​**​`f[0][0]`​** ​  **(隐式为 0)** ：开市前手里没股票，利润是 $0$，这是完全合法的初始本金。
  - ​**​`f[0][1] = -∞ / 2`​**​：开市前手里不可能有股票，这是一个非法状态。​**除以 2 的细节非常关键**​：因为在后面的状态转移中，我们会执行 `f[i][0] - prices[i]`​，如果直接用 `Integer.MIN_VALUE`，减去一个正数价格会导致整型向下溢出（变成一个巨大的正数），从而引发致命的逻辑错误。

  ### 2. 状态转移：手续费的精准打击

  Java

  ```
  for (int i = 0; i < n; i++) {
      f[i + 1][0] = Math.max(f[i][0], f[i][1] + prices[i] - fee);
      f[i + 1][1] = Math.max(f[i][1], f[i][0] - prices[i]);
  }
  ```

  这段递推逻辑极其严丝合缝。计算“今天” (`i + 1`​) 的状态，完全只依赖于“昨天” (`i`) 的状态：

  - ​**今天没股票 (**​**​`f[i + 1][0]`​** ​ **)** ​：要么是昨天就没股票 (`f[i][0]`​) 继续观望；要么是昨天有股票，今天卖了换成现金 `+ prices[i]`​，并且​**立刻支付手续费**  **​`- fee`​**。
  - ​**今天有股票 (**​**​`f[i + 1][1]`​** ​ **)** ​：要么是昨天就有股票 (`f[i][1]`​) 继续持有；要么是昨天没股票，今天花钱买了 `- prices[i]`。

  最后直接返回 `f[n][0]`，即最后一天手里没股票的最大利润，完美收官。

  ### 3. 复杂度分析

  - ​**时间复杂度**：$O(N)$。遍历一次数组。
  - ​**空间复杂度**：$O(N)$。开辟了一个 $(N + 1) \times 2$ 的二维数组。

  ---

  走到这一步，相信你的直觉已经非常敏锐了！

  在递推方程中，`f[i + 1]`​ **永远只依赖于** `f[i]`。这意味着整个二维数组其实大部分都是没用的历史数据，我们只需要两个变量交替滚动即可。

  要不要我为你写出这道题的最终绝杀——​**空间复杂度被极限压缩到** **$O(1)$** **的终极代码**，为你这趟充实的股票系列学习之旅画上完美的句号？

‍

## 三、空间优化

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int f0 = 0;
        int f1 = Integer.MIN_VALUE / 2;
        for (int p : prices) {
            int newF0 = Math.max(f0, f1 + p - fee);
            f1 = Math.max(f1, f0 - p);
            f0 = newF0;
        }
        return f0;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/2469505/shi-pin-gu-piao-mai-mai-tong-yong-fang-f-0u38/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太完美了！这就是整个股票买卖系列的最强绝杀——​**空间复杂度** **$O(1)$** **的状态压缩（滚动数组优化）** ！

  恭喜你，跟着这段代码，你已经走完了从最基础的贪心算法，到二维/三维动态规划，再到极致空间压缩的完整进阶之路。这种把内存压榨到极致的代码功底，在技术面试中绝对是能让面试官频频点头的加分项，也是检验基础扎实程度的试金石。

  让我们最后一次，来欣赏这段只有寥寥几行，却逻辑严密的工业级代码：

  ### 核心奥秘：告别数组，迎接变量

  在上一版代码中，我们发现推导“今天”的状态，​**永远只需要用到“昨天”的数据**。前天、大前天的数据全都是冗余的。既然如此，我们根本不需要开辟一个长度为 $N$ 的数组，只需要两个变量交替滚动即可！

  - ​**​`f0`​**​：代表“昨天”手里没股票时的最大利润。初始值为 `0`。
  - ​**​`f1`​**​：代表“昨天”手里有股票时的最大利润。初始值为 `-∞ / 2`（防止后续减法溢出）。

  ### 代码逐行拆解：防污染的临时变量

  Java

  ```
  for (int p : prices) {
  ```

  随着每一天的价格 `p` 到来，状态开始滚动：

  Java

  ```
      int newF0 = Math.max(f0, f1 + p - fee);
  ```

  - ​**计算今天的空仓利润**​：要么昨天就空仓（`f0`​），要么昨天持股今天卖掉，并扣除手续费（`f1 + p - fee`）。
  - ​ **⚠️ 绝妙细节** **​`newF0`​**​：这里必须用一个临时变量存起来！因为如果直接写 `f0 = ...`​，那么 `f0`​ 就变成了“今天”的数据。而在下一步计算持股利润时，我们需要用到的是“昨天”的 `f0`。如果不引入临时变量，昨天的数据就会被无情覆盖（数据污染）。

  Java

  ```
      f1 = Math.max(f1, f0 - p);
  ```

  - ​**计算今天的持股利润**​：要么昨天就持股（`f1`​），要么用**昨天**的空仓利润在今天买入（`f0 - p`）。
  - 这里因为 `f0` 还没有被真正更新，所以它依然保留着“昨天”的纯洁状态。

  Java

  ```
      f0 = newF0;
  ```

  - ​**时光推进**​：把今天刚算出来的空仓利润 `newF0`​ 正式赋值给 `f0`。对于明天来说，这就是崭新的“昨天”。

  Java

  ```
  }
  return f0;
  ```

  遍历结束，直接返回 `f0`（最后一天手里没股票的最大利润），干净利落。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N)$。仅仅用一个 `for` 循环遍历了一次价格数组。
  - ​**空间复杂度**：​**$O(1)$**​。全场只用了 `f0`​、`f1`​ 和 `newF0` 三个整型变量，连数组的影子都没了，内存消耗降到了最低！

  ---

  ### 股票系列大满贯总结

  回顾这几道题，其实所有股票问题的本质都在于​**状态转移**。

  1. ​**定义状态**​：手里有股票（`1`​），还是没股票（`0`）。
  2. ​**寻找前置条件**：今天的状态是怎么从昨天（甚至是冷冻期的前天）变过来的。
  3. ​**处理特殊限制**：

     - 有交易次数限制 $k$？那就再加一维状态记录次数。
     - 有冷冻期？那就让买入操作去读取 `i - 2` 的状态。
     - 有手续费？那就在卖出（或买入）的时候减去常数 `fee`。
  4. ​**空间优化**：只要当前状态只依赖前一两个状态，就果断用滚动变量干掉数组。

### 两大 DP 流派的碰撞

在这份总结中，Carl（代码随想录作者）偏向于​**严谨的二维（或多维）数组推导**​。这种写法最大的好处是​**直观、不易出错**。

- **状态定义的直白性：**  比如在“最多买卖两次 (123题)”中，直接定义了 $5$ 个明确的状态（没有操作、第一次买、第一次卖、第二次买、第二次卖）。相比于利用下标偏移去隐式表达交易次数，这种写法在复盘时一眼就能看懂 `dp[i][3]` 代表什么。
- **完整的历史记录：**  虽然空间复杂度通常是 $O(n)$，但它保留了每一天所有的状态变迁。如果面试官不仅要求返回最大利润，还要求​**打印出具体的买卖日期路径**，这种保留了完整 $dp$ 表格的做法就能瞬间派上用场。

### 你的进阶武库

通过这段时间的刷题复习，你在处理“状态机 DP”上其实已经掌握了两套极其强大的武器：

1.  **“随想录”的标准递推阵型：**  适合在考场上快速理清思路。先老老实实把 $dp$ 数组的大小开足，把每一天的状态转移方程写对，确保先拿到 AC（Accept）。
2.  **“灵神”的极致降维打击：**  也就是我们在前几题深挖的滚动数组和常数级变量优化。当你用标准写法跑通后，如果面试官微笑着问：“能不能把空间复杂度优化到 $O(1)$ 呢？”你就可以从容地祭出那几个滚动变量，完成绝杀。

### 股票系列通关核心密码

无论是哪种语言、哪种写法，整个股票系列的灵魂只有一个——​**明确今天的状态，寻找昨天的来源**：

- **今天持股** \= $\max$ (昨天就持股, 昨天合法空仓 - 今天买入价)
- **今天空仓** \= $\max$ (昨天就空仓, 昨天持股 + 今天卖出价)

只要在这个骨架上，根据题目要求贴上“交易次数 $k$”、“冷冻期 `i-2`​”、“手续费 `-fee`”的补丁，任何股票题都不在话下。

‍
