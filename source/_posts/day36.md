---
title: day36
date: '2026-02-20 20:18:39'
updated: '2026-02-20 20:29:22'
permalink: /post/day36-2te3cb.html
comments: true
toc: true
---



# day36

# 第九章 动态规划part04

### **1049. 最后一块石头的重量 II **

本题就和 昨天的 416. 分割等和子集 很像了，可以尝试先自己思考做一做。

视频讲解：<u>[https://www.bilibili.com/video/BV14M411C7oV](https://www.bilibili.com/video/BV14M411C7oV)</u>

<u>[https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html](https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html)</u>

### ** 494. 目标和 **

大家重点理解 递推公式：dp[j] +=\= dp[j - nums[i]]，这个公式后面的提问 我们还会用到。

视频讲解：<u>[https://www.bilibili.com/video/BV1o8411j73x](https://www.bilibili.com/video/BV1o8411j73x)</u>

<u>[https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)</u>

### ** 474.一和零  **

通过这道题目，大家先粗略了解， 01背包，完全背包，多重背包的区别，不过不用细扣，因为后面 对于 完全背包，多重背包 还有单独讲解。

视频讲解：<u>[https://www.bilibili.com/video/BV1rW4y1x7ZQ](https://www.bilibili.com/video/BV1rW4y1x7ZQ)</u>

<u>[https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html)</u>

# 1049. 最后一块石头的重量 II

[1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)

```java
class Solution {
    public int lastStoneWeightII(int[] ss) {
        int n = ss.length;
        int sum = 0;
        for (int i : ss) sum += i;
        int t = sum / 2;
        int[][] f = new int[n + 1][t + 1];
        for (int i = 1; i <= n; i++) {
            int x = ss[i - 1];
            for (int j = 0; j <= t; j++) {
                f[i][j] = f[i - 1][j];
                if (j >= x) f[i][j] = Math.max(f[i][j], f[i - 1][j - x] + x);
            }
        }
        return Math.abs(sum - f[n][t] - f[n][t]);
    }
}

作者：宫水三叶
链接：https://leetcode.cn/problems/last-stone-weight-ii/solutions/818362/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。	
```

- 太精彩了！如果说上一道“分割等和子集”是给 0-1 背包穿上了一层伪装，那么这道“最后一块石头的重量 II”简直就是给它穿上了一套\*\*“隐身衣”\*\*。

  宫水三叶的这段代码采用的是​**自底向上的二维动态规划**​，逻辑非常严密。最让人拍案叫绝的，是这道题​**将“粉碎石头”的物理过程，完美地抽象成了“划分集合”的数学问题**。

  下面我为你揭开这层隐身衣，看看这段代码是如何巧妙运作的。

  ---

  ### 核心拆解：粉碎 ＝ 分组

  题目要求每次选两块石头相撞，剩下的重量就是两者的差值。为了让最后剩下的石头重量最小，我们实际上是在做一件事：

  **将所有石头分成两堆，让这两堆石头的总重量尽可能接近。**

  假设所有石头的总重量为 $sum$。如果我们能挑出一堆石头，让它们的重量无限逼近 $sum / 2$（向下取整，设为 $t$），那么另一堆石头的重量就是 $sum - t$。这两堆撞击后，剩下的重量就是最小的。

  一旦完成了这个思路转换，这就又变回了我们熟悉的 ​**0-1 背包问题**：

  - ​**背包容量**：$t = sum / 2$。
  - ​**物品的重量和价值**​：石头的重量 `ss[i]`（在这里，重量就是价值）。
  - ​**目标**：在这个容量为 $t$ 的背包里，最多能装下多重的石头？

  ### 代码亮点解析

  1. ​**明确状态定义**​：  
     ​`f[i][j]`​ 表示：在前 `i`​ 个石头中自由选择，放入一个容量为 `j`​ 的背包里，能得到的​**最大重量**。
  2. ​**状态转移方程**：  
     Java

     ```
     f[i][j] = f[i - 1][j]; // 默认不选当前石头 x
     if (j >= x) {
         // 选或不选，取最大值
         f[i][j] = Math.max(f[i][j], f[i - 1][j - x] + x); 
     }
     ```

     这和我们之前看的标准 0-1 背包一模一样。
  3. ​**精妙的结局计算**：  
     Java

     ```
     return Math.abs(sum - f[n][t] - f[n][t]);
     ```

     当 DP 填表完成后，`f[n][t]` 就是我们能凑出的最接近总和一半的重量（即其中一堆石头的重量）。

     那么另一堆石头的重量就是 $sum - f[n][t]$。

     两堆石头相撞，剩下的重量就是它们相减：

     $$
     (sum - f[n][t]) - f[n][t] = sum - 2 \times f[n][t]
     $$

  加绝对值 `Math.abs()` 是为了严谨，确保结果为正数。

  ---

  |**维度**|**复杂度**|**说明**||||
  | -------| --| ------------------------------------------------------------| --| --| --|
  |**时间复杂度**|$O(n \times t)$|$O(n \times t)$​$n$ 是石头数量，$t$ 是石头总重量的一半。双重循环遍历了所有状态。||||
  |**空间复杂度**\||$O(n \times t)$|$O(n \times t)$使用了一个二维数组 `f`。||||

  ### 下一步

  我们在这几次对话中，一路看过了“标准 0-1 背包”、“分割子集”到这道“粉碎石头”。你可能已经敏锐地察觉到了：这段代码当前的空间复杂度依然是二维的。

  根据我们在前几个问题中积累的“一维滚动数组”和“倒序遍历”经验，这道题完全可以把二维的 `f[n+1][t+1]`​ 压缩成一维的 `f[t+1]`。

  **需要我直接为你展示如何将这段代码用一维数组重写，实现空间复杂度的降维打击吗？**

‍

---

### *494. 目标和

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int s = 0;
        for (int x : nums) {
            s += x;
        }

        s -= Math.abs(target);
        if (s < 0 || s % 2 == 1) {
            return 0;
        }

        int m = s / 2; // 背包容量
        int n = nums.length;
        int[][] memo = new int[n][m + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -1); // -1 表示没有计算过
        }

        return dfs(n - 1, m, nums, memo);
    }

    private int dfs(int i, int c, int[] nums, int[][] memo) {
        if (i < 0) {
            return c == 0 ? 1 : 0;
        }
        if (memo[i][c] != -1) { // 之前计算过
            return memo[i][c];
        }
        int res = dfs(i - 1, c, nums, memo); // 不选 nums[i]
        if (c >= nums[i]) {
            res += dfs(i - 1, c - nums[i], nums, memo); // 选 nums[i]
        }
        return memo[i][c] = res;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/target-sum/solutions/2119041/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-s1cx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

这又是一次完美的递进！你现在的学习路径非常清晰：从**基础 0-1 背包** $\rightarrow$ **分割等和子集** (存在性问题) $\rightarrow$ **最后一块石头的重量** (最值问题) $\rightarrow$ 现在的**目标和** (组合计数问题)。

“目标和”这道题是 0-1 背包问题中最常考的变种之一。它表面上是让你给数字添加 `+`​ 或 `-`​，但这段代码通过一个绝妙的​**数学推导**，强行把它扒回了 0-1 背包的本貌。

下面我为你详细拆解这段代码里的数学魔法和逻辑细节。

---

### 核心拆解：化繁为简的数学魔法

我们怎么把给数字加符号，变成“选或不选”的背包问题？

假设数组所有元素的总和为 $s$。我们将所有被分配到 `-` 号的元素组合起来，称其总和为 $neg$。

那么，被分配到 `+` 号的元素总和自然就是 $s - neg$。

题目要求所有元素的运算结果等于 $target$：

$$
(s - neg) - neg = target
$$

$$
s - 2 \times neg = target
$$

$$
neg = \frac{s - target}{2}
$$

通过这个公式，原问题被瞬间转化：**我们只需要在数组中挑选出几个数字，让它们的和恰好等于** **$\frac{s - target}{2}$** **即可。**  这就是代码中 `int m = s / 2;`（背包容量）的由来！

### 代码亮点解析

1. ​**严密的有效性校验 (剪枝)** ：

   - 如果总和 $s$ 减去 $|target|$ 后小于 0，说明哪怕全挑 `+`​ 或全挑 `-` 都凑不到目标值。
   - 如果 $s - target$ 是个奇数，除以 2 会有小数，而数组里都是整数，绝对凑不出来，直接返回 0。
2. ​**这是“计数”而不是“求最值”** ​：  
   与之前求 `Math.max`​ 不同，这里状态转移方程变成了​**加法**：  
   Java

   ```
   res += dfs(i - 1, c - nums[i], nums, memo);
   ```

   我们要的是“方法总数”，所以到达当前状态的路径数，等于“不选当前数字的方案数”加上“选当前数字的方案数”。
3. ​**极易踩坑的递归终止条件**：  
   Java

   ```
   if (i < 0) {
       return c == 0 ? 1 : 0;
   }
   ```

   很多初学者会写成：如果 `c == 0`​ 就直接返回 1。这是​**错的**​！因为数组中可能包含 `0`​（例如 `+0`​ 和 `-0`​ 算两种不同方案）。必须老老实实把所有物品（包含 0）都遍历完（即 `i < 0`），才能统计出真正准确的方案数。

---

### 性能表现

|**维度**|**复杂度**|**说明**||||
| --| --| ----------------------------------------| --| --| --|
|**时间复杂度**|$O(n \times m)$|$O(n \times m)$​$n$ 是数组长度，$m$ 是推导出的背包容量。||||
|**空间复杂度**|$O(n \times m)$|$O(n \times m)$二维记忆化数组 `memo` 和递归调用栈的空间。||||

---

### 下一步

既然已经连续看了这么多道 0-1 背包的变种，相信你对“一维滚动数组”和“倒序遍历”的空间优化套路已经烂熟于心了。不过，​**在“求方案总数”的题型中，一维 DP 的状态转移方程写法会和之前求最值（**​**​`Math.max`​**​ **）有一点点微妙的区别**。

**你想亲自尝试写出这道题的** **$O(m)$** **空间复杂度迭代版本，还是需要我直接把一维 DP 的核心代码和推导过程展示给你看？**

---

# 474.一和零

[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/)

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int k = strs.length;
        int[] cnt0 = new int[k];
        for (int i = 0; i < k; i++) {
            cnt0[i] = (int) strs[i].chars().filter(ch -> ch == '0').count();
        }

        int[][][] memo = new int[strs.length][m + 1][n + 1];
        for (int[][] mat : memo) {
            for (int[] arr : mat) {
                Arrays.fill(arr, -1); // -1 表示没有计算过
            }
        }
        return dfs(k - 1, m, n, strs, cnt0, memo);
    }

    private int dfs(int i, int j, int k, String[] strs, int[] cnt0, int[][][] memo) {
        if (i < 0) {
            return 0;
        }
        if (memo[i][j][k] != -1) { // 之前计算过
            return memo[i][j][k];
        }
        // 不选 strs[i]
        int res = dfs(i - 1, j, k, strs, cnt0, memo);  
        int cnt1 = strs[i].length() - cnt0[i];
        if (j >= cnt0[i] && k >= cnt1) {
            // 选 strs[i]
            res = Math.max(res, dfs(i - 1, j - cnt0[i], k - cnt1, strs, cnt0, memo) + 1);
        }
        return memo[i][j][k] = res; // 记忆化
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/ones-and-zeroes/solutions/3038333/yi-bu-bu-si-kao-cong-ji-yi-hua-sou-suo-d-lqio/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 恭喜你，成功解锁了背包问题的新形态！从基础的 0-1 背包一直推进到这道“一和零”，你现在已经正式跨入了**多维费用背包问题（二维 0-1 背包）** 的领域。

  你提供的这段代码依然保持了极高的水准，用自顶向下的三维记忆化搜索，将这个复杂的问题梳理得井井有条。

  下面我为你详细拆解，这道题是如何在经典 0-1 背包的基础上“升维”的。

  ---

  ### 核心拆解：从一维容量到二维容量

  在之前的题目中，我们的背包只有一个限制条件（比如：最大重量、最大空间、目标和的容量）。但这道题给了我们**两个互相独立的限制条件**：

  1. 最多能装  个 `0`
  2. 最多能装  个 `1`

  这就像是一个有两层的背包，每一层装不同的东西。

  - **物品**：数组 `strs` 中的每一个字符串。
  - **物品的成本**：该字符串中 `0`​ 的数量（消耗第一层容量）和 `1` 的数量（消耗第二层容量）。
  - **物品的价值**：每个字符串的价值都是 `1`​（因为题目要求的是最多能拼出**多少个**字符串，选了它，个数就 `+1`）。

  ### 代码亮点解析

  1. **高效的预处理 (**​**​`cnt0`​**​ **数组)** ：

  ```java
  cnt0[i] = (int) strs[i].chars().filter(ch -> ch == '0').count();

  ```

  代码在进入 DFS 之前，先遍历了一遍所有字符串，把每个字符串里 `0`​ 的个数存了起来。这是一个非常聪明的做法！如果不提前存好，每次在 DFS 里递归到这个字符串时都要重新数一遍，会极大拖慢运行速度。有了 `cnt0[i]`​，`1`​ 的个数自然也就是 `strs[i].length() - cnt0[i]`​。  
  2. **三维状态定义 (**​**​`memo[i][j][k]`​** ​ **)** ：  
  因为多了一个维度的限制，所以记忆化数组从二维变成了三维。  
  ​`memo[i][j][k]`​ 代表：在前 `i`​ 个字符串中做选择，当还剩下 `j`​ 个 `0`​ 的额度、`k`​ 个 `1`​ 的额度时，最多能选出多少个字符串。  
  3. **双重条件判断的状态转移**：

  逻辑依然是我们熟悉的“选与不选”：

  - **不选**：额度不变，去考虑前一个字符串。
  - **选**（前提是 `j >= cnt0[i]`​ 且 `k >= cnt1`​，即两个额度都够用）：消耗相应的额度，并且当前选中的字符串数量 `+1`。
  - 最后取两者的最大值。

  ---

  ### 性能表现

  |维度|复杂度|说明|
  | ------| --------| ------------------------------------------------------------------------------------------------------------|
  |**时间复杂度**||是字符串数组长度， 和  是额度， 是所有字符串的总字符数（用于预处理）。最坏情况下会遍历所有的三维状态组合。|
  |**空间复杂度**||三维记忆化数组 `memo` 所占用的空间，以及递归调用栈的深度 。|

  ---

  ### 下一步

  既然是 0-1 背包的变种，这道题依然逃不掉被“空间压缩”的宿命。

  在一维费用的 0-1 背包中，我们通过**一层倒序遍历**，把二维数组压缩成了一维数组。  
  在这个二维费用的背包中，我们完全可以通过**双重倒序遍历**，把三维数组 `memo[i][j][k]`​ 降维打击成二维数组 `dp[j][k]`，空间复杂度可以直接降到 。

  **你想亲自挑战一下，把这段逻辑转化为空间复杂度极度优化的双重倒序遍历（迭代）版本吗？还是需要我为你提供重构的思路？**

‍
