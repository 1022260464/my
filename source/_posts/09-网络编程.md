---
title: 09网络编程
date: '2026-02-17 13:27:25'
updated: '2026-02-17 13:36:13'
permalink: /post/09network-programming-z2d62pl.html
comments: true
toc: true
---



# 09网络编程

在Java网络编程中，\*\*TCP（传输控制协议）**和**UDP（用户数据报协议）\*\*是两种最核心的传输层协议。它们在工作方式、可靠性和适用场景上有很大的不同。

为了更直观地理解，我们可以先看看它们在通信流程上的差异：

下面我将从核心区别、Java实现方式以及代码示例这三个方面为您详细梳理。

---

### 一、 TCP 与 UDP 的核心区别

在决定使用哪种协议之前，了解它们的特性差异至关重要。

|**特性**|**TCP (Transmission Control Protocol)**|**UDP (User Datagram Protocol)**||||
| --| ----------------------------------------------| ----------------------------------------| --| --| --|
|**连接性**|面向连接（需经过“三次握手”建立连接）|无连接（直接发送，不管对方是否准备好）||||
|**可靠性**|高。保证数据不丢失、不重复、按序到达|低。尽最大努力交付，可能丢包或乱序到达||||
|**传输速度**|较慢（因为有确认机制、重传机制等开销）|较快（没有连接和确认的开销）||||
|**数据格式**|面向字节流（没有明确的边界，可能发生粘包）|面向报文（每个数据包有明确的边界）||||
|**系统资源**|消耗较多|消耗较少||||
|**典型应用场景**|文件传输、网页浏览(HTTP)、电子邮件、即时通讯|视频直播、在线游戏、语音通话、DNS查询||||

---

### 二、 Java TCP 通信实现

Java 中的 TCP 通信主要依赖于 `java.net` 包下的两个核心类：

1. ​**​`ServerSocket`​**：用于服务端，监听特定端口，等待客户端连接。
2. ​**​`Socket`​**：用于客户端发起连接，以及服务端接收连接后用于和客户端进行数据读写。

#### TCP 服务端代码示例：

Java

```
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TCPServer {
    public static void main(String[] args) throws Exception {
        // 1. 创建 ServerSocket，监听 8888 端口
        ServerSocket serverSocket = new ServerSocket(8888);
        System.out.println("服务端已启动，等待客户端连接...");

        // 2. 调用 accept() 阻塞等待客户端连接
        Socket socket = serverSocket.accept();
        System.out.println("客户端已连接，IP: " + socket.getInetAddress().getHostAddress());

        // 3. 获取输入流，读取客户端发送的数据
        InputStream is = socket.getInputStream();
        byte[] buffer = new byte[1024];
        int len = is.read(buffer);
        System.out.println("收到客户端消息: " + new String(buffer, 0, len));

        // 4. 释放资源
        is.close();
        socket.close();
        serverSocket.close();
    }
}
```

#### TCP 客户端代码示例：

Java

```
import java.io.OutputStream;
import java.net.Socket;

public class TCPClient {
    public static void main(String[] args) throws Exception {
        // 1. 创建 Socket，指定服务端的 IP 和端口并建立连接
        Socket socket = new Socket("127.0.0.1", 8888);

        // 2. 获取输出流，向服务端发送数据
        OutputStream os = socket.getOutputStream();
        os.write("你好，我是TCP客户端！".getBytes());

        // 3. 释放资源
        os.close();
        socket.close();
    }
}
```

---

### 三、 Java UDP 通信实现

Java 中的 UDP 通信不像 TCP 那样区分严格的“服务端”和“客户端”，而是分为“发送端”和“接收端”。核心类主要有两个：

1. ​**​`DatagramSocket`​**：相当于快递站点，负责发送和接收数据包。
2. ​**​`DatagramPacket`​**：相当于快递包裹，封装了要发送的数据、目标 IP 和端口（发送时用），或者用于作为接收数据的容器（接收时用）。

#### UDP 接收端代码示例：

> ​**注意**：必须先启动接收端，否则发送端发出的数据会因为无人接收而丢失（UDP不会报错）。

Java

```
import java.net.DatagramPacket;
import java.net.DatagramSocket;

public class UDPReceiver {
    public static void main(String[] args) throws Exception {
        // 1. 创建 DatagramSocket，监听 9999 端口
        DatagramSocket socket = new DatagramSocket(9999);
        System.out.println("UDP 接收端已启动...");

        // 2. 创建一个空的 DatagramPacket，用于接收数据
        byte[] buffer = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

        // 3. 阻塞等待接收数据
        socket.receive(packet);

        // 4. 解析数据
        String message = new String(packet.getData(), 0, packet.getLength());
        String senderIp = packet.getAddress().getHostAddress();
        System.out.println("收到来自 " + senderIp + " 的消息: " + message);

        // 5. 释放资源
        socket.close();
    }
}
```

#### UDP 发送端代码示例：

Java

```
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPSender {
    public static void main(String[] args) throws Exception {
        // 1. 创建 DatagramSocket（发送端通常不需要指定端口，由系统随机分配）
        DatagramSocket socket = new DatagramSocket();

        // 2. 准备要发送的数据，并将其封装到 DatagramPacket 中
        String message = "你好，我是UDP发送端！";
        byte[] data = message.getBytes();
        // 指定接收端的 IP 和端口
        InetAddress targetIp = InetAddress.getByName("127.0.0.1");
        int targetPort = 9999;
        DatagramPacket packet = new DatagramPacket(data, data.length, targetIp, targetPort);

        // 3. 发送数据包
        socket.send(packet);
        System.out.println("UDP 数据包已发送。");

        // 4. 释放资源
        socket.close();
    }
}
```

---

### 总结

- 如果您正在开发类似**聊天软件的消息发送、文件下载、数据库连接**等对数据准确性要求极高的应用，请选择 ​**TCP**。
- 如果您正在开发**视频会议、在线直播、实时对战游戏**等对延迟敏感，且能容忍少量画面卡顿或丢包的应用，请选择 ​**UDP**。

您希望我进一步演示如何使用 ​**多线程处理多个 TCP 客户端的连接**​，还是想了解更高效的 **Java NIO（非阻塞IO）**  在网络编程中的应用呢？

# 综合实战代码：

# 《综合项目实战-局域网内的沟通软件》

## 需求：

- 展示一个用户的登录界面，这个界面只要求用户输入自己聊天的昵称就可以了。

登录进入后，展示一个群聊的窗口，这个窗口，展示在线人数，展示消息展示框，消息输入框，发送按钮。可以实现群聊。实现实时展示在线人数。完全做到即时通讯功能。

## 技术选型

1、GUI编程技术：Swing

2、网络编程

3、面向对象设计

4、常用API

## 思路分析

### 1、创建一个模块，代表我们的项目

- 模块名取名为：itheima-chat-system.

### 2、拿到系统需要的界面：Swing的代码

       --  登录界面：这个界面只要求用户输入自己聊天的昵称就可以了。

```
package com.itheima.ui;
​
import javax.swing.*;
import java.awt.*;
​
public class ChatEntryFrame extends JFrame {
​
    private JTextField nicknameField;
    private JButton enterButton;
    private JButton cancelButton;
​
    public ChatEntryFrame() {
        setTitle("局域网聊天室");
        setSize(350, 150);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        setResizable(false); // 禁止调整大小
​
        // 设置背景颜色
        getContentPane().setBackground(Color.decode("#F0F0F0"));
​
        // 创建主面板并设置布局
        JPanel mainPanel = new JPanel(new BorderLayout());
        mainPanel.setBackground(Color.decode("#F0F0F0"));
        add(mainPanel);
​
        // 创建顶部面板
        JPanel topPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        topPanel.setBackground(Color.decode("#F0F0F0"));
​
        // 标签和文本框
        JLabel nicknameLabel = new JLabel("昵称:");
        nicknameLabel.setFont(new Font("楷体", Font.BOLD, 16));
        nicknameField = new JTextField(10);
        nicknameField.setFont(new Font("楷体", Font.PLAIN, 16));
        nicknameField.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1, 1, 1, 1, Color.GRAY),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)
        ));
​
        topPanel.add(nicknameLabel);
        topPanel.add(nicknameField);
        mainPanel.add(topPanel, BorderLayout.NORTH);
​
        // 按钮面板
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        buttonPanel.setBackground(Color.decode("#F0F0F0"));
​
        enterButton = new JButton("进入");
        enterButton.setFont(new Font("楷体", Font.BOLD, 16));
        enterButton.setBackground(Color.decode("#007BFF"));
        enterButton.setForeground(Color.WHITE);
        enterButton.setBorderPainted(false);
        enterButton.setFocusPainted(false);
​
        cancelButton = new JButton("取消");
        cancelButton.setFont(new Font("楷体", Font.BOLD, 16));
        cancelButton.setBackground(Color.decode("#DC3545"));
        cancelButton.setForeground(Color.WHITE);
        cancelButton.setBorderPainted(false);
        cancelButton.setFocusPainted(false);
​
        buttonPanel.add(enterButton);
        buttonPanel.add(cancelButton);
        mainPanel.add(buttonPanel, BorderLayout.SOUTH);
​
        // 添加监听器
        enterButton.addActionListener(e -> {
            String nickname = nicknameField.getText();
            if (!nickname.isEmpty()) {
                // 进入聊天室逻辑
                dispose(); // 关闭窗口
            } else {
                JOptionPane.showMessageDialog(this, "请输入昵称!");
            }
        });
​
        cancelButton.addActionListener(e -> System.exit(0));
​
        this.setVisible(true);
    }
​
    public static void main(String[] args) {
        new ChatEntryFrame();
    }
}
```

- 获取系统需要的聊天界面。
- ```
  package com.itheima.ui;
  ​
  import javax.swing.*;
  import java.awt.*;
  import java.awt.event.ActionEvent;
  import java.awt.event.ActionListener;
  ​
  public class ClientChatFrame extends JFrame {
      public JTextArea smsContent = new JTextArea(23, 50);
      private JTextArea smsSend = new JTextArea(4, 40);
      public JList<String> onLineUsers = new JList<>();
      private JButton sendBn = new JButton("发送");
  ​
      public ClientChatFrame() {
          initView();
          this.setVisible(true);
      }
  ​
      private void initView() {
          this.setSize(700, 600);
          this.setLayout(new BorderLayout());
          this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 关闭窗口，退出程序
          this.setLocationRelativeTo(null); // 窗口居中
  ​
          // 设置窗口背景色
          this.getContentPane().setBackground(new Color(0xf0, 0xf0, 0xf0));
  ​
          // 设置字体
          Font font = new Font("SimKai", Font.PLAIN, 14);
  ​
          // 消息内容框
          smsContent.setFont(font);
          smsContent.setBackground(new Color(0xdd, 0xdd, 0xdd));
          smsContent.setEditable(false);
  ​
          // 发送消息框
          smsSend.setFont(font);
          smsSend.setWrapStyleWord(true);
          smsSend.setLineWrap(true);
  ​
          // 在线用户列表
          onLineUsers.setFont(font);
          onLineUsers.setFixedCellWidth(120);
          onLineUsers.setVisibleRowCount(13);
  ​
          // 创建底部面板
          JPanel bottomPanel = new JPanel(new BorderLayout());
          bottomPanel.setBackground(new Color(0xf0, 0xf0, 0xf0));
  ​
          // 消息输入框
          JScrollPane smsSendScrollPane = new JScrollPane(smsSend);
          smsSendScrollPane.setBorder(BorderFactory.createEmptyBorder());
          smsSendScrollPane.setPreferredSize(new Dimension(500, 50));
  ​
          // 发送按钮
          sendBn.setFont(font);
          sendBn.setBackground(Color.decode("#009688"));
          sendBn.setForeground(Color.WHITE);
  ​
          // 按钮面板
          JPanel btns = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));
          btns.setBackground(new Color(0xf0, 0xf0, 0xf0));
          btns.add(sendBn);
  ​
          // 添加组件
          bottomPanel.add(smsSendScrollPane, BorderLayout.CENTER);
          bottomPanel.add(btns, BorderLayout.EAST);
  ​
          // 用户列表面板
          JScrollPane userListScrollPane = new JScrollPane(onLineUsers);
          userListScrollPane.setBorder(BorderFactory.createEmptyBorder());
          userListScrollPane.setPreferredSize(new Dimension(120, 500));
  ​
          // 中心消息面板
          JScrollPane smsContentScrollPane = new JScrollPane(smsContent);
          smsContentScrollPane.setBorder(BorderFactory.createEmptyBorder());
  ​
          // 添加所有组件
          this.add(smsContentScrollPane, BorderLayout.CENTER);
          this.add(bottomPanel, BorderLayout.SOUTH);
          this.add(userListScrollPane, BorderLayout.EAST);
      }
  ​
      public static void main(String[] args) {
          new ClientChatFrame();
      }
  }
  ```

### 3、定义一个App启动类：创建进入界面对象并展示。

```
public class App {
    public static void main(String[] args) {
        new ChatEntryFrame();
    }
}
```

### 4、分析系统的整体架构。

![image-20240802151800841](file://F:\java\黑马程序员java学习路线\1.java基础\2.%20Java+AI（资料）\2.%20JavaSE基础加强6天课程\day05-网络编程\综合项目实战：局域网内的沟通软件\《综合项目实战-局域网内的沟通软件》.assets\image-20240802151800841.png?lastModify=1771306539)

1、开发服务端要做的事情大概有这些。

     -- 接收客户端的管道链接。

     -- 接收登录消息，接收昵称信息。

     -- 服务端也可能是接收客户端发送过来的群聊消息。

     -- 服务端存储全部在线的socket管道，以便到时候知道哪些客户端在线 ，以便为这些客户端转发消息。

     -- 如果服务端收到了登录消息，接收昵称，然后更新所有客户端的在线人数列表。

     -- 如果服务端收到了群聊消息，需要接收这个人的消息，再转发给所有客户端展示这个消息。

2、客户端界面已经准备好了。

### 5、先开发完整的服务端

- 第一步：创建一个服务端的项目：itheima-chat-server
- 第二步：创建一个服务端启动类，启动服务器等待客户端的链接。

```
public class Server {
    public static void main(String[] args) {
        System.out.println("启动服务端系统.....");
        try {
            // 1、注册端口。
            ServerSocket serverSocket = new ServerSocket(Constant.PORT);
            // 2、主线程负责接受客户端的连接请求
            while (true) {
                // 3、调用accept方法，获取到客户端的Socket对象
                System.out.println("等待客户端的连接.....");
                Socket socket = serverSocket.accept();
                System.out.println("一个客户端连接成功.....");
            }
        } catch (Exception e) {
           e.printStackTrace();
        }
    }
}
```

- 第三步：把这个管道交给一个独立的线程来处理：以便支持很多客户端可以同时进来通信。

```
public class Server {
    public static void main(String[] args) {
        System.out.println("启动服务端系统.....");
        try {
            // 1、注册端口。
            ServerSocket serverSocket = new ServerSocket(Constant.PORT);
            // 2、主线程负责接受客户端的连接请求
            while (true) {
                // 3、调用accept方法，获取到客户端的Socket对象
                System.out.println("等待客户端的连接.....");
                
                Socket socket = serverSocket.accept();
                new ServerReaderThread(socket).start();
                
                System.out.println("一个客户端连接成功.....");
            }
        } catch (Exception e) {
           e.printStackTrace();
        }
    }
}
```

- 第四步：定义一个集合容器存储所有登录进来的客户端管道，以便将来群发消息给他们.  
  -- 这个集合只需要一个记住所有的在线的客户端socket

```
// 定义一个Map集合，键是存储客户端的管道，值是这个管道的用户名称。
public static final Map<Socket, String> onLineSockets = new HashMap<>();
```

**第五步、服务端线程开始接收登录消息/群聊消息**

```
 // 接收的消息可能有很多种类型：1、登录消息（包含昵称） 2、群聊消息 3、私聊消息
            // 所以客户端必须声明协议发送消息
            // 比如客户端先发1，代表接下来是登录消息。
            // 比如客户端先发2，代表接下来是群聊消息。
```

```
public class ServerReaderThread extends Thread{
    private Socket socket;
    public ServerReaderThread(Socket socket) {
        this.socket = socket;
    }
​
    @Override
    public void run() {
        try {
            // 接收的消息可能有很多种类型：1、登录消息（包含昵称） 2、群聊消息 3、私聊消息
            // 所以客户端必须声明协议发送消息
            // 比如客户端先发1，代表接下来是登录消息。
            // 比如客户端先发2，代表接下来是群聊消息。
            // 先从socket管道中接收客户端发送来的消息类型编号
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            int type = dis.readInt();
            switch (type){
                case 1:
                    // 客户端发来了登录消息，接下来要接收昵称数据，再更新全部在线客户端的在线人数列表。
                    break;
                case 2:
                    // 客户端发来了群聊消息，接下来要接收群聊消息内容，再把群聊消息转发给全部在线客户端。
                    break;
                case 3:
                    // 客户端发来了私聊消息，接下来要接收私聊消息内容，再把私聊消息转发给指定客户端。
                    break;
            }
        } catch (Exception e) {
            System.out.println("客户端下线了："+ socket.getInetAddress().getHostAddress());
        }
    }
}
```

**第六步、实现服务端的登录消息接收**

```
package com.itheima;
​
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
import java.util.Collection;
​
public class ServerReaderThread extends Thread{
    private Socket socket;
    public ServerReaderThread(Socket socket) {
        this.socket = socket;
    }
​
    @Override
    public void run() {
        try {
            // 接收的消息可能有很多种类型：1、登录消息（包含昵称） 2、群聊消息 3、私聊消息
            // 所以客户端必须声明协议发送消息
            // 比如客户端先发1，代表接下来是登录消息。
            // 比如客户端先发2，代表接下来是群聊消息。
            // 先从socket管道中接收客户端发送来的消息类型编号
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            int type = dis.readInt(); // 1、2、3
            switch (type){
                case 1:
                    // 客户端发来了登录消息，接下来要接收昵称数据，再更新全部在线客户端的在线人数列表。
                    String nickname = dis.readUTF();
                    // 把这个登录成功的客户端socket存入到在线集合。
                    Server.onLineSockets.put(socket, nickname);
                    // 更新全部客户端的在线人数列表
                    updateClientOnLineUserList();
                    break;
                case 2:
                    // 客户端发来了群聊消息，接下来要接收群聊消息内容，再把群聊消息转发给全部在线客户端。
                    break;
                case 3:
                    // 客户端发来了私聊消息，接下来要接收私聊消息内容，再把私聊消息转发给指定客户端。
                    break;
            }
        } catch (Exception e) {
            System.out.println("客户端下线了："+ socket.getInetAddress().getHostAddress());
            Server.onLineSockets.remove(socket); // 把下线的客户端socket从在线集合中移除
        }
    }
​
    private void updateClientOnLineUserList() {
        // 更新全部客户端的在线人数列表
        // 拿到全部在线客户端的用户名称，把这些名称转发给全部在线socket管道。
        // 1、拿到当前全部在线用户昵称
        Collection<String> onLineUsers = Server.onLineSockets.values();
        // 2、把这个集合中的所有用户都推送给全部客户端socket管道。
        for (Socket socket : Server.onLineSockets.keySet()) {
            try {
                // 3、把集合中的所有用户名称，通过socket管道发送给客户端
                DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                dos.writeInt(1); // 1代表告诉客户端接下来是在线人数列表信息  2 代表发的是群聊消息
                dos.writeInt(onLineUsers.size()); // 告诉客户端，接下来要发多少个用户名称
                for (String onLineUser : onLineUsers) {
                    dos.writeUTF(onLineUser);
                }
                dos.flush();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

**第七步： 接收客户端的群聊消息**

线程没收一个客户端的群聊消息，就应该把这个消息转发给全部在线的客户端对应的socket管道

```
package com.itheima;
​
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collection;
​
public class ServerReaderThread extends Thread{
    private Socket socket;
    public ServerReaderThread(Socket socket) {
        this.socket = socket;
    }
​
    @Override
    public void run() {
        try {
            // 接收的消息可能有很多种类型：1、登录消息（包含昵称） 2、群聊消息 3、私聊消息
            // 所以客户端必须声明协议发送消息
            // 比如客户端先发1，代表接下来是登录消息。
            // 比如客户端先发2，代表接下来是群聊消息。
            // 先从socket管道中接收客户端发送来的消息类型编号
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            while (true) {
                int type = dis.readInt(); // 1、2、3
                switch (type){
                    case 1:
                        // 客户端发来了登录消息，接下来要接收昵称数据，再更新全部在线客户端的在线人数列表。
                        String nickname = dis.readUTF();
                        // 把这个登录成功的客户端socket存入到在线集合。
                        Server.onLineSockets.put(socket, nickname);
                        // 更新全部客户端的在线人数列表
                        updateClientOnLineUserList();
                        break;
                    case 2:
                        // 客户端发来了群聊消息，接下来要接收群聊消息内容，再把群聊消息转发给全部在线客户端。
                        String msg = dis.readUTF();
                        sendMsgToAll(msg);
                        break;
                    case 3:
                        // 客户端发来了私聊消息，接下来要接收私聊消息内容，再把私聊消息转发给指定客户端。
                        break;
                }
            }
        } catch (Exception e) {
            System.out.println("客户端下线了："+ socket.getInetAddress().getHostAddress());
            Server.onLineSockets.remove(socket); // 把下线的客户端socket从在线集合中移除
            updateClientOnLineUserList(); // 下线了用户也需要更新全部客户端的在线人数列表。
        }
    }
​
    // 给全部在线socket推送当前客户端发来的消息
    private void sendMsgToAll(String msg) {
        // 一定要拼装好这个消息，再发给全部在线socket.
        StringBuilder sb = new StringBuilder();
        String name = Server.onLineSockets.get(socket);
​
        // 获取当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss EEE a");
        String nowStr = dtf.format(now);
​
        String msgResult = sb.append(name).append(" ").append(nowStr).append("\r\n")
                .append(msg).append("\r\n").toString();
        // 推送给全部客户端socket
        for (Socket socket : Server.onLineSockets.keySet()) {
            try {
                // 3、把集合中的所有用户名称，通过socket管道发送给客户端
                DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                dos.writeInt(2); // 1代表告诉客户端接下来是在线人数列表信息  2 代表发的是群聊消息
                dos.writeUTF(msgResult);
                dos.flush(); // 刷新数据！
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
​
    private void updateClientOnLineUserList() {
        // 更新全部客户端的在线人数列表
        // 拿到全部在线客户端的用户名称，把这些名称转发给全部在线socket管道。
        // 1、拿到当前全部在线用户昵称
        Collection<String> onLineUsers = Server.onLineSockets.values();
        // 2、把这个集合中的所有用户都推送给全部客户端socket管道。
        for (Socket socket : Server.onLineSockets.keySet()) {
            try {
                // 3、把集合中的所有用户名称，通过socket管道发送给客户端
                DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                dos.writeInt(1); // 1代表告诉客户端接下来是在线人数列表信息  2 代表发的是群聊消息
                dos.writeInt(onLineUsers.size()); // 告诉客户端，接下来要发多少个用户名称
                for (String onLineUser : onLineUsers) {
                    dos.writeUTF(onLineUser);
                }
                dos.flush();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 6、完善整个客户端程序的代码

**第一步：从登录界面开始： 完成了登录，完成了socket管道传给消息聊天界面。**

给这个进入按钮绑定一个点击事件监听器，让他可以点击，一旦点击了，获取到昵称，然后立即请求与服务器端的socket管道链接。

并立即发送登录信息：发送1，发送昵称。

再展示客户端的聊天界面： 接收到了昵称，接收到了属于自己客户端的socket通信管道。

**第二步：立即在消息聊天界面，立即读取客户端socket管道从服务端发来的在线人数更新消息/群聊消息**

- 交给一个独立的线程专门负责读取客户端socket从服务端收到的在线人数更新数据和群聊数据。
- 收到消息，先判断消息的类型，判断是在线人数更新消息还是群聊消息，分开处理。

**第三步：接收群聊消息。**

- 接收消息类型 2 ，接收群聊数据，展示到界面的面板上去即可。

**第四步：发送群聊消息。**

- 给发送按钮绑定一个点击事件，获取输入框的消息内容，再先发送2，再把群聊内容发送给服务端就完事了。
