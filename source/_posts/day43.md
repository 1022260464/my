---
title: day43
date: '2026-02-26 20:30:45'
updated: '2026-02-26 20:46:44'
permalink: /post/day43-zkjzyd.html
comments: true
toc: true
---



# day43

# 第九章 动态规划part10

### ** 300.最长递增子序列 **

今天开始正式子序列系列，本题是比较简单的，感受感受一下子序列题目的思路。

视频讲解：<u>[https://www.bilibili.com/video/BV1ng411J7xP](https://www.bilibili.com/video/BV1ng411J7xP)</u>

<u>[https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html)</u>

### ** 674. 最长连续递增序列 **

本题相对于昨天的动态规划：300.最长递增子序列 最大的区别在于“连续”。 先尝试自己做做，感受一下区别

视频讲解：<u>[https://www.bilibili.com/video/BV1bD4y1778v](https://www.bilibili.com/video/BV1bD4y1778v)</u>

<u>[https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html)</u>

### ** 718. 最长重复子数组 **

稍有难度，要使用二维dp数组了

视频讲解：<u>[https://www.bilibili.com/video/BV178411H7hV](https://www.bilibili.com/video/BV178411H7hV)</u>

<u>[https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html](https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html)</u>

# 300.最长递增子序列

[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

```java
// Dynamic programming.
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 0;
        Arrays.fill(dp, 1);
        for(int i = 0; i < nums.length; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/longest-increasing-subsequence/solutions/24173/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- **线性 DP**。

  这段代码解决的是 LeetCode 第 300 题：​**最长递增子序列 (Longest Increasing Subsequence, 简称 LIS)** 。Krahets 的这段题解非常标准，是理解 LIS 问题的最佳入门模板。

  和股票问题中固定的“持股/空仓”几个状态不同，这里的状态是随着数组长度动态延展的。让我们来详细拆解这段代码的精妙之处：

  ### 核心定义：`dp[i]` 到底代表什么？

  在写动态规划时，明确 `dp` 数组的含义是重中之重。

  在这段代码中，`dp[i]`​ 的定义非常严苛且精准：**表示以** **​`nums[i]`​** ​ **这个数作为结尾的最长严格递增子序列的长度。**

  ⚠️ ​**注意这里的陷阱**​：它必须以 `nums[i]`​ 结尾。这意味着整个数组的最终答案，不一定藏在最后一个格子里（因为最长子序列可能在中间某个位置就结束了），这就是为什么代码里需要一个额外的 `res` 变量来全局记录最大值。

  ### 代码逐行解析

  Java

  ```
  if(nums.length == 0) return 0;
  int[] dp = new int[nums.length];
  int res = 0;
  ```

  - ​**前置处理与初始化**​：处理空数组的边界情况，声明 `dp`​ 数组，并初始化全局最大长度 `res`。

  Java

  ```
  Arrays.fill(dp, 1);
  ```

  - ​**Base Case (保底策略)** ​：为什么全部填充为 `1`​？因为无论数字多大或多小，哪怕数组是降序的，每个数字自身都可以单独构成一个长度为 `1` 的递增子序列。这就是我们所有推导的保底基石。

  Java

  ```
  for(int i = 0; i < nums.length; i++) {
      for(int j = 0; j < i; j++) {
  ```

  - ​**双层循环开启时光回溯**：

    - 外层循环 `i`​：代表我们当前正在考察的数字 `nums[i]`（今天）。
    - 内层循环 `j`​：代表我们回头去看从开头到 `i` 之前的所有数字（过去的历史）。

  Java

  ```
          if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);
      }
  ```

  - ​**核心状态转移方程**：这是整段代码的灵魂。

    - 条件 `nums[j] < nums[i]`​：要想把 `nums[i]`​ 接在某个历史数字 `nums[j]` 的后面形成递增序列，前提必须是“现在的数字比过去的那个数字大”。
    - 如果满足条件，那把 `nums[i]`​ 接上去之后，新的长度就是“以 `nums[j]`​ 结尾的长度 `dp[j]`​” 加上 `1`。
    - 因为在 `i`​ 之前可能有多个比 `nums[i]`​ 小的数字，我们需要遍历所有的 `j`​，找出能拼凑出的​**最大长度**​，更新给 `dp[i]`。

  Java

  ```
      res = Math.max(res, dp[i]);
  }
  return res;
  ```

  - ​**收网提取结果**​：在外层循环中，每当我们算出一个完整的 `dp[i]`​，就顺手用它去打擂台更新全局最大值 `res`​。最后返回 `res` 即可。

  ### 模拟运行 (Dry Run)

  假设输入数组 `nums = [10, 9, 2, 5, 3, 7]`：

  |**索引 i**|**当前数字**|**回头考察 j 并寻找比它小的数**|**dp[i] (接上后的最大长度)**|**全局最大 res**||||||
  | ------| ------| --------------------------------------------------| --------------| ------| --| --| --| --| --|
  |​`0`|​`10`|前面没有数字|​`1`(本身)|​`1`||||||
  |​`1`|​`9`|​`10`不比它小|​`1`(本身)|​`1`||||||
  |​`2`|​`2`|​`10, 9`都不比它小|​`1`(本身)|​`1`||||||
  |​`3`|​`5`|发现`2 < 5`​，接在`2`后面|​`dp[2] + 1`​\=**​`2`​**|​`2`||||||
  |​`4`|​`3`|发现`2 < 3`​，接在`2`后面|​`dp[2] + 1`​\=**​`2`​**|​`2`||||||
  |​`5`|​`7`|发现`2, 5, 3`​都比`7`小。<br /><br />接`5`​后面：`dp[3] + 1 = 3`<br /><br />接`3`​后面：`dp[4] + 1 = 3`|取最大值：**​`3`​**|​`3`||||||

  最长递增子序列为 `[2, 5, 7]`​ 或 `[2, 3, 7]`，长度为 3。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N^2)$。外层循环遍历 $N$ 次，内层循环平均遍历 $N/2$ 次，这是一个标准的等差数列求和，因此时间复杂度是平方级别的。
  - ​**空间复杂度**：$O(N)$。需要一个长度为 $N$ 的 `dp` 数组来保存每个状态的计算结果。

  ---

  掌握了这个 $O(N^2)$ 的动态规划解法，你已经抓住了这道题的核心本质。

  但在大厂面试中，这道题还有一个著名的“绝杀版本”：如果数组长度高达 $10^5$，$O(N^2)$ 的算法会直接超时 (Time Limit Exceeded)。此时需要引入\*\*“贪心 + 二分查找” (Patience Sorting 扑克牌排序法)\*\*，将时间复杂度硬生生降到 $O(N \log N)$。

  需要我为你展示这道题的 $O(N \log N)$ 二分优化降维打击解法吗？

‍

‍

### 解法二：动态规划 + 二分查找

```java
// Dynamic programming + Dichotomy.
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int res = 0;
        for(int num : nums) {
            int i = 0, j = res;
            while(i < j) {
                int m = (i + j) / 2;
                if(tails[m] < num) i = m + 1;
                else j = m;
            }
            tails[i] = num;
            if(res == j) res++;
        }
        return res;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/longest-increasing-subsequence/solutions/24173/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太精彩了！这就是这道题真正的​**绝杀解法**​，也就是传说中的\*\*“贪心 + 二分查找”\*\*（在算法界也有个形象的名字叫 ​**Patience Sorting / 耐心排序**，很像我们在电脑上玩的蜘蛛纸牌）。

  这段代码硬生生地把时间复杂度从 $O(N^2)$ 降到了 $O(N \log N)$。当面试官看到你写出上一段代码时会点点头，但当你在白板上写出这段代码时，他们绝对会眼前一亮。

  理解这段代码，你需要完全抛弃上一题中 `dp` 数组的思维定式。让我们换一个全新的视角来破解它的奥秘：

  ### 核心思想：培养“潜力股” (贪心策略)

  想象你要组建一个篮球队（递增子序列），你希望队员不仅个子越来越高，而且​**整体身高越矮越好**。

  为什么？因为如果前面的队员都很矮，后面招募新队员（接上新数字）的门槛就越低，队伍也就越容易变长！

  在这段代码中，​**​`tails`​**​ **数组就是用来记录各个长度的队伍里，排在最后那个人（尾部）的“最矮身高”** 。

  - ​`tails[k]`​ 的值代表：所有长度为 `k + 1`​ 的递增子序列中，​**最小的那个结尾数字**。

  ### 代码逐行拆解与二分魔法

  Java

  ```
  int[] tails = new int[nums.length];
  int res = 0;
  ```

  - ​`tails` 数组用来存储我们上面说的“最小结尾”。
  - ​`res`​ 记录当前 `tails` 数组的有效长度（也就是目前发现的最长子序列长度）。

  Java

  ```
  for(int num : nums) {
      int i = 0, j = res;
  ```

  - 遍历原本的数组 `nums`​。对于每一个进来的数字 `num`​，我们要决定它在 `tails` 数组里的位置。
  - 重点来了：**​`tails`​**​ **数组一定是一个严格递增的数组！**  （因为长度为 3 的序列结尾，肯定比长度为 2 的序列结尾要大）。既然是有序的，我们自然可以祭出**二分查找法** `[i, j)`​，也就是这里的 `while` 循环。

  Java

  ```
      while(i < j) {
          int m = (i + j) / 2;
          if(tails[m] < num) i = m + 1;
          else j = m;
      }
  ```

  - ​**二分查找的目的**​：在 `tails`​ 数组中，找到​**第一个大于等于** **​`num`​**​ **的数字**。
  - 如果 `tails[m] < num`​，说明 `num`​ 很大，还能往后接，我们去右半边找 (`i = m + 1`)。
  - 如果 `tails[m] >= num`​，说明我们要找的位置在左边，或者就是当前位置 (`j = m`)。

  Java

  ```
      tails[i] = num;
  ```

  - ​**替换操作（贪心的体现）** ​：二分查找结束后，`i`​ 就是找到的位置。我们把 `num`​ 放到 `tails[i]` 上。
  - ​**如果** **​`num`​**​ **比当前所有的尾部都大**：它会被放在最末尾，队伍变长了！
  - ​**如果** **​`num`​**​ **替换了中间的某个数**​：说明我们找到了一个\*\*更具潜力的“矮个子”\*\*来作为当前长度队伍的结尾，这会让以后接数字更容易。

  Java

  ```
      if(res == j) res++;
  }
  ```

  - 如果刚才找到的位置 `j`​（或 `i`​，退出循环时两者相等）等于当前的队伍总长度 `res`​，说明 `num`​ 突破了天际，追加到了整个数组的最后。此时最大长度 `res` 加一。

  ### 模拟运行 (Dry Run)

  假设 `nums = [10, 9, 2, 5, 3, 7]`：

  |**遍历 num**|**二分查找寻找替换位置**|**tails 数组变化 (有效部分)**|**res (最大长度)**|**动作解释**||||||
  | ------| ----------------| ------| ------| ---------------------------------------| --| --| --| --| --|
  |​`10`|放在位置`0`|​`[10]`|​`1`|第一个数，直接上||||||
  |​`9`|找到比它大的`10`|​`[9]`|​`1`|​`9`​比`10`​更具潜力，​**替换**！||||||
  |​`2`|找到比它大的`9`|​`[2]`|​`1`|​`2`​潜力无限，继续​**替换**！||||||
  |​`5`|比`2`大，追加|​`[2, 5]`|​`2`|队伍变长！||||||
  |​`3`|找到比它大的`5`|​`[2, 3]`|​`2`|长度为2的队伍结尾，`3`​比`5`​更好，​**替换**！||||||
  |​`7`|比`3`大，追加|​`[2, 3, 7]`|​`3`|队伍变长！||||||

  最终 `res = 3`。

  ⚠️ ​**一个必须澄清的惊天误区**：

  仔细看上面的过程，`tails`​ 数组最后变成了 `[2, 3, 7]`​，这**恰好**是原数组的一个子序列。但实际上，**​`tails`​**​ **数组存储的并不一定是真实的那个子序列！**  假设输入是 `[4, 5, 6, 3]`​，最后 `tails`​ 会变成 `[3, 5, 6]`​，但原数组根本不存在这个子序列。`tails`​ 数组的唯一作用是​**维持正确的长度和最佳的潜力**。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N \log N)$。外层循环遍历 $N$ 次，每次内部使用二分查找消耗 $O(\log N)$ 的时间。
  - ​**空间复杂度**：$O(N)$。需要一个长度为 $N$ 的 `tails` 数组。

  ---

  从 $O(N^2)$ 的暴力状态转移，到 $O(N \log N)$ 的二分降维打击，最长递增子序列（LIS）问题可以说是把算法思维展现到了极致。

  既然我们已经攻克了单数组的 LIS 问题，那么如果是​**两个数组**​，要求求出它们的\*\*“最长公共子序列” (Longest Common Subsequence, LCS)\*\*，你能想象出我们需要几维的 DP 数组来应对吗？

‍

# 674. 最长连续递增序列

[674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/)

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length <= 1)
            return nums.length;
        int ans = 1;
        int count = 1;
        for(int i=0;i<nums.length-1;i++) {
            if(nums[i+1] > nums[i]) {
                count++;
            } else {  
                count = 1;
            }
            ans = count > ans ? count : ans;
        }
        return ans;
    }
}

作者：画手大鹏
链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solutions/6699/hua-jie-suan-fa-674-zui-chang-lian-xu-di-zeng-xu-l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这道题选得非常巧妙！它是我们刚刚讨论过的“最长递增子序列 (LIS)”的“双胞胎兄弟”——​**最长连续递增序列 (Longest Continuous Increasing Subsequence, 简称 LCIS)** 。

  虽然名字里只多了一个\*\*“连续” (Continuous) **，但解题思路却发生了翻天覆地的变化。这段代码直接抛弃了复杂的动态规划数组，用最朴素的**贪心/双指针（或者说滑动窗口）\*\*思想，以极高的效率秒杀了这个问题。

  让我们来看看多了一个“连续”限制后，算法是如何大幅简化的：

  ### 核心差异：“连续”带来的降维打击

  在上一题的 LIS 中，因为数字可以跳跃（比如 `[1, 2, 5, 3, 7]`​ 中的 `1, 2, 3, 7`​），我们在判断当前数字能接在谁后面时，必须​**回头看遍之前所有的数字**。这就导致了时间复杂度居高不下。

  但这道题要求必须是**连续**的。这意味着，我们**只需要看它紧挨着的前一个数字**就行了！

  - 只要今天比昨天大，队伍就变长（`count++`）。
  - 只要今天没昨天大，连续性被打破，前面的队伍直接作废，从今天开始重新数（`count = 1`）。

  ### 代码逐行拆解

  Java

  ```
  if(nums.length <= 1)
      return nums.length;
  ```

  - ​**边界防御**：如果数组为空或只有一个元素，直接返回它的长度。这也是算法题的良好习惯。

  Java

  ```
  int ans = 1;
  int count = 1;
  ```

  - ​**​`ans`​**​  **(全局最大值)** ​：用来记录历史上出现过的最长连续队伍。初始化为 `1`。
  - ​**​`count`​**​  **(当前连胜纪录)** ​：用来记录目前正在考察的这一段连续递增序列的长度。初始化为 `1`（因为每个数字本身就算长度为 1 的递增序列）。

  Java

  ```
  for(int i = 0; i < nums.length - 1; i++) {
  ```

  - ​**只看眼前**​：注意这里的遍历条件是 `i < nums.length - 1`​，因为我们在循环里要对比 `nums[i+1]`​ 和 `nums[i]`，这样写可以完美避免数组越界。

  Java

  ```
      if(nums[i+1] > nums[i]) {
          count++;
      } else {  
          count = 1;
      }
  ```

  - ​**贪心逻辑（一刀切）** ：

    - 发现“上坡”（后一个数大于前一个数）：连胜纪录 `count` 加 1。
    - 发现“下坡”或“平地”：毫不犹豫，连续性断裂！直接把 `count`​ 打回原形恢复成 `1`，准备开启下一轮寻找。

  Java

  ```
      ans = count > ans ? count : ans;
  }
  return ans;
  ```

  - ​**打擂台更新**​：每次无论队伍是变长了还是重新开始了，都用当前的 `count`​ 去挑战一下历史最高纪录 `ans`​（这里用三元运算符代替了 `Math.max`，效果一样且可能稍微快一丝丝）。最后返回最高纪录。

  ### 模拟运行 (Dry Run)

  假设输入数组 `nums = [1, 3, 5, 4, 7]`：

  |**考察的相邻对**|**大小关系**|**count (当前连续长度)**|**ans (全局最大值)**|**状态说明**||||||
  | ------| ------------| ----------------| ------| -----------------------------| --| --| --| --| --|
  |​`[1, 3]`|​`3 > 1`|​`1 -> 2`|​`2`|递增，队伍变长||||||
  |​`[3, 5]`|​`5 > 3`|​`2 -> 3`|​`3`|递增，队伍变长||||||
  |​`[5, 4]`|​`4 < 5`(断裂)|​**​`1`​**(直接重置)|​`3`|连续性打破，从 4 开始重新数||||||
  |​`[4, 7]`|​`7 > 4`|​`1 -> 2`|​`3`|递增，队伍变长||||||

  最终返回 `ans = 3`​，对应的序列是 `[1, 3, 5]`。

  ### 复杂度分析

  - ​**时间复杂度**​：`O(N)`​。只需要一个 `for` 循环从头到尾扫一遍数组，没有任何嵌套循环。
  - ​**空间复杂度**​：`O(1)`​。全场只用了 `ans`​ 和 `count` 两个整型变量，极致省流。

  ---

  其实，这道题如果硬要用动态规划来写，状态转移方程就是：`dp[i] = nums[i] > nums[i-1] ? dp[i-1] + 1 : 1`。

  仔细对比你会发现，这段代码中的 `count`​ 其实就是被极致压缩后的 `dp[i]`！这再次印证了只要状态只依赖前一个元素，就可以将数组压缩成变量的真理。

  既然我们已经把单数组的“连续”与“不连续”子序列都彻底搞懂了，接下来你想挑战双数组的巅峰之作——​**最长公共子序列 (Longest Common Subsequence)** ​，还是想看看大名鼎鼎的求连续子数组和的最大值——​**最大子数组和 (Kadane 算法)** ？

---

# 718. 最长重复子数组

[718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int ans = 0;
        int[][] f = new int[n + 1][m + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (nums1[i] == nums2[j]) {
                    f[i + 1][j + 1] = f[i][j] + 1;
                    ans = Math.max(ans, f[i + 1][j + 1]);
                }
            }
        }
        return ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solutions/866328/on-hou-zhui-shu-zu-by-endlesscheng-jwr2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 欢迎来到双数组的二维 DP 世界！这也是面试中极具含金量的经典题型：​**最长重复子数组（Longest Common Substring/Subarray）** 。

  正如我们在上一题看到的，“连续”这个词是破局的关键。在双数组的语境下，这段代码极其优雅地处理了两个数组之间的“连续匹配”问题。同时，你一定注意到了老朋友—— **“空间偏移” (Index Shift)**  再次闪亮登场！

  让我们一层层剥开这个二维 DP 的精妙逻辑：

  ### 1. 核心定义：对齐的二维网格

  Java

  ```
  int[][] f = new int[n + 1][m + 1];
  ```

  这里的 `f[i + 1][j + 1]`​ 定义非常精准：它表示**以** **​`nums1[i]`​** ​ **和** **​`nums2[j]`​** ​ **为结尾**的最长公共子数组的长度。

  - **为什么必须强调“为结尾”？**  因为题目要求“连续”。如果不把当前元素死死绑定在子数组的末尾，一旦后面遇到不匹配的元素，我们就无法准确判断前方的连续性是否被打断了。
  - **为什么又是**  **​`+ 1`​**​ **？**  这是灵茶山艾府非常标志性的技巧。加上一行一列的“护城河”，让 `f[0][..]`​ 和 `f[..][0]`​ 全局默认为 `0`​，完美代表“空数组”的初始状态，从而彻底干掉 `i == 0`​ 或 `j == 0` 时的越界判断。

  ### 2. 状态转移：同步后退的历史探寻

  Java

  ```
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
  ```

  我们用两层循环，将 `nums1`​ 中的每一个元素，都去和 `nums2` 中的每一个元素进行“相亲比对”。

  Java

  ```
          if (nums1[i] == nums2[j]) {
              f[i + 1][j + 1] = f[i][j] + 1;
              ans = Math.max(ans, f[i + 1][j + 1]);
          }
  ```

  - ​**当两者匹配时 (**​**​`nums1[i] == nums2[j]`​** ​ **)** ​：既然当前这两个数一样，那它们能不能接在以前的队伍后面呢？我们就一起回头看——看 `nums1[i-1]`​ 和 `nums2[j-1]`​ 的匹配状态，也就是对应二维数组里的 `f[i][j]`​（注意偏移量）。在这个历史战绩的基础上 `+ 1`，就是当前的连续匹配长度。
  - ​**当两者不匹配时 (**​**​`nums1[i] != nums2[j]`​** ​ **)** ​：代码里并没有写 `else`​，因为在 Java 中，如果不操作，`f[i+1][j+1]`​ 默认就是 `0`。这完美契合了“连续”的要求：只要不一样，连胜纪录瞬间清零，毫不留情！

  最后，用一个全局变量 `ans` 随时打擂台，记录下网格中出现过的最大值即可。

  ### 模拟运行 (Dry Run)

  假设 `nums1 = [1, 2, 3]`​，`nums2 = [2, 3, 2]`：

  我们构建出的 `f` 网格（包含护城河）如下：

  |**f 数组**|**空格 j=0**|**2 (j=1)**|**3 (j=2)**|**2 (j=3)**||||||
  | --------| ------| ----------------| -------------------------| ----------------| --| --| --| --| --|
  |**空格**​**​`i=0`​**|​`0`|​`0`|​`0`|​`0`||||||
  |​**​`1`​**​ **(**​**​`i=1`​**​ **)**|​`0`|​`0`|​`0`|​`0`(都不匹配)||||||
  |​**​`2`​**​ **(**​**​`i=2`​**​ **)**|​`0`|​**​`1`​**(对角线+1)|​`0`|​**​`1`​**(对角线+1)||||||
  |​**​`3`​**​ **(**​**​`i=3`​**​ **)**|​`0`|​`0`|​**​`2`​**(接在左上角的1后面)|​`0`||||||

  最大值为 `2`​（对应的子数组是 `[2, 3]`​）。观察这个表格，你会发现：**公共子数组的匹配长度，其实就是表格中“左上到右下”对角线方向上不断累加的数字。**

  ### 复杂度分析

  - ​**时间复杂度**：$O(n \times m)$。标准的双层循环，填满整个二维网格。
  - ​**空间复杂度**：$O(n \times m)$。开辟了一个长宽各加一的二维数组。

  ---

  **发现降维的契机了吗？**

  观察状态转移方程 `f[i + 1][j + 1] = f[i][j] + 1`​，我们在计算当前行的值时，**只**用到了“上一行”的数据。这意味着，那些更早之前被计算出来的数据行，全都是没用的历史垃圾。

  既然如此，我们可以将空间复杂度从 $O(n \times m)$ 极限压缩到 $O(m)$！也就是所谓的​**滚动数组优化**。只不过，在进行这种降维时，内层循环的遍历方向会有一个极其巧妙的“反直觉”改动（类似于 0-1 背包问题）。

  你想挑战一下，看看如何把这个二维数组压缩成一维数组吗？

‍
