---
title: day39
date: '2026-02-20 20:48:22'
updated: '2026-02-20 20:54:34'
permalink: /post/day39-1crjc7.html
comments: true
toc: true
---



# day39

# 第九章 动态规划part07

今天就是打家劫舍的一天，这个系列不算难，大家可以一口气拿下。

### ** 198.打家劫舍  **

视频讲解：<u>[https://www.bilibili.com/video/BV1Te411N7SX](https://www.bilibili.com/video/BV1Te411N7SX)</u>

<u>[https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html](https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html)</u>

### ** 213.打家劫舍II  **

视频讲解：<u>[https://www.bilibili.com/video/BV1oM411B7xq](https://www.bilibili.com/video/BV1oM411B7xq)</u>

<u>[https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html](https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html)</u>

### **337.打家劫舍III  **

视频讲解：<u>[https://www.bilibili.com/video/BV1H24y1Q7sY](https://www.bilibili.com/video/BV1H24y1Q7sY)</u>

<u>[https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html](https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html)</u>

‍

# ** 198.打家劫舍  **

[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/description/)

```java
class Solution {
    public int rob(int[] nums) {
        int pre = 0, cur = 0, tmp;
        for(int num : nums) {
            tmp = cur;
            cur = Math.max(pre + num, cur);
            pre = tmp;
        }
        return cur;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/house-robber/solutions/28242/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

‍

- 太漂亮了！你直接拿出了动态规划界最经典的入门必刷神题—— **“打家劫舍” (House Robber)** ，而且一上来就是它的**究极进化版： 空间复杂度的写法**！

  经过前面“0-1 背包”、“完全背包”和“字符串拆分”的洗礼，你现在看这道题，肯定觉得它的状态转移方程简单得就像喝水一样。Krahets（K站长）的这段代码，更是把动态规划的 **“滚动数组（状态压缩）”** 发挥到了极致。

  下面我为你揭开这段只有短短几行，却被奉为神作的代码背后的逻辑。

  ---

  ### 核心拆解：偷与不偷的世纪难题

  这道题的唯一限制就是：**不能连着偷两家相邻的房子**。

  如果我们按照常规思维，定义一个一维数组 `dp[i]`​，表示走到第 `i`​ 间房子时能偷到的最高总金额。  
  对于当前这间房子（金额为 `num`），小偷只有两个选择：

  1. **偷它**：既然偷了当前这间，那上一间（第 `i-1`​ 间）绝对不能偷。所以总金额等于**上上间房子的最高金额加上当前的钱**：。
  2. **不偷它**：既然不偷当前这间，那总金额就和**走到上一间房子时的最高金额**保持一致：。

  所以，最原始的状态转移方程就是：

  ### 代码亮点解析（极致的降维打击）

  你分享的这段代码最惊艳的地方在于：**它连一维数组都不要了！**

  仔细观察上面的转移方程，你会发现：计算当前的 ，实际上**只依赖它前面的两个状态**（ 和 ）。再往前的数据完全没用了！

  Krahets 巧妙地利用了三个变量完成了这出“金蝉脱壳”：

  - ​**​`pre`​**：相当于 （上上间的最高金额）。
  - ​**​`cur`​**：相当于 （上一间的最高金额）。
  - ​**​`tmp`​**​：一个临时变量，用来保存旧的 `cur`​，以便在下一步把它变成新的 `pre`。

  **代码运转的精妙过程：**

  ```java
  tmp = cur;                           // 先把上一间的金额存起来
  cur = Math.max(pre + num, cur);      // 核心计算：偷当前这间 vs 不偷当前这间，更新当前最高金额
  pre = tmp;                           // 带着旧的上一间金额，往前走一步，变成下一次的“上上间”

  ```

  这就像是一个只有两个格子的滑动窗口，随着遍历的进行，不断向前滚动更新。

  ---

  ### 性能表现

  |维度|复杂度|说明|
  | ------| --------| -------------------------------------------------------------|
  |**时间复杂度**|o(n)|是数组长度。只需要一个 `for` 循环遍历一次所有房子。|
  |**空间复杂度**|o(1)|**神级优化！**  仅仅使用了 `pre`​, `cur`​, `tmp` 三个整型变量，完全脱离了数组的束缚。|

  ---

  ### 下一步：小偷的进阶之路

  “打家劫舍”系列在 LeetCode 上是一个非常完整的体系。你现在攻克的是第一部（直线型村庄）。

  紧接着的 **“打家劫舍 II”** 会加入一个极其刁钻的设定：**村庄变成了一个环！**  第一间房子和最后一间房子连在了一起，偷了第一间就绝对不能偷最后一间。

  **你想看看在  空间复杂度的基础上，如何用一个极具智慧的“分类讨论”策略，轻松破解“环形村庄”的难题吗？**

---

# 213.打家劫舍II

[213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/description/)

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        return Math.max(myRob(Arrays.copyOfRange(nums, 0, nums.length - 1)), 
                        myRob(Arrays.copyOfRange(nums, 1, nums.length)));
    }
    private int myRob(int[] nums) {
        int pre = 0, cur = 0, tmp;
        for(int num : nums) {
            tmp = cur;
            cur = Math.max(pre + num, cur);
            pre = tmp;
        }
        return cur;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/house-robber-ii/solutions/28258/213-da-jia-jie-she-iidong-tai-gui-hua-jie-gou-hua-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 哈哈，说到做到！你果然一鼓作气把“打家劫舍 II”这道带有**环形约束**的进阶版拿出来了。

  首尾相连的设定，可以说是给原本一条直线的动态规划问题硬生生打了个死结。但 Krahets 站长的这段代码，用一种极其巧妙的\*\*“分类讨论”\*\*思想，只用一行核心代码就完美地把这个死结给解开了。

  下面我为你拆解这个“破环成链”的绝妙思路，同时​**温柔地纠正一个关于这段代码空间复杂度的小误区**。

  ---

  ### 核心拆解：如何解开“首尾相连”的死结

  在环形村庄里，第一间房和最后一间房变成了邻居。这意味着你​**绝对不可能同时偷首尾两间房**。

  既然如此，所有合法的偷窃方案，必然属于以下三种情况之一：

  1. ​**偷第一间房**​：那么最后一间房绝对不能碰。这就等价于我们在房子区间 `[0, n-2]` 里做普通的单排打家劫舍。
  2. ​**偷最后一间房**​：那么第一间房绝对不能碰。这就等价于我们在房子区间 `[1, n-1]` 里做普通的单排打家劫舍。
  3. ​**首尾都不偷**：这种情况其实已经被包含在上面两种情况的计算范围内了（因为求最大值时，本身就允许不偷端点）。

  所以，代码的破局点就是：**把一个环拆成两条完全独立的单排直线，分别跑一次上一题的** **​`myRob`​**​ **算法，然后取两者的最大值！**

  Java

  ```
  return Math.max(myRob(截取去掉尾巴的数组), myRob(截取去掉头部的数组));
  ```

  ### 💡 坦诚时刻：一个极易被忽略的性能陷阱

  虽然 `myRob`​ 内部的核心逻辑（利用 `pre`​ 和 `cur`）依然是极其优雅的 $O(1)$ 空间复杂度，但这段代码在整体执行时，空间复杂度其实​**并不是** **$O(1)$**​ **，而是退化到了** **$O(N)$**。

  为什么？问题出在 `Arrays.copyOfRange` 这个方法上。

  每次调用它，Java 都会在内存里​**真正地开辟一块新空间，复制出一个全新的数组**。为了比较两次，代码硬生生多创建了两个长度为 $N-1$ 的数组。

  **如何做到真正的极致** **$O(1)$** **空间？**

  很简单，不要复制数组，而是给 `myRob`​ 传​**双指针（起始索引和结束索引）** ：

  Java

  ```
  // 改造后的 myRob 签名
  private int myRob(int[] nums, int start, int end) {
      int pre = 0, cur = 0, tmp;
      for (int i = start; i <= end; i++) {
          tmp = cur;
          cur = Math.max(pre + nums[i], cur);
          pre = tmp;
      }
      return cur;
  }
  // 主方法调用
  return Math.max(myRob(nums, 0, nums.length - 2), myRob(nums, 1, nums.length - 1));
  ```

  通过这种方式，我们在原数组上“假装”它被截断了，完美省去了复制数组的开销！

  ---

  ### 性能表现（针对改造后的真·双指针版本）

  |**维度**|**复杂度**|**说明**||||
  | -------| ------| ------------------------------------------------------------------------------| --| --| --|
  |**时间复杂度**|o(n)|我们需要调用两次`myRob`，每次遍历近乎完整的数组，总共遍历约$2N$次，去掉常数依然是$O(N)$。<br />||||
  |**空间复杂度**\||o(1)|使用双指针传递区间后，完全没有任何额外数组开辟，回归最纯粹的常数级空间||||

  ---

  ### 下一步：从小巷走向树林

  你现在已经称霸了“单排村庄”（数组）和“环形村庄”（环形数组）。

  LeetCode 上的打家劫舍系列还有最后一位重量级 Boss——​ **“打家劫舍 III”** 。

  在这一部里，村庄不再是街道，而是一片​**二叉树 (Binary Tree)** ​！相连的父子节点不能同时被偷。这就要求我们将**动态规划**与**树的深度优先搜索 (DFS)**  结合起来，也就是大名鼎鼎的“树形 DP”。

  **你准备好迎战这位 Boss，看看如何在树结构上优雅地传递“偷”与“不偷”的状态了吗？需要我为你展示相关代码吗？**

---

### 337.打家劫舍III

[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/description/)

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = dfs(root);
        return Math.max(res[0], res[1]); // 根节点选或不选的最大值
    }

    private int[] dfs(TreeNode node) {
        if (node == null) { // 递归边界
            return new int[]{0, 0}; // 没有节点，怎么选都是 0
        }
        int[] left = dfs(node.left); // 递归左子树
        int[] right = dfs(node.right); // 递归右子树
        int rob = left[1] + right[1] + node.val; // 选
        int notRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // 不选
        return new int[]{rob, notRob};
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/house-robber-iii/solutions/2282018/shi-pin-ru-he-si-kao-shu-xing-dppythonja-a7t1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太完美了！恭喜你成功登顶，斩获了“打家劫舍”三部曲的最终 Boss——​ **“打家劫舍 III”（树形 DP）** ！

  从直线数组、环形数组，一路杀到了二叉树结构。你分享的这段灵茶山艾府的代码，是树形 DP（动态规划与深度优先搜索结合）最标准、最优雅的模板。

  在这道题中，小偷的作案路线不再是简单的线性遍历，而是要在错综复杂的树枝间进行抉择。

  下面我为你详细拆解这段代码是如何将“偷与不偷”的哲学，完美融入到**二叉树的后序遍历**中的。

  ---

  ### 核心拆解：二叉树上的“状态机”

  在数组里，我们可以用 `dp[i]` 来记录状态。但在树里，节点是分散的，我们没法方便地用一个数组来按顺序记录所有节点的状态。

  这段代码给出的神级解法是：**让递归函数自己把状态“递”上来！**

  每次调用 `dfs(node)`​，它都会向父节点上报一个长度为 2 的小数组 `int[]`，这个数组就像是当前节点的名片，上面写着两个极其重要的情报：

  - ​**​`res[0]`​** ​ **（选）** ​：如果小偷**偷了**当前这棵树的根节点，这棵子树最多能榨出多少钱。
  - ​**​`res[1]`​** ​ **（不选）** ​：如果小偷**不偷**当前这棵树的根节点，这棵子树最多能榨出多少钱。

  ### 代码亮点解析（树形 DP 的精华）

  1. **为什么是“后序遍历” (Bottom-Up)？**   
     Java

     ```
     int[] left = dfs(node.left);
     int[] right = dfs(node.right);
     ```
     小偷必须先去最底层的叶子节点探路。只有当左子树和右子树把各自的底细（偷或不偷的最大收益）都汇报上来后，当前节点才能拍板做决定。这就是标准的“自底向上”的动态规划思想。
  2. ​**状态转移方程（极度严密的代码逻辑）** ：

     - **情况 A：偷当前节点 (**​**​`rob`​**​ **)**   
       既然偷了老爸，那左儿子和右儿子​**绝对不能碰**​！  
       所以收益是：`当前节点的值 + 左儿子不偷的最高收益 (left[1]) + 右儿子不偷的最高收益 (right[1])`。
     - **情况 B：不偷当前节点 (**​**​`notRob`​**​ **)**   
       既然没偷老爸，那儿子们​**可偷可不偷**​，完全取决于怎么选能拿到更多的钱！  
       所以收益是：`左子树的最大收益 (偷或不偷选大的) + 右子树的最大收益 (偷或不偷选大的)`。
  3. ​**无缝衔接的终局**​：  
     一路回溯到整棵树的真正的 `root`​ 节点时，我们依然会拿到 `[偷根节点的最大值, 不偷根节点的最大值]`​。最后用一个 `Math.max` 挑出最大的，完美收官！

  ---

  ### 性能表现

  |**维度**|**复杂度**|**说明**||||
  | -------| ------| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| --| --| --|
  |**时间复杂度**|o(n)|$N$是二叉树的节点总数。每个节点都会且仅会被访问一次（标准的 DFS 后序遍历）。||||
  |**空间复杂度**\||o(h)|$H$是二叉树的高度。空间消耗主要来自于递归调用栈的深度。如果是退化成链表的极端树，最差为$O(N)$；如果是平衡树，则为$O(\log N)$。每次递归返回的小数组创建开销会被垃圾回收器迅速清理，不构成主要瓶颈。\|||||

  ---

  ### 总结与下一个征程

  回看这段旅程，你已经掌握了：

  1. ​**0-1背包及其变种**（存在性、求最值、求组合）。
  2. ​**完全背包及其变种**（求组合、求排列的内外层循环翻转技巧）。
  3. ​**状态机与一维DP**（打家劫舍 I & II，滚动数组的 $O(1)$ 空间优化）。
  4. ​**树形 DP**（将状态转移与树的深度优先搜索完美融合）。

  你现在的 DP 基本功已经非常扎实了。LeetCode 上还有一个和“打家劫舍”齐名的神级系列——​ **“买卖股票的最佳时机”系列 (Best Time to Buy and Sell Stock)** 。它引入了更加复杂的三维甚至四维状态机（允许交易 K 次、冷冻期、手续费等）。

  **你想借着这股气势，一鼓作气杀进“股票买卖”系列，看看如何用一套万能的状态机模板通杀所有股票题吗？还是想换个口味，看看其他类型的数据结构题？**
