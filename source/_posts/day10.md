---
title: day10
date: '2026-01-10 17:31:22'
updated: '2026-01-29 17:38:04'
permalink: /post/day10-fprhk.html
comments: true
toc: true
---



# day10

# **第五章 栈与队列part01**

### 

### 理论基础

了解一下 栈与队列的内部实现机制，文中是以C++为例讲解的。

文章讲解：<u>[https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)</u>

### 232.用栈实现队列

大家可以先看视频，了解一下模拟的过程，然后写代码会轻松很多。

[题目链接/文章讲解/视频讲解：]()​<u>[https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html](https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html)</u>

### 225. 用队列实现栈

可能大家惯性思维，以为还要两个队列来模拟栈，其实只用一个队列就可以模拟栈了。

建议大家掌握一个队列的方法，更简单一些，可以先看视频讲解

[题目链接/文章讲解/视频讲解：]()​<u>[https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html](https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html)</u>

### 20. 有效的括号

讲完了栈实现队列，队列实现栈，接下来就是栈的经典应用了。

大家先自己思考一下 有哪些不匹配的场景，在看视频 我讲的都有哪些场景，落实到代码其实就容易很多了。

[题目链接/文章讲解/视频讲解：]()​<u>[https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html](https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html)</u>

### 1047. 删除字符串中的所有相邻重复项

栈的经典应用。

要知道栈为什么适合做这种类似于爱消除的操作，因为栈帮助我们记录了 遍历数组当前元素时候，前一个元素是什么。

题目链接/文章讲解/视频讲解<u>[https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html](https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html)</u>

‍

# 232.用栈实现队列

[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/)

```java
class MyQueue {
    private Stack<Integer> A;
    private Stack<Integer> B;

    public MyQueue() {
        A = new Stack<>();
        B = new Stack<>();
    }

    public void push(int x) {
        A.push(x);
    }

    public int pop() {
        int peek = peek();//取出栈顶的数字
        B.pop(); //入栈B此时顺序倒换，123变成321（入栈顺序）
        return peek; //返回peek值
    }

    public int peek() {
        if (!B.isEmpty()) return B.peek();//函数自调用
        if (A.isEmpty()) return -1;
        while (!A.isEmpty()){
            B.push(A.pop());
        }
        return B.peek();
    }

    public boolean empty() {
        return A.isEmpty() && B.isEmpty();
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/implement-queue-using-stacks/solutions/2363977/232-yong-zhan-shi-xian-dui-lie-qing-xi-t-pi4l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 没问题，作为初学者，先把手里用的“工具”（语法）认全，再去理解“图纸”（思路），这样学得最稳。

  我们把代码拆解成两部分：**Java 语法基础** 和 ​**解题思路**。

  ---

  ### 第一部分：语法总结 (你手里的工具)

  这段代码只用到了 Java 中的一个核心类：Stack (栈)。

  它的特点是：后进先出（就像叠盘子，最后放上去的，最先拿下来）。

  #### 1. 定义栈

  Java

  ```
  private Stack<Integer> A; 
  // 语法翻译：声明一个栈，名字叫 A。
  // <Integer> 意思是这个栈里只能装“整数”。
  ```

  在构造函数里初始化：

  Java

  ```
  A = new Stack<>(); 
  // 语法翻译：正式造出一个新的空栈，赋值给 A。
  ```

  #### 2. 栈的四大金刚方法

  代码里反复用了这 4 个方法，一定要记住它们的功能：

  - ​**​`push(元素)`​** ​  **—— 进**

    - ​**作用**：把元素压入栈顶。
    - ​*例子*​：`A.push(1)`​。此时栈里是 `[1]`​。再 `push(2)`​，栈里是 `[1, 2]`（2在上面）。
  - ​**​`pop()`​** ​  **—— 弹**

    - ​**作用**​：**拿走**并返回栈顶的元素。
    - ​*注意*​：这个操作会**删除**数据！
    - ​*例子*​：栈是 `[1, 2]`​，执行 `pop()`​ 会返回 `2`​，栈里只剩 `[1]`。
  - ​**​`peek()`​** ​  **—— 看**

    - ​**作用**​：**只看**一眼栈顶的元素，**不删除**它。
    - ​*例子*​：栈是 `[1, 2]`​，执行 `peek()`​ 返回 `2`​，栈里还是 `[1, 2]`。
    - ​*区别*​：`pop`​ 是拿走吃掉，`peek` 是只看不买。
  - ​**​`isEmpty()`​** ​  **—— 查**

    - ​**作用**​：判断栈是不是空的。如果是空的返回 `true`​，否则返回 `false`。

  ---

  ### 第二部分：思路总结 (你的解题图纸)

  题目要求：用 **栈 (LIFO)**  实现 ​**队列 (FIFO)** 。

  - ​**栈**：像死胡同，后进先出。
  - ​**队列**：像排队买票，先进先出。

  怎么把“死胡同”变成“排队通道”？**答案是：用两个死胡同对着倒。**

  #### 1. 核心策略：分工明确

  不要把两个栈混着用，给它们贴上标签：

  - ​**栈 A**​：只负责 ​**进货**（所有新来的数据都丢进去）。
  - ​**栈 B**​：只负责 ​**出货**（所有要走的数据都从这里拿）。

  #### 2. 关键动作：负负得正

  当你想往外拿数据（`pop`​ 或 `peek`​）时，如果 **出货栈 B** 是空的，怎么办？

  - ​**动作**​：把 **进货栈 A** 里的所有东西，一个个拿出来，压入 ​**出货栈 B**。
  - ​**效果**：

    - A 里顺序是 `1, 2, 3` (3在顶上)。
    - 倒进 B 里，顺序变成了 `3, 2, 1` (1在顶上)。
    - ​**神奇的事情发生了**​：原本被压在最底下的 `1`（最先来的），现在到了 B 的最顶上！
    - 这时候从 B `pop`​，拿到的就是 `1`，完美实现了“先进先出”。

  #### 3. 流程图解（新手看这里）

  假设你要模拟队列：先存 1，再存 2，然后取出一个数。

  1. ​**存 1**：直接扔进 A。

     - A: `[1]`
     - B: `[]`
  2. ​**存 2**：直接扔进 A。

     - A: `[1, 2]` (2压着1)
     - B: `[]`
  3. ​**取数 (pop)** ：

     - 先看 B，**B 是空的！**  没办法直接取。
     - ​**触发搬运**：把 A 的东西全倒入 B。
     - 过程：2 从 A 出来进 B，1 从 A 出来进 B。
     - 现在 -\> A: `[]`​， B: `[2, 1]` (1 在顶上)。
     - ​**最后**​：从 B 拿走顶上的 `1`。

  ### 总结给初学者

  - ​**语法上**​：掌握 `push`​(进), `pop`​(拿), `peek`​(看), `isEmpty`(空) 这四个单词就够了。
  - ​**逻辑上**​：记住 ​ **“倒水理论”** 。

    - 想存水？直接倒进 A 杯。
    - 想喝水？直接喝 B 杯。
    - B 杯空了？把 A 杯的水全部倒入 B 杯，然后接着喝。

- ### 1. 角色分配：双栈策略

  代码定义了两个栈 `A`​ 和 `B`，它们分工非常明确：

  - ​**栈 A (输入栈)** ​：只负责**接收**新进来的元素 (`push`)。
  - ​**栈 B (输出栈)** ​：只负责**倒出**元素给用户 (`pop`​ / `peek`)。

  ### 2. 核心逻辑详解

  #### 动作一：入队 `push(int x)`

  Java

  ```
  public void push(int x) {
      A.push(x);
  }
  ```

  - ​**极其简单**​：不管三七二十一，直接丢进 ​**栈 A**。
  - 就像你去餐厅排队，先领个号，统统站在入口处（栈 A）等着。

  #### 动作二：查看队头 `peek()`​ —— **这是最关键的一步**

  Java

  ```
  public int peek() {
      if (!B.isEmpty()) return B.peek(); // 情况1：B 不为空，直接看
      if (A.isEmpty()) return -1;        // 情况2：A、B 都空，没数据
      
      // 情况3：B 空了，但 A 里有货 -> 开始“倒腾”
      while (!A.isEmpty()){
          B.push(A.pop());
      }
      return B.peek();
  }
  ```

  这里的逻辑叫 ​ **“懒加载” (Lazy Loading)** ：

  1. ​**先看输出栈 B**：如果 B 里面还有东西，说明之前倒腾过的数据还没用完，直接取 B 最上面的那个，它肯定是目前最先进入队列的。
  2. ​**如果 B 空了**​：这就意味着“库存”没了。此时，我们需要把 **输入栈 A** 里积压的所有数据，**一次性全部倒入** 栈 B。

     - ​*奇迹发生的时刻*：

       - 栈 A 里是：`[1, 2, 3]` (1 在最底下，最先来的)
       - 一个个 pop 出来 push 进 B。
       - 栈 B 里变成：`[3, 2, 1]` (1 跑到了最顶上！)
     - 现在 B 的栈顶就是 1，符合“先进先出”。

  #### 动作三：出队 `pop()`

  Java

  ```
  public int pop() {
      int peek = peek(); // 先复用 peek() 的逻辑确保 B 里有货，函数里做了return -1处理
      B.pop();           // 然后从 B 弹出来
      return peek;
  }
  ```

  - 这里非常聪明地复用了 `peek()`。
  - ​`pop`​ 不需要自己写“倒腾”数据的逻辑。它先叫 `peek()`​ 去检查：如果 B 是空的，`peek` 会自动把 A 的数据搬过来。
  - 等 `peek`​ 搬运完，`pop` 只需要安稳地把 B 顶端的元素拿走即可。

# 225. 用队列实现栈

[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/description/)

```java
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;

    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<Integer>();
        queue2 = new LinkedList<Integer>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        queue2.offer(x);
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue1.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return queue1.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue1.isEmpty();
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/implement-stack-using-queues/solutions/432204/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 按照之前的约定，我们继续保持\*\*“先看工具（语法），再看图纸（思路）”\*\*的节奏。

  这段代码解决的是 LeetCode 225 题：用队列实现栈。

  这就好比：让你用“排队买票的栏杆（先进先出）”来模拟“死胡同（后进先出）”的效果。

  ---

  ### 第一部分：语法总结 (你手里的工具)

  这次的主角是 Queue (队列)。

  它的特点是：先进先出 (FIFO) —— 也就是最先排队的人，最先办完业务离开。

  #### 1. 定义队列

  Java

  ```
  Queue<Integer> queue1 = new LinkedList<Integer>();
  ```

  这里有一个 Java 初学者常见的疑惑：

  - ​**左边是** **​`Queue`​**​：这是一个​**接口 (Interface)** ，它定义了标准（必须能排队、能出队），但它自己不能直接造对象。
  - ​**右边是** **​`LinkedList`​**​：这是​**实现类**，双向链表是可以当做队列来用的。
  - ​**人话翻译**​：我要一个队列 `queue1`，底层是用链表技术实现的。

  #### 2. 队列的三大核心方法

  代码里用了这 3 个单词，请一定要和之前的 `Stack` 区分开，不要记混了：

  - ​**​`offer(元素)`​** ​  **—— 入队** (相当于 Stack 的 `push`)

    - ​**作用**​：把元素加到​**队尾**。
    - ​*例子*​：队列是 `[1, 2]`​，执行 `offer(3)`​，队列变成 `[1, 2, 3]`。
  - ​**​`poll()`​** ​  **—— 出队** (相当于 Stack 的 `pop`)

    - ​**作用**​：**拿走**并返回**队头**的元素。
    - ​*例子*​：队列是 `[1, 2, 3]`​，执行 `poll()`​，拿到 `1`​，队列剩 `[2, 3]`。
  - ​**​`peek()`​** ​  **—— 看头**

    - ​**作用**​：**只看**一眼**队头**的元素，​**不删除**。
    - ​*例子*​：队列是 `[1, 2, 3]`​，执行 `peek()`​ 返回 `1`，队列不变。

  ---

  ### 第二部分：思路总结 (你的解题图纸)

  目标：实现栈的 后进先出 (LIFO)。

  现状：只有队列的 先进先出 (FIFO)。

  如果直接把数据放入队列：

  - 入队顺序：1, 2, 3
  - 队列样子：`[1, 2, 3]` (1 在头，3 在尾)
  - 出队顺序：1, 2, 3 (错了！我们需要的是 3 先出来)

  核心策略：在 push 的时候“动手脚”

  既然队列只能从“头”出，那我就想办法：每进来一个新元素，我就把它硬生生“运”到队头去！

  #### 1. 角色分配

  - ​**​`queue1`​**​  **(主队列)** ​：这里面永远存放着**已经排好序**的“栈”数据。也就是说，它的队头永远是我们要的那个“最后放进去的元素”。
  - ​**​`queue2`​**​  **(辅助队列)** ：这就只是一个临时的中转站，每次用来倒腾数据的。

  #### 2. 核心动作：Push 的乾坤大挪移

  假设 `queue1`​ 里已经有了 `[1]`​。现在我们要 `push(2)`。

  - 第一步：新人进空屋  
    让新元素 2 先进入空的 queue2。

    - ​`q2`​: `[2]`
    - ​`q1`​: `[1]`
  - 第二步：老人排后面  
    把 queue1 里所有的老元素，一个个拿出来，排到 queue2 那个新人的后面。

    - ​`q2`​: `[2, 1]` (看！2 跑到前面去了！)
    - ​`q1`​: `[]` (空了)
  - 第三步：交换名字 (Swap)  
    现在 q2 里是我们想要的顺序 [2, 1]，而 q1 是空的。  
    为了保证下次还能用同样的逻辑，我们交换一下引用（改一下名字）。

    - ​`q1`​ 指向 `[2, 1]` (变成主队列)
    - ​`q2`​ 指向 `[]` (变回辅助空队列)

  #### 3. 为什么 `pop`​ 和 `top` 那么简单？

  Java

  ```
  public int pop() {
      return queue1.poll();
  }
  ```

  因为最麻烦的事情在 push 的时候已经做完了！

  现在的 queue1 里面，队头就是当初最后放进去的那个元素。

  想出栈？直接让 queue1 出队就行了。

  ---

  ### 模拟演练 (手把手)

  假设我们要：Push 1, Push 2, Push 3, Pop

  1. ​**Push 1**:

     - ​`q2`​ 收 1: `[1]`
     - ​`q1` 没东西可搬。
     - 交换。结果 -\> `q1`​: `[1]`​, `q2`​: `[]`
  2. ​**Push 2**:

     - ​`q2`​ 收 2: `[2]`
     - ​`q1`​ 里的 `1`​ 搬到 `q2`​: `q2`​ 变成 `[2, 1]`
     - 交换。结果 -\> `q1`​: `[2, 1]`​, `q2`​: `[]`
     -  *(注意：此时 2 在队头)*
  3. ​**Push 3**:

     - ​`q2`​ 收 3: `[3]`
     - ​`q1`​ 里的 `2, 1`​ 搬到 `q2`​: `q2`​ 变成 `[3, 2, 1]`
     - 交换。结果 -\> `q1`​: `[3, 2, 1]`​, `q2`​: `[]`
  4. ​**Pop**:

     - ​`q1`​ 执行 `poll()`。
     - 队头是 `3`。返回 3。
     - 正确！最后进去的 3 最先出来了。

  ### 总结给初学者

  - ​**语法上**​：记清楚队列是用 `offer`​(进) 和 `poll`(出)。
  - ​**逻辑上**：

    - 上一题（用栈做队列）是**取钱的时候**麻烦（pop 时倒腾数据）。
    - 这一题（用队列做栈）是**存钱的时候**麻烦（push 时倒腾数据）。
    - ​**核心一句话**：新来的必须当“插队大哥”，让所有老元素都排到它后面去，这样出队时它才能第一个出来。

# 20. 有效的括号

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/)

```java
class Solution {
    public boolean isValid(String s) {
        if (s.length() % 2 != 0) { // s 长度必须是偶数
            return false;
        }
        Map<Character, Character> mp = new HashMap<>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};
        Deque<Character> st = new ArrayDeque<>();
        for (char c : s.toCharArray()) {
            if (!mp.containsKey(c)) { // c 是左括号
                st.push(c); // 入栈
            } else if (st.isEmpty() || st.pop() != mp.get(c)) { // c 是右括号
                return false; // 没有左括号，或者左括号类型不对
            }
        }
        return st.isEmpty(); // 所有左括号必须匹配完毕
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/valid-parentheses/solutions/2809539/gua-hao-xiao-xiao-le-san-chong-li-yong-z-2xb3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- ## 写法二

  也可以在哈希表/数组中保存每个左括号对应的右括号。在遍历到左括号时，把对应的右括号入栈。这样遍历到右括号时，只需看栈顶括号是否一样即可。

```java
class Solution {
    public boolean isValid(String s) {
        if (s.length() % 2 != 0) { // s 长度必须是偶数
            return false;
        }
        Map<Character, Character> mp = new HashMap<>() {{
            put('(', ')');
            put('[', ']');
            put('{', '}');
        }};
        Deque<Character> st = new ArrayDeque<>();
        for (char c : s.toCharArray()) {
            if (mp.containsKey(c)) { // c 是左括号
                st.push(mp.get(c)); // 入栈
            } else if (st.isEmpty() || st.pop() != c) { // c 是右括号
                return false; // 没有左括号，或者左括号类型不对
            }
        }
        return st.isEmpty(); // 所有左括号必须匹配完毕
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/valid-parentheses/solutions/2809539/gua-hao-xiao-xiao-le-san-chong-li-yong-z-2xb3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这道题是 LeetCode 第 20 题 有效的括号。

  这其实就是经典的 “消消乐” 游戏：遇到左括号存起来，遇到右括号就看能不能抵消掉最近的一个左括号。

  按照我们的老规矩，先看工具（语法），再看图纸（思路）。

  ---

  ### 第一部分：语法总结 (你手里的工具)

  这段代码引入了两个新工具：`Map`​ 和 `Deque`。而且写法上非常“老练”，展示了现代 Java 的一些标准用法。

  #### 1. `Deque` (双端队列) —— 现代版的 Stack

  Java

  ```
  Deque<Character> st = new ArrayDeque<>();
  ```

  - ​**疑惑**​：之前的代码不是用 `Stack` 吗？这里怎么变了？
  - ​**解释**​：在 Java 官方推荐中，​**​`Stack`​**​ **这个类已经过时了（太老了，性能稍差）** 。
  - ​**现代标准**​：现在写代码，如果想用栈的功能，通常都用 `Deque`​（读作 "deck"）接口，配合 `ArrayDeque` 实现类。
  - ​**用法完全一样**：

    - ​`push(c)`：入栈（压进去）。
    - ​`pop()`：出栈（弹出来）。
    - ​`isEmpty()`：是不是空的。

  #### 2. `Map` (哈希表/字典)

  Java

  ```
  Map<Character, Character> mp = new HashMap<>() {{
      put(')', '(');
      put(']', '[');
      put('}', '{');
  }};
  ```

  - ​**什么是 Map**：就像一本字典。你需要查找一个东西（Key），它告诉你对应的内容（Value）。
  - ​**这里存了什么**：

    - 它建立了 **右括号 ->**  **左括号** 的映射关系。
    - 意思是：如果你手里拿的是 `)`​，那你期待的另一半必须是 `(`。
  - ​**双大括号**  **​`{{ }}`​** ：这是一种“匿名内部类”的初始化写法，为了方便在创建 Map 的同时直接塞进去初始数据。
  - ​**关键方法**：

    - ​`mp.containsKey(c)`​：查字典。看看 `c` 是不是一个“右括号”（因为 Key 存的都是右括号）。
    - ​`mp.get(c)`​：取值。如果 `c`​ 是 `)`​，这句代码返回 `(`。

  #### 3. 取余运算 `%`

  Java

  ```
  if (s.length() % 2 != 0)
  ```

  - ​**逻辑**​：括号必须成对出现，所以总长度一定是偶数。如果是奇数（比如 3 个），绝对不可能匹配成功，直接返回 `false`。这是一个“剪枝”操作，为了省时间。

  ---

  ### 第二部分：思路总结 (你的解题图纸)

  这道题的核心逻辑是 ​**栈 (Stack) 的“对称性”** 。

  #### 1. 策略：左进右出（配对消除）

  想象你在整理俄罗斯套娃，或者剥洋葱。

  - ​**左括号**  **​`( [ {`​** ​：代表“开始了”，但我不知道什么时候结束。​**先存起来**（入栈）。
  - ​**右括号**  **​`) ] }`​** ​：代表“要结束了”。此时必须检查**最近一次存进去的**那个左括号是否匹配。

  #### 2. 代码逻辑拆解

  第一步：准备字典

  我们把规则写在纸上（Map）：看到 ) 就要找 (，看到 ] 就要找 [。

  **第二步：遍历字符串**

  Java

  ```
  for (char c : s.toCharArray()) {
      if (!mp.containsKey(c)) { 
          // 这一步很巧妙！
          // 如果 Map 的 Key 里没有 c（说明 c 不是右括号），那它肯定是左括号。
          st.push(c); // 左括号？入栈！
      } else {
          // 说明 c 是右括号，准备消消乐
          // ... (看下面)
      }
  }
  ```

  第三步：右括号的“三连问” (核心难点)

  当遇到一个右括号（比如 )）时，我们要检查三件事，只要有一件不满足，马上报错（return false）：

  Java

  ```
  // 翻译代码： st.isEmpty() || st.pop() != mp.get(c)

  // 1. 栈是空的吗？
  // 如果栈空了，说明没有左括号给你消了。比如输入是 "())"，多了一个右括号。 -> 错！

  // 2. 弹出来的左括号，跟我不匹配吗？
  // 比如当前是 ')'，期望栈顶是 '('。结果 pop 出来个 '['。 -> 错！
  ```

  **第四步：最后的大结局**

  Java

  ```
  return st.isEmpty();
  ```

  循环结束了，能直接返回 `true`​ 吗？**不行！**

  - 比如输入 `"((("`​，循环里一直在 `push`，从来没报错。
  - 但最后栈里还剩下一堆左括号没被消除。
  - ​**规则**：只有栈彻底空了，才算完美匹配。

  #### 3. 模拟演示

  输入：`s = "{ [ ] }"`

  1. 遇到 `{`​：是左括号。**栈：**​ **​`{`​**
  2. 遇到 `[`​：是左括号。**栈：**​ **​`{, [`​** ​ (注意 `[` 在顶上)
  3. 遇到 `]`：是右括号。

     - 查 Map：`]`​ 对应的应该是 `[`。
     - 看栈顶：确实是 `[`​。**匹配成功！消掉！**
     - **栈：**​ **​`{`​**
  4. 遇到 `}`：是右括号。

     - 查 Map：`}`​ 对应的应该是 `{`。
     - 看栈顶：确实是 `{`​。**匹配成功！消掉！**
     - **栈：**​**​`空`​**
  5. 循环结束，栈为空。返回 `true`。

  ### 总结给初学者

  1. ​**工具更新**​：以后做栈的题，尽量用 `Deque`​ (ArrayDeque)，虽然 `Stack`​ 也能用，但 `Deque` 更专业。
  2. ​**Map 的妙用**​：用 Map 存 `右->左`​ 的关系，可以避免写一大堆 `if (c==')' && top=='(') ... else if ...`。
  3. ​**核心口诀**：

     - 左括号？**进栈**等着。
     - 右括号？**查栈顶**抵消。
     - 最后必须​**空空如也**。

# 1047. 删除字符串中的所有相邻重复项

使用 Deque 作为堆栈

## 问题：

- - 在 Java 中，`String`​ 是不可变的。每次执行 `str = ... + str`​，系统都会创建一个新的 `StringBuilder`​ 对象，将原来的内容拷贝一遍，再生成一个新的 `String`。
  - **后果：**  如果剩下的字符很多，这个循环的时间复杂度会飙升到 $O(N^2)$。这在面试中会被扣分。

```java
class Solution {
    public String removeDuplicates(String S) {
        //ArrayDeque会比LinkedList在除了删除元素这一点外会快一点
        //参考：https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist
        ArrayDeque<Character> deque = new ArrayDeque<>();
        char ch;
        for (int i = 0; i < S.length(); i++) {
            ch = S.charAt(i);
            if (deque.isEmpty() || deque.peek() != ch) {
                deque.push(ch);
            } else {
                deque.pop();
            }
        }
        String str = "";
        //剩余的元素即为不重复的元素
        while (!deque.isEmpty()) {
            str = deque.pop() + str;
        }
        return str;
    }
}

```

---

### 拿字符串直接作为栈，省去了栈还要转为字符串的操作：

```java
class Solution {
    public String removeDuplicates(String s) {
        // 将 res 当做栈
        // 也可以用 StringBuilder 来修改字符串，速度更快
        // StringBuilder res = new StringBuilder();
        StringBuffer res = new StringBuffer();
        // top为 res 的长度
        int top = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            // 当 top >= 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--
            if (top >= 0 && res.charAt(top) == c) {
                res.deleteCharAt(top);
                top--;
            // 否则，将该字符 入栈，同时top++
            } else {
                res.append(c);
                top++;
            }
        }
        return res.toString();
    }
}
```

- 这段代码的思路非常清晰，通过手动维护一个 `top`​ 指针，用 `StringBuffer` 模拟了一个栈。

  为了让你完全吃透这段代码，我将从​**核心思路**​（为什么要这么做）和​**详细语法细节**（每一行代码背后的原理）两个方面为你深度解析。

  ---

  ### 一、 核心思路解析：栈的“消消乐”

  这道题的本质是：**相邻且相同，就会消失。**

  这就好比玩“连连看”或者“俄罗斯方块”，新的方块落下来，如果和下面的方块一样，两个都消失；如果不一样，就堆叠上去。

  **为什么选栈（Stack）？**

  因为我们需要频繁地查看\*\*“刚刚放进去的那个元素”\*\*（即栈顶元素）。

  - **入栈（Append）：**  来了个新字符，和栈顶不一样，留下来。
  - **出栈（Delete）：**  来了个新字符，和栈顶一样，两个抵消（把栈顶的那个踢出去）。

  **你的代码巧妙之处：**

  通常大家会用 `Stack<Character>`​ 类。但你直接用 `StringBuffer/StringBuilder`​ 当作栈容器，把字符串的**末尾**当作​**栈顶**​。这样做的好处是：**最后不需要再把栈里的元素一个个倒出来拼字符串，容器本身就是结果。**

  ---

  ### 二、 详细语法细节与底层原理

  这里有几个非常关键的语法点，面试时常问：

  #### 1. `StringBuffer`​ vs `StringBuilder` (重中之重)

  Java

  ```
  // 你的代码：
  StringBuffer res = new StringBuffer();
  ```

  - **语法细节：**  `StringBuffer`​ 是 Java 早期（JDK 1.0）提供的类。它的所有方法（如 `append`​, `deleteCharAt`​）都加了 `synchronized` 关键字。
  - **意味着什么：**  它是**线程安全**的（Thread-safe）。就像去上厕所要锁门一样，同一时间只能有一个线程操作它。
  - **代价：**  “锁门”和“开锁”非常耗时。在 LeetCode 这种单线程环境下，这些锁是多余的累赘。
  - **推荐：**  ​**坚决改用** **​`StringBuilder`​**（JDK 1.5 引入）。它的 API 和 Buffer 完全一样，但去掉了锁，性能提升显著。

  #### 2. `top` 指针的初始化与含义

  Java

  ```
  int top = -1;
  ```

  - **语法细节：**  这里 `top`​ 代表的是 ​ **“栈顶元素的下标”** 。
  - **为什么是 -1？**

    - 数组/字符串下标从 `0` 开始。
    - 当容器为空时，没有元素，所以下标指向 `0`​ 的左边，即 `-1`。
  - **逻辑对应：**

    - ​`top == -1`：空栈。
    - ​`top == 0`：栈里有 1 个元素。

  #### 3. `charAt(int index)` 方法

  Java

  ```
  if (top >= 0 && res.charAt(top) == c)
  ```

  - **语法细节：**  `charAt`​ 是 `CharSequence` 接口（StringBuilder 实现该接口）的方法。
  - **底层原理：**  `StringBuilder`​ 内部其实维护了一个 `char[] value`​ 数组。`charAt(top)`​ 本质上就是返回内部数组 `value[top]`​ 的值。这是一个 ​**O(1)** （常数时间）的操作，非常快。

  #### 4. `deleteCharAt(int index)` 方法

  Java

  ```
  res.deleteCharAt(top);
  ```

  - **语法细节：**  删除指定位置的字符。
  - **底层原理（坑点）：**

    - 如果你删除中间的字符，Java 需要把后面的字符全部往前挪一位（System.arraycopy），这是 **O(N)**  的操作，很慢。
    - **但是！**  你删除的是 `top`​（最后一个位置）。此时不需要挪动任何元素，只需要把内部的 `count`​（计数器）减 1 即可。这是一个 **O(1)**  的操作。
    - **结论：**  在这里当栈用（只删末尾），性能极高。

  #### 5. `append(char c)` 方法

  Java

  ```
  res.append(c);
  ```

  - **语法细节：**  在字符串末尾添加字符。
  - **底层原理：**

    - 如果内部数组还有空位，直接赋值：`value[count++] = c`。
    - 如果内部数组满了，会触发​**扩容机制**（通常扩容为原来的 2 倍 + 2），这会涉及到新建数组和拷贝数据。

  ---

  ### 三、 代码执行流程演示

  假设输入字符串 `s = "abbaca"`。

  |**步骤**|**当前字符 c**|**top 指针**|**res (栈) 内容**|**操作**|**解释**|||||||
  | ------| ------| ---------| ------| ------| ------------------------| --| --| --| --| --| --|
  |**初始**|-|-1|​`""`|-|空栈|||||||
  |**1**|​`'a'`|-1 (空)|​`""`|**入栈**|栈空，直接加入|||||||
  |结果||**0**|​`"a"`|​`top++`||||||||
  |**2**|​`'b'`|0|​`"a"`|**入栈**|​`'b' != 'a'`(栈顶)，加入|||||||
  |结果||**1**|​`"ab"`|​`top++`||||||||
  |**3**|​`'b'`|1|​`"ab"`|**出栈**|​`'b' == 'b'`(栈顶)，匹配消除！|||||||
  |结果||**0**|​`"a"`|​`top--`|​`deleteCharAt(1)`|||||||
  |**4**|​`'a'`|0|​`"a"`|**出栈**|​`'a' == 'a'`(栈顶)，匹配消除！|||||||
  |结果|| **-1**|​`""`|​`top--`|​`deleteCharAt(0)`|||||||
  |**5**|​`'c'`|-1|​`""`|**入栈**|栈空，直接加入|||||||
  |结果||**0**|​`"c"`|​`top++`||||||||
  |**6**|​`'a'`|0|​`"c"`|**入栈**|​`'a' != 'c'`(栈顶)，加入|||||||
  |结果||**1**|​`"ca"`|​`top++`||||||||

  **最终返回：**  `"ca"`。

  ### 四、 最终优化后的代码（标准答案）

  我帮你把 `StringBuffer`​ 改成了 `StringBuilder`​，并去掉了显式的 `top`​ 变量（用 `length()-1` 代替），这是最符合 Java 习惯的写法：

  Java

  ```
  class Solution {
      public String removeDuplicates(String s) {
          // 1. 使用 StringBuilder，速度更快 (非线程安全)
          StringBuilder stack = new StringBuilder();

          for (int i = 0; i < s.length(); i++) {
              char c = s.charAt(i);
              
              // 2. 获取当前栈的长度
              int len = stack.length();

              // 3. 判断：栈不为空 且 栈顶元素等于当前元素
              // len - 1 就是你代码里的 top
              if (len > 0 && stack.charAt(len - 1) == c) {
                  // 4. 出栈（消除）
                  stack.deleteCharAt(len - 1);
              } else {
                  // 5. 入栈
                  stack.append(c);
              }
          }
          return stack.toString();
      }
  }
  ```

  **总结：**  你的逻辑完全正确，唯一的“瑕疵”就是选用了老旧的 `StringBuffer`​。换成 `StringBuilder` 后，这就是教科书级别的解答。

---

### 拓展：双指针

```java
class Solution {
    public String removeDuplicates(String s) {
        char[] ch = s.toCharArray();
        int fast = 0;
        int slow = 0;
        while(fast < s.length()){
            // 直接用fast指针覆盖slow指针的值
            ch[slow] = ch[fast];
            // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了
            if(slow > 0 && ch[slow] == ch[slow - 1]){
                slow--;
            }else{
                slow++;
            }
            fast++;
        }
        return new String(ch,0,slow);
    }
}
```

- 这段代码写得**非常“秀”** ！

  这是这道题在 Java 语言下的**性能天花板**（耗时最少，通常击败 100% 的提交）。

  它没有使用任何额外的容器（如 `Stack`​, `Deque`​, `StringBuilder`​），而是直接利用**数组 + 双指针**模拟了一个栈。这属于进阶的“原地操作”（In-place Operation）思想。

  以下是详细的思路图解和语法解析：

  ### 1. 核心思路：数组当栈用

  你需要把 `ch` 数组看作两部分：

  1. ​**​`0`​**​ **到** **​`slow-1`​**​ **的区域：**  这是我们模拟的  **“栈”** ，存放的是已经处理好、没有重复的字符。
  2. ​**​`fast`​**​ **指针：**  它是  **“扫描员”** ，负责把后面的新字符一个个搬运过来。

  **逻辑精髓：**

  - **入栈操作：**  不管三七二十一，先把 `fast`​ 指向的字符“写”到 `slow` 的位置（覆盖）。
  - **检查消消乐：**  写完之后，回头看一眼：`slow`​ 位置的字符和它前一个位置 `slow-1` 一样吗？
  - **一样（消除）：**  `slow--`。这意味着刚才写进去的字符和前面的抵消了，不仅刚才那个不要了，前面的那个也“出栈”了。
  - **不一样（保留）：**  `slow++`。意味着刚才写进去的字符是合法的，栈顶向上长高一格。

  ---

  ### 2. 代码执行过程模拟

  假设字符串 `s = "abbaca"`。

  |步骤|​`fast` 指针|当前字符|动作 (ch[slow] = ch[fast])|检查冲突 (ch[slow] vs ch[slow-1])|​`slow` 变化|数组当前状态 (0~slow)|
  | ------| -----------| ----------| ----------------------------| -----------------------------------| -----------| -----------------------|
  |**1**|0|'a'|​`ch[0] = 'a'`|​`slow=0`，无法比较|​`slow++` -> 1|​`[a]`|
  |**2**|1|'b'|​`ch[1] = 'b'`|​`'b' != 'a'`|​`slow++` -> 2|​`[a, b]`|
  |**3**|2|'b'|​`ch[2] = 'b'`|​`'b' == 'b'` (冲突!)|​**​`slow--`​** ​  **-> 1**|​`[a]` (逻辑上删掉了b)|
  |**4**|3|'a'|​`ch[1] = 'a'` (覆盖)|​`'a' == 'a'` (冲突!)|​**​`slow--`​** ​  **-> 0**|​`[]` (逻辑上空了)|
  |**5**|4|'c'|​`ch[0] = 'c'` (覆盖)|​`slow=0`，无法比较|​`slow++` -> 1|​`[c]`|
  |**6**|5|'a'|​`ch[1] = 'a'`|​`'a' != 'c'`|​`slow++` -> 2|​`[c, a]`|

  **最终结果：**  截取数组前 `slow`​ (2) 个字符 -> `"ca"`。

  ---

  ### 3. 关键语法细节解析

  #### A. `ch[slow] = ch[fast];` (先上车，后买票)

  这行代码非常关键。它的策略是：**先把人放进来，再检查合不合格。**

  - 这样做的好处是代码极其简洁，不需要提前判断。
  - 如果合格，`slow` 就会往后移，这个字符就留下了。
  - 如果不合格（重复），`slow`​ 就会退回去，**下一次循环时，这个位置就会被新的** **​`fast`​**​ **字符无情覆盖**。

  #### B. `slow > 0`

  ```java
  if (slow > 0 && ch[slow] == ch[slow - 1])

  ```

  这个判断必不可少。

  - 当 `slow == 0`​ 时（栈是空的），来了新字符肯定直接入栈，没法和“前面”比较，否则会数组越界（`slow - 1` 变成 -1）。

  #### C. `return new String(ch, 0, slow);`

  这是 Java `String` 类的一个构造方法，专门用于从字符数组中截取一段。

  - **语法：**  `new String(char[] value, int offset, int count)`
  - **含义：**  使用数组 `ch`​，从下标 `0`​ 开始，截取 `slow` 个长度的字符。
  - **为什么不用** **​`toString()`​** ​ **？**  数组的 `toString()`​ 打印的是内存地址哈希码（如 `[C@15db9742`​），必须用 `String`​ 构造器或者 `String.valueOf`。

  ---

  ### 4. 这种写法的优缺点

  **优点：**

  1. **速度极快：**  纯数组操作，内存连续，CPU 缓存命中率高。
  2. **无对象开销：**  相比 `StringBuilder`​ 或 `Deque`，它没有创建任何额外的对象（除了最开始转数组和最后转字符串），垃圾回收（GC）压力最小。

  **缺点：**

  1. **理解门槛：**  双指针的“覆盖”逻辑比直接用栈“入栈出栈”要难理解一点。
  2. **破坏原数据：**  `fast`​ 跑过的地方，数据可能被修改了（虽然这题里我们本身就转成了新数组 `ch`，所以无所谓）。

  **总结：**   
  如果面试时你能写出 `Deque`​ 或 `StringBuilder`​ 版本，是**标准答案**；  
  如果你能写出这个双指针版本，并能解释清楚“覆盖”和“回退”的逻辑，那就是**满分答案**。

‍
