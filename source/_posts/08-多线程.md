---
title: 08多线程
date: '2026-02-09 20:22:46'
updated: '2026-02-12 15:03:56'
permalink: /post/08multiple-threads-2mwpua.html
comments: true
toc: true
---



# 08多线程

# 线程的创建方式：

---

### 1. 继承 Thread 类

这是最直接的方式。`Thread`​ 类本身就实现了 `Runnable` 接口。

- **实现方式：**  定义一个类继承 `Thread`​，重写 `run()` 方法。
- **启动方式：**  创建子类对象，调用 `start()` 方法。
- **局限性：**  Java 是**单继承**的。如果你的类已经继承了其他类（比如 `extends Person`​），就无法再继承 `Thread`，扩展性较差。

Java

```
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("方式一：继承 Thread 类，线程名：" + Thread.currentThread().getName());
    }
}

// 调用
public static void main(String[] args) {
    new MyThread().start();
}
```

### 2. 实现 Runnable 接口

这是最常用的基础方式，体现了“组合优于继承”的设计原则。

- **实现方式：**  定义一个类实现 `Runnable`​ 接口，实现 `run()` 方法。
- **启动方式：**  将该实现类的实例作为参数传递给 `Thread`​ 的构造函数，再调用 `start()`。
- **优点：**  避免了单继承的局限性，实现了​**任务（Runnable）与 线程（Thread）的解耦**​。多个线程可以共享同一个 `Runnable` 资源。

Java

```
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("方式二：实现 Runnable 接口，线程名：" + Thread.currentThread().getName());
    }
}

// 调用
public static void main(String[] args) {
    MyRunnable target = new MyRunnable();
    // 传入 target，启动线程
    new Thread(target).start(); 
}
```

### 3. 实现 Callable 接口

​`Runnable`​ 有一个缺点：`run()`​ 方法没有返回值，也不能抛出受检异常（Checked Exception）。`Callable` 解决了这个问题。

- **实现方式：**  实现 `Callable<V>`​ 接口，重写 `call()` 方法。
- **启动方式：**  需要借助 `FutureTask`​ 类来包装 `Callable`​ 对象（因为 `Thread`​ 只能接受 `Runnable`​，而 `FutureTask`​ 既实现了 `Runnable`​ 又包装了 `Callable`）。
- **优点：**  ​**有返回值**​，​**可以抛出异常**。适合需要获取异步执行结果的场景。

Java

```
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println("方式三：实现 Callable 接口，计算中...");
        Thread.sleep(1000); // 模拟耗时
        return 1024;
    }
}

// 调用
public static void main(String[] args) throws ExecutionException, InterruptedException {
    // 1. 创建 Callable 实例
    MyCallable myCallable = new MyCallable();
    // 2. 使用 FutureTask 包装 Callable
    FutureTask<Integer> futureTask = new FutureTask<>(myCallable);
    // 3. 启动线程
    new Thread(futureTask).start();

    // 4. 获取结果（这一步会阻塞主线程，直到 call() 执行完毕）
    Integer result = futureTask.get(); 
    System.out.println("获取到的返回值：" + result);
}
```

---

### 核心对比总结

为了方便记忆和选型，请参考下表：

|**特性**|**继承 Thread**|**实现 Runnable**|**实现 Callable**|||||
| --| ----------------------------| ------------------------------| --------------------------------| --| --| --| --|
|**返回值**|无|无|**有 (泛型)**|||||
|**抛出异常**|只能捕获，不能抛出|只能捕获，不能抛出|**可以抛出 Exception**|||||
|**扩展性**|差 (占用了父类名额)|**好 (支持实现其他接口)**|**好**|||||
|**实现复杂度**|简单|简单|略复杂 (需 FutureTask)|||||
|**使用场景**|简单的、不依赖返回值的任务|资源共享、多线程处理同一任务|需要计算结果、可能抛异常的任务|||||

---

### ⚠️ 进阶：实际开发中的“第四种方式”

在真实的生产环境（企业级开发）中，我们**极少**直接使用 `new Thread()`。

因为频繁地创建和销毁线程（Create & Destroy）非常消耗系统资源（CPU、内存）。如果并发量大，可能会导致 OOM（内存溢出）。

**最佳实践：使用线程池 (Thread Pool)**

也就是使用 `ExecutorService` 框架。严格来说，线程池并不是“创建线程的新方式”（底层还是用的 Runnable/Thread），但它是“管理线程的标准方式”。

Java

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public static void main(String[] args) {
    // 创建一个包含10个线程的线程池
    ExecutorService pool = Executors.newFixedThreadPool(10);

    // 提交 Runnable 任务
    pool.execute(new MyRunnable());
    
    // 提交 Callable 任务
    // pool.submit(new MyCallable());

    // 关闭线程池
    pool.shutdown();
}
```

# 线程的常用方法：

---

### 1. 核心启动方法

最基础的两个方法，但面试中经常问到它们的区别。

|方法|说明|关键点|
| ------| --------------| -----------------------------------------------------------------------|
|​**​`start()`​** |启动新线程|JVM 会调用底层的 `run`​ 方法。调用后线程进入 **Runnable (就绪)**  状态。**只能调用一次**。|
|​**​`run()`​** |执行业务逻辑|如果直接调用 `run()`​，它只是一个普通的方法调用，**不会启动新线程**，而是在当前主线程中执行。|

> **一句话总结：**  只有调用了 `start()`，才真正开启了多线程。

---

### 2. 线程控制与调度 (静态方法)

这些方法通常直接通过 `Thread.method()`​ 调用，作用于**当前正在执行**的线程。

- ​**​`Thread.sleep(long millis)`​**
- **作用：**  让当前线程“睡眠”指定毫秒数，进入 **Timed Waiting (超时等待)**  状态。
- **注意：**  睡眠期间，线程**不会释放对象锁**（抱着锁睡觉）。时间到了自动醒来。
- ​**​`Thread.yield()`​**
- **作用：**  线程“礼让”。提示调度器当前线程愿意放弃 CPU 资源。
- **注意：**  线程会从 **Running** 回到 **Runnable (就绪)**  状态，而不是阻塞。调度器可能会忽略这个提示，或者立刻又再次选中该线程执行。

---

### 3. 线程等待与插队 (实例方法)

- ​**​`join()`​**
- **作用：**  让“当前线程”等待“调用 join 的那个线程”执行完毕。
- **场景：**  比如主线程需要等待子线程 A 和 B 都把数据准备好，才能进行下一步汇总。
- **记忆口诀：**  谁调用 `join`，谁就是“插队者”，当前线程就要让它先走。

```java
Thread t1 = new Thread(() -> { ... });
t1.start();
t1.join(); // 主线程阻塞，直到 t1 执行完毕
System.out.println("t1 结束了，主线程继续");

```

---

### 4. 线程中断机制

Java 的中断是一种**协作机制**，而不是强制停止。

- ​**​`interrupt()`​**
- **作用：**  给目标线程打一个“中断标记”。如果该线程正在阻塞（如 `sleep`​, `wait`​, `join`​），会抛出 `InterruptedException` 并清除标记。
- ​**​`isInterrupted()`​**
- **作用：**  检查线程是否被标记中断（不清除标记）。
- ​**​`Thread.interrupted()`​**
- **作用：**  静态方法，检查**当前线程**是否被中断，并**清除标记**。

---

### 5. 线程通信 (Object 类的方法)

虽然这些是 `Object`​ 类的方法，但它们是线程通信的核心。**必须在** **​`synchronized`​**​ **同步代码块中使用。**

- ​**​`wait()`​**
- **作用：**  让当前线程等待。
- **关键点：**  线程会**释放对象锁**，进入等待池，直到被唤醒。
- **`notify()`​ / `notifyAll()**`
- **作用：**  唤醒在该对象上等待的线程（`notify`​ 随机唤醒一个，`notifyAll` 唤醒所有）。

---

### 6. 属性设置方法

- ​**​`setDaemon(boolean on)`​**
- **作用：**  将线程设置为**守护线程**（如 GC 垃圾回收线程）。
- **特性：**  当 JVM 中所有的用户线程（非守护线程）结束时，守护线程会自动死亡，JVM 退出。**必须在 start() 之前调用**。
- ​**​`setPriority(int newPriority)`​**
- **作用：**  设置优先级（1-10，默认为 5）。优先级高并不代表一定先执行，只是获得 CPU 时间片的概率大一些。

---

### ⚠️ 高频面试对比：sleep() vs wait()

这是这部分最核心的知识点，请务必区分：

|特性|Thread.sleep()|Object.wait()|
| ------| --------------------| ----------------------|
|**所属类**|Thread 类|Object 类|
|**锁的处理**|**不释放锁** (抱着锁睡)|**释放锁** (交出控制权)|
|**使用范围**|任何地方|必须在 `synchronized` 块中|
|**唤醒方式**|时间到了自动醒|需要被 `notify()`​ 或 `notifyAll()` 唤醒|
|**用途**|暂停执行，模拟延时|线程间通信/协作|

---

### ❌ 已废弃的方法 (不要使用)

你应该知道它们存在，但在开发中**严禁使用**，因为可能导致死锁或数据不一致：

- ​`stop()`: 暴力停止线程，可能导致资源未释放。
- ​`suspend()`​ / `resume()`: 暂停和恢复，极易造成死锁。

---

# 线程安全：

所谓“线程安全”，核心在于​**对共享资源（Shared Resources）的访问控制**。

简单来说：当多个线程同时访问同一个变量（或对象），如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

反之，如果出现了**数据污染、重复处理、丢失更新**等情况，就是​**线程不安全**。

---

### 1. 场景模拟：经典的“卖票问题”

为了让你直观地看到线程不安全引发的灾难，我们来模拟一个**火车站卖票**的场景。

**设定：**

- 只有 **10 张** 火车票。
- 有 **3 个窗口** (线程) 同时在抢着卖这 10 张票。
- 为了让问题更容易复现，我们在卖票前模拟一点网络延迟（`Thread.sleep`），这会让线程切换的概率大大增加。

#### ❌ 线程不安全的代码示例

Java

```
public class TicketDemo {
    public static void main(String[] args) {
        // 创建一个卖票的任务（Runnable），这 10 张票是共享资源
        SellTicketTask task = new SellTicketTask();

        // 开启 3 个线程（窗口）同时执行这个任务
        new Thread(task, "窗口A").start();
        new Thread(task, "窗口B").start();
        new Thread(task, "窗口C").start();
    }
}

class SellTicketTask implements Runnable {
    // 共享数据：10 张票
    private int tickets = 10;

    @Override
    public void run() {
        while (true) {
            // 1. 判断是否还有票
            if (tickets > 0) {
                try {
                    // 2. 模拟网络延迟（哪怕只有 10ms，也会引发严重的线程安全问题）
                    // 这一步是为了放大线程被挂起、发生上下文切换的可能性
                    Thread.sleep(10); 
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // 3. 卖票（打印并减 1）
                String name = Thread.currentThread().getName();
                System.out.println(name + " 正在卖第 " + tickets-- + " 张票");
            } else {
                break; // 没票了，退出循环
            }
        }
    }
}
```

---

### 2. 运行结果分析

如果你运行上面的代码，极大概率会看到以下 ​**两种诡异现象**：

**现象一：重票（卖了同一张票）**

Plaintext

```
窗口A 正在卖第 10 张票
窗口B 正在卖第 10 张票  <-- 错误！一张票卖给了两个人
```

**现象二：超卖（卖出了 0 甚至负数的票）**

Plaintext

```
...
窗口B 正在卖第 1 张票
窗口C 正在卖第 0 张票   <-- 错误！不存在第 0 张票
窗口A 正在卖第 -1 张票  <-- 严重错误！系统崩溃
```

---

### 3. 为什么会这样？（原理图解）

问题的根源在于 **原子性（Atomicity）**  被破坏了。

你以为 `tickets--`​ 是一行代码，是一个动作。但在计算机底层（JVM 指令集），它实际上包含了 ​**三个步骤**：

1. **Read（读）：**  从内存中读取 `tickets` 的当前值（比如 1）。
2. **Modify（改）：**  在 CPU 寄存器中将值减 1（变成 0）。
3. **Write（写）：**  将新的值（0）写回内存。

**超卖（负数票）是如何发生的？**

假设现在只剩下 **最后 1 张票** (`tickets = 1`)：

1. **窗口A** 抢到了 CPU，执行 `if(tickets > 0)`，条件成立。
2. **窗口A** 刚准备卖，突然遇到了 `Thread.sleep`​ 或者时间片用完了，被迫挂起（此时它还没来得及把 `tickets` 减 1）。
3. **窗口B** 抢到了 CPU。它去内存读 `tickets`​，发现仍然是 ​**1**。
4. **窗口B** 执行 `if(tickets > 0)`，条件也成立！
5. **窗口B** 动作快，直接把票卖了，`tickets`​ 变成了 ​**0**，写回内存。
6. **窗口A** 醒来了。它**不需要再次判断** `if`​（因为它之前已经判断过了，程序计数器记录了它停在 `if` 里面）。
7. **窗口A** 继续执行 `tickets--`。虽然现在内存里是 0，但 A 手里的临时变量可能还是旧的，或者它直接对 0 进行减 1 操作。
8. **结果：**  `tickets`​ 变成了 ​ **-1**。

---

### 总结

产生线程安全问题，通常需要同时满足以下 ​**三个条件**：

1. ​**多线程环境**（有多个线程在运行）。
2. ​**共享资源**（多个线程访问同一个变量/对象）。
3. ​**非原子性操作**（对资源进行了写操作，且该操作不是一步完成的）。

**想要解决这个问题，就必须打破上面这三个条件之一。**  最常用的方法就是给代码 ​ **“加锁”** 。

‍

---

​**线程同步**（Thread Synchronization）是解决线程安全问题的核心手段。

它的本质就是 ​ **“排队”** ​：当多个线程竞争同一个共享资源时，让它们按照顺序一个一个地访问，而不是一窝蜂地抢。这虽然牺牲了一点性能（并发变串行），但保证了数据的 ​**安全性（原子性）** 。

我们继续使用“卖票”的案例，来看看这三种修复方式的代码实现与区别。

---

### 方式一：同步代码块 (Synchronized Block)

这是最灵活的一种方式。你可以手动指定  **“锁对象”**  和 ​ **“需要锁住的代码范围”** 。

- **格式：**  `synchronized(锁对象) { ... }`
- **锁对象：**  必须是​**所有线程都能看得到的同一个对象**​（通常是 `this` 或者共享资源本身）。

Java

```
class SellTicketBlock implements Runnable {
    private int tickets = 10;
    // 定义一把“锁”对象（也可以直接用 this）
    private final Object lock = new Object(); 

    @Override
    public void run() {
        while (true) {
            // 【重点】这里开始加锁
            synchronized (lock) { 
                if (tickets > 0) {
                    try { Thread.sleep(10); } catch (InterruptedException e) {}
                    
                    System.out.println(Thread.currentThread().getName() + " 卖出第 " + tickets-- + " 张票");
                } else {
                    break; 
                }
            } // 【重点】这里释放锁
        }
    }
}
```

> **注意：**  锁的范围不能太大（影响效率），也不能太小（没包住所有涉及共享资源的操作）。

---

### 方式二：同步方法 (Synchronized Method)

这是最简洁的方式。直接在方法声明上加上 `synchronized` 关键字。

- **格式：**  `public synchronized void method() { ... }`
- **隐式锁对象：**

  - 如果是​**普通实例方法**​，锁对象就是 `this`（当前对象）。
  - 如果是​**静态方法 (static)** ​，锁对象是 `类名.class`（当前类的字节码对象）。

Java

```
class SellTicketMethod implements Runnable {
    private int tickets = 10;

    @Override
    public void run() {
        while (true) {
            if (!sellOne()) break; // 调用同步方法
        }
    }

    // 【重点】将卖票逻辑抽取出来，加上 synchronized
    // 此时锁对象默认是 this
    private synchronized boolean sellOne() {
        if (tickets > 0) {
            try { Thread.sleep(10); } catch (InterruptedException e) {}
            System.out.println(Thread.currentThread().getName() + " 卖出第 " + tickets-- + " 张票");
            return true;
        }
        return false;
    }
}
```

> **优缺点：**  代码写起来简单，但​**粒度太粗**。如果你整个方法里只有一行代码操作共享数据，其他 99 行都是耗时计算，那么把整个方法锁住会导致性能大幅下降。

---

### 方式三：Lock 锁 (显式锁)

JDK 5 以后引入的 `java.util.concurrent.locks.Lock`​ 接口，最常用的是实现类 `ReentrantLock`（可重入锁）。

它比 `synchronized`​ 更强大、更灵活，但也更麻烦，因为它需要**手动上锁**和​**手动释放锁**。

- **核心步骤：**

  1. ​`lock()`: 上锁
  2. ​`try { ... } finally { unlock() }`​: ​**必须在 finally 中释放锁**，否则一旦发生异常，锁永远不会释放，导致程序“死锁”。

Java

```
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SellTicketLock implements Runnable {
    private int tickets = 10;
    
    // 【重点】定义显式锁，必须是成员变量，确保多个线程共享同一把锁
    private final Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            // 1. 上锁
            lock.lock(); 
            try {
                // 2. 核心业务逻辑
                if (tickets > 0) {
                    try { Thread.sleep(10); } catch (InterruptedException e) {}
                    System.out.println(Thread.currentThread().getName() + " 卖出第 " + tickets-- + " 张票");
                } else {
                    break;
                }
            } finally {
                // 3. 【必须】在 finally 块中释放锁
                lock.unlock(); 
            }
        }
    }
}
```

---

### ⚔️ 核心对比：synchronized vs Lock

这是面试中的超高频考点，请务必掌握：

|**特性**|**synchronized**|**Lock (ReentrantLock)**||||
| --| -------------------------------------| ---------------------------------------| --| --| --|
|**存在层次**|Java 关键字 (JVM 层实现)|Java 类/接口 (API 层实现)||||
|**锁的获取**|隐式 (进入代码块自动获取)|**显式**(需要调用`lock()`)||||
|**锁的释放**|隐式 (出代码块/异常自动释放)|**显式**(必须在`finally`​中调用`unlock()`)||||
|**灵活性**|低 (不可中断，无法判断是否获取到锁)|**高**(可中断`lockInterruptibly`​，可尝试获取`tryLock`)||||
|**公平性**|非公平锁|默认非公平，**可设置为公平锁**||||
|**适用场景**|代码量少，竞争不激烈|竞争激烈，需要高级功能 (如超时、中断)||||

> **什么是公平锁？**
>
> ​`Lock lock = new ReentrantLock(true);`
>
> 这意味着“先来后到”。排队时间最长的线程会优先获得锁。而 `synchronized`​ 和默认的 `Lock` 都是“非公平”的，只要锁被释放，谁抢到算谁的，可能导致某些线程一直抢不到（线程饥饿）。

**掌握了如何“加锁”，也就意味着同时也可能引入“死锁”的问题。你想了解什么是死锁，以及如何避免吗？**

---

**线程池 (Thread Pool)**  是 Java 并发编程中非常重要的概念。

简单来说，**线程池就是一个容纳多个线程的容器**。  
它的核心思想是：**复用**。

- **如果不使用线程池：**  来一个任务 -> 创建线程 -> 运行 -> 销毁线程。频繁创建和销毁非常消耗 CPU 和内存资源。
- **使用线程池：**  线程池里的线程“整装待发”，来一个任务 -> 线程接单 -> 运行 -> 任务结束 -> **线程不销毁，回到池子等待下一个任务**。

---

### 1. 通过 Executors 创建线程池

Java 提供了 `java.util.concurrent.Executors` 工具类（也就是工厂类），可以快速创建三种常见的线程池。

虽然在生产环境中建议手动创建（见文末“避坑指南”），但在学习阶段，这是最快上手的方式。

#### 常见的三种类型：

1. ​**​`newFixedThreadPool(int nThreads)`​**

- **固定大小线程池**。
- 池子里只有 `nThreads` 个线程。如果任务多了，就放在队列里排队。
- **适用场景：**  执行长期的、负载较重的任务。

2. ​**​`newCachedThreadPool()`​**

- **可缓存线程池**。
- 线程数量不固定。如果你发了 100 个任务，它可能瞬间创建 100 个线程；如果任务执行完了，空闲线程会被回收。
- **适用场景：**  执行很多短期、主要耗时较小的任务。

3. ​**​`newSingleThreadExecutor()`​**

- **单线程化线程池**。
- 池子里只有 **1** 个线程。
- **适用场景：**  需要保证任务按顺序执行的场景。

---

### 2. 实战代码：创建与任务处理

我们用 `FixedThreadPool`​ 为例，演示如何处理 `Runnable`​ 和 `Callable` 任务。

#### 核心方法对比

|特性|​`execute()`|​`submit()`|
| ------| ----------------------| -------------------------------------------|
|**接收参数**|​`Runnable`|​`Runnable`​ 或 `Callable`|
|**返回值**|**void** (无返回值)|**Future** (返回异步结果对象)|
|**异常处理**|直接抛出，难以捕获|异常被封装在 Future 中，调用 get() 时抛出|
|**用途**|只要执行，不关心结果|需要结果，或需要捕获异常|

#### 完整代码演示

```java
import java.util.concurrent.*;

public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 1. 创建一个固定包含 3 个线程的线程池
        ExecutorService pool = Executors.newFixedThreadPool(3);

        try {
            // ==========================================
            // 场景一：处理 Runnable 任务 (没有返回值)
            // ==========================================
            Runnable runTask = () -> {
                System.out.println(Thread.currentThread().getName() + " [Runnable] 正在办理业务...");
                try { Thread.sleep(1000); } catch (InterruptedException e) {}
            };

            // 使用 execute 提交
            pool.execute(runTask);
            pool.execute(runTask);
            pool.execute(runTask);


            // ==========================================
            // 场景二：处理 Callable 任务 (有返回值)
            // ==========================================
            Callable<Integer> callTask = () -> {
                System.out.println(Thread.currentThread().getName() + " [Callable] 正在计算...");
                Thread.sleep(1000);
                return 1024; // 返回计算结果
            };

            // 使用 submit 提交，返回一个 Future 对象
            Future<Integer> future = pool.submit(callTask);

            // 获取结果（这一步是阻塞的，直到任务执行完）
            // 如果不想阻塞，可以使用 future.isDone() 轮询
            Integer result = future.get();
            System.out.println("Callable 计算结果：" + result);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭线程池
            // shutdown(): 不再接受新任务，但会把队列里已有的任务执行完
            pool.shutdown();
        }
    }
}

```

---

### ⚠️ 进阶：阿里巴巴开发手册的“避坑指南”

虽然 `Executors`​ 很方便，但在大厂（如阿里巴巴）的开发规范中，是 **禁止** 直接使用 `Executors` 创建线程池的。

**原因：**

1. ​`FixedThreadPool`​ 和 `SingleThreadExecutor`:

- 允许的**请求队列长度**为 `Integer.MAX_VALUE`。
- **风险：**  大量请求堆积，导致 **OOM (Out Of Memory)**  内存溢出。

2. ​`CachedThreadPool`:

- 允许的**创建线程数量**为 `Integer.MAX_VALUE`。
- **风险：**  创建大量线程，导致 CPU 100% 或 OOM。

**推荐方式：**   
直接使用底层构造函数 `ThreadPoolExecutor` 手动创建，明确指定 7 个核心参数（核心线程数、最大线程数、队列容量等），这样能让你更清楚地掌控系统的资源使用情况。

---

非常棒！这正是迈向**资深开发工程师**的必经之路。

手动创建线程池（即使用 `ThreadPoolExecutor`）虽然代码看起来复杂一点，但它能让你完全掌控线程池的行为，避免生产环境下的资源耗尽风险。

我们将这 **7 个核心参数** 比作一个  **“银行网点”**  的运营管理，这样你瞬间就能理解了。

---

### 1. 核心参数详解 (银行网点类比)

Java

```
public ThreadPoolExecutor(
    int corePoolSize,              // 1. 核心线程数
    int maximumPoolSize,           // 2. 最大线程数
    long keepAliveTime,            // 3. 空闲保持时间
    TimeUnit unit,                 // 4. 时间单位
    BlockingQueue<Runnable> workQueue, // 5. 任务队列
    ThreadFactory threadFactory,   // 6. 线程工厂
    RejectedExecutionHandler handler   // 7. 拒绝策略
) { ... }
```

|**参数名**|**含义**|**银行网点类比**||||
| --| --| --------------------------------------------------------------------------| --| --| --|
|**corePoolSize**|**核心线程数**|​**常驻柜员**。即使没人办业务，他们也在窗口坐着，随时待命。||||
|**workQueue**|**任务队列**|​**候客区（椅子）** 。常驻柜员忙不过来时，客户就在这里排队等待。||||
|**maximumPoolSize**|**最大线程数**|​**常驻柜员 + 临时柜员**。当候客区也坐满了，经理会临时多开几个窗口（招聘临时工）来应急。||||
|**keepAliveTime**|**空闲存活时间**|​**临时工的聘用期限**。如果临时柜员空闲了这么久还没人来，就辞退他们（节省成本）。||||
|**unit**|**时间单位**|毫秒、秒、分等。||||
|**threadFactory**|**线程工厂**|​**HR 部门**。负责招聘（创建）员工，通常用于给线程起个有意义的名字，方便查日志。||||
|**handler**|**拒绝策略**|​**保安**。当窗口全开、候客区也满了，再来人怎么办？保安负责拦人。||||

---

### 2. 线程池的工作流程 (核心逻辑)

这是面试中最常问的逻辑：**当一个任务提交进来，线程池是如何判断该由谁来执行的？**

**流程如下：**

1. **判断核心线程：**

   - 如果当前线程数 \< `corePoolSize`​，**立刻创建新线程**运行这个任务（哪怕有空闲线程）。
2. **判断队列：**

   - 如果核心线程满了，任务会被​**塞入** **​`workQueue`​**​ **排队**。
3. **判断最大线程：**

   - 如果队列也满了（椅子坐不下了），判断当前线程数是否 \< `maximumPoolSize`。
   - 如果是，**创建非核心线程（临时工）**  立刻运行这个新任务（注意：是抢着处理新任务，而不是处理队列里的老任务）。
4. **执行拒绝策略：**

   - 如果队列满了，且线程数也达到了 `maximumPoolSize`​（所有人都忙疯了），则触发 `handler`​ **拒绝策略**。

---

### 3. 四大拒绝策略 (Handler)

JDK 内置了 4 种策略，默认是 `AbortPolicy`。

1. **AbortPolicy (默认):**  直接抛出 `RejectedExecutionException` 异常。

   - *后果：*  调用者知道任务失败了，需要自己处理异常。
2. **CallerRunsPolicy (最推荐):**  “谁调用的，谁自己去跑”。由提交任务的线程（比如主线程）自己去执行这个任务。

   - *后果：*  既然主线程在干活，它就不能提交新任务了，从而降低了任务提交的速度（​**负反馈机制**），给线程池喘息的机会。
3. **DiscardPolicy:**  直接丢弃任务，不抛出异常。

   - *后果：*  任务静悄悄地消失了，风险很大。
4. **DiscardOldestPolicy:**  丢弃队列里等待最久的一个任务，然后把新任务加进去。

   - *后果：*  如果是排队系统，先来的人被踢走了，很不公平。

---

### 4. 配置技巧：线程数设多少合适？

参数配置没有标准答案，取决于你的​**任务类型**。

#### A. CPU 密集型任务 (CPU Bound)

- **特点：**  疯狂计算，如加密、解密、压缩、图像处理、复杂算法。
- **配置公式：**  `CPU 核数 + 1`
- **原理：**  CPU 一直在全速运转，多开线程只会增加上下文切换的开销，不仅不快，反而更慢。“+1” 是为了防止某个线程偶尔缺页中断或暂停，能有备胎顶上。

#### B. IO 密集型任务 (IO Bound) - **最常见**

- **特点：**  并不是一直在算，而是在等待。如：读写数据库、请求 Web 接口、读写文件。
- **配置公式：**  `CPU 核数 * 2` （或者更多）
- **原理：**  线程大部分时间都在“等”（阻塞），CPU 很闲。所以要多开几个线程，让 CPU 在 A 线程等待的时候去处理 B 线程。
- **进阶公式：**  `CPU 核数 / (1 - 阻塞系数)`

  - *阻塞系数* 一般在 0.8 \~ 0.9 之间。

---

### 5. 总结代码示例

Java

```
import java.util.concurrent.*;

public class MyThreadPoolDemo {
    public static void main(String[] args) {
        // 获取 CPU 核数
        int cpuCores = Runtime.getRuntime().availableProcessors();
        
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
            2,                          // 1. 核心线程数 (比如 2 个)
            5,                          // 2. 最大线程数 (最多 5 个)
            3,                          // 3. 空闲存活 3 秒
            TimeUnit.SECONDS,           // 4. 单位
            new LinkedBlockingDeque<>(3), // 5. 队列容量 (只能坐 3 人)
            Executors.defaultThreadFactory(), // 6. 默认工厂
            new ThreadPoolExecutor.AbortPolicy() // 7. 拒绝策略：抛异常
        );

        try {
            // 模拟提交 10 个任务
            for (int i = 1; i <= 10; i++) {
                final int tempInt = i;
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + " 处理任务 " + tempInt);
                    try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
```

**思考题：**

在上面的代码中，最大线程数是 5，队列容量是 3。

如果我一次性提交 ​**9 个任务**，会发生什么？

1. 核心线程接 2 个。
2. 队列存 3 个。
3. 救急线程接 3 个（达到最大 5）。
4. **第 9 个任务会被拒绝（抛异常）！**

---

# 并发与并行：

> **并发 (Concurrency) 是逻辑上的同时发生（通过快速切换），而并行 (Parallelism) 是物理上的同时发生（真正的同时）。**

---

### 1. 生活化的类比（秒懂）

为了让你彻底理解，我们用  **“吃午饭”**  和  **“排队”**  来举例。

#### 场景 A：并发 (Concurrency) —— 一个人干多件事

你只有 ​**一张嘴**（单核 CPU）。

但在午饭时，你想 **吃包子** 同时也想 ​**喝可乐**。

- 你咬一口包子。
- 放下包子，喝一口可乐。
- 放下可乐，再咬一口包子。
- **宏观上：**  你的朋友看你，觉得你“在吃早饭的同时也在喝可乐”。
- **微观上：**  你的嘴在任意一个​**瞬间**，要么在吃包子，要么在喝可乐，不能同时进行。
- **关键点：**  靠的是​**快速切换**。

#### 场景 B：并行 (Parallelism) —— 多个人干多件事

现在有 ​**两个人**：你和你的朋友（多核 CPU）。

- 你在吃包子。
- 你的朋友在喝可乐。
- **宏观上：**  你们在同时进行。
- **微观上：**  在任意一个瞬间，这两个动作都在​**真正地同时发生**。
- **关键点：**  靠的是​**多核硬件支持**。

---

### 2. 技术层面的对比

|**特性**|**并发 (Concurrency)**|**并行 (Parallelism)**||||
| --| ---------------------------------------------------------------------| --------------------------------------------------| --| --| --|
|**核心定义**|多个任务在**同一个时间段**内交替执行。|多个任务在**同一个时刻**同时执行。||||
|**CPU 需求**|**单核**或多核都可以实现。|**必须多核**CPU 才能实现。||||
|**实现方式**|​**时间片轮转**（Context Switching）。CPU 像个多动症一样，飞快地在任务间切换。|​**多条流水线**。CPU 的不同核心各自负责一个任务，互不干扰。||||
|**侧重点**|侧重于​**结构**（如何设计程序以处理多个任务）。|侧重于​**执行**（如何利用硬件同时跑多个任务）。||||
|**吞吐量**|取决于切换速度和任务阻塞情况。|理论上是单核的 N 倍（N\=核数）。||||

---

### 3. 深入理解：为什么单核也能“多线程”？

你可能会问： *“我的老电脑是单核的，为什么也能一边听歌一边打字？”*

这就是 **并发** 的魔力。

操作系统引入了 **时间片（Time Slice）**  的概念。它把 CPU 的执行时间切成无数个极短的片段（比如 10 毫秒）。

1. **0ms - 10ms:**  CPU 运行音乐播放器（加载数据）。
2. **10ms - 20ms:**  CPU 切换到文档编辑器（处理你的按键）。
3. **20ms - 30ms:**  CPU 切回音乐播放器（解码音频）。

因为切换速度太快（毫秒级），人类的感官根本察觉不到停顿，产生了一种“同时都在运行”的​**错觉**。

---

### 4. Java 中的并发与并行

在 Java 开发中，我们通常说“并发编程”，是因为我们主要关注的是​**如何设计线程安全的代码**，而不是关注 CPU 到底怎么跑。

- **当我们写** **​`new Thread().start()`​** ​ **时：**  我们是在告诉操作系统，“我想要并发地执行这个任务”。
- **操作系统怎么做：**

  - 如果你的机器是​**单核**​：操作系统会用​**并发**（时间片轮转）来运行它。
  - 如果你的机器是​**多核**​：操作系统会尽量用​**并行**（分配给不同核心）来运行它，如果任务太多，核心不够用，再结合并发。

### 总结

- **并发**是关于  **“应对” (Dealing with)**  多件事。
- **并行**是关于  **“做” (Doing)**  多件事。
- **并发**是**逻辑**上的同时。
- **并行**是**物理**上的同时。

**理解了这个，你就明白为什么会有“线程安全”问题了：无论是并发的“切换”还是并行的“同时”，都会导致多个线程争抢同一个资源。**

---

# 小案例：

```java
package com.feng.duoxiancheng.demo1;

import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;

public class PepoleThread implements Callable {
    private List<Integer> list;
    public PepoleThread(List<Integer> list, String name){
        this.list = list;}
    @Override
    public Object call() throws Exception {
        while (true){
            synchronized (list) {
                if (list.size() == 0) {
                    break;//竞争到锁，没钱直接挂掉
                }
                //随机取走一个红包
                int index = new Random().nextInt(list.size());
                Integer s = list.remove(index);
                System.out.println(Thread.currentThread().getName() + "取走了" + s + "$");
                if (list.size() == 0) {
                    System.out.println("红包发完了");
            }
//模拟网络延迟,抢完让线程睡眠1秒
                Thread.sleep(1000);
        }


    }

        return list;
    };
    }

```

‍

‍

```java
package com.feng.duoxiancheng.demo1;

import sun.font.FontRunIterator;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.FutureTask;

public class TheeradTest {
    public static void main(String[] args) {
    List <Integer> redList = new TheeradTest().redList();

    // 创建3个线程，模拟3个抢红包的线程
    for (int i = 0; i < 3; i++) {
        //futuretask包装线程
        FutureTask futureTask =new FutureTask<> (new PepoleThread(redList, "线程" + i));
       new Thread(futureTask).start();
    }

    }
    //准备200个红包，存入list
    public List<Integer> redList(){
    List<Integer> redList = new ArrayList<>();
    for (int i = 0; i < 200; i++) {
        Random random = new Random();
        redList.add(random.nextInt(100)+1); // 确保红包金额至少为1,最大为100
    }
    return redList;
    }
}


```
