---
title: day35
date: '2026-02-20 20:12:27'
updated: '2026-02-20 20:18:06'
permalink: /post/day35-ghujb.html
comments: true
toc: true
---



# day35

# 动态规划：01背包理论基础

本题力扣上没有原题，大家可以去[卡码网第46题 (opens new window)](https://kamacoder.com/problempage.php?pid=1046)去练习，题意是一样的。

## [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)算法公开课

​**[《代码随想录》算法视频公开课 (opens new window)](https://programmercarl.com/other/gongkaike.html)**​ **：**​**[带你学透0-1背包问题！ (opens new window)](https://www.bilibili.com/video/BV1cg411g7Y6/)**​ **，相信结合视频再看本篇题解，更有助于大家对本题的理解**。

## [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E6%80%9D%E8%B7%AF)思路

正式开始讲解背包问题！

对于面试的话，其实掌握01背包和完全背包，就够用了，最多可以再来一个多重背包。

如果这几种背包，分不清，我这里画了一个图，如下：

![416.分割等和子集1](https://file1.kamacoder.com/i/algo/20210117171307407.png)

除此以外其他类型的背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。

而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。

​**所以背包问题的理论基础重中之重是01背包，一定要理解透**！

leetcode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。

​**所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了**。

之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！

### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85)01 背包

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。​**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。

这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？

每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2\^n)，这里的n表示物品数量。

**所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！**

在下面的讲解中，我举一个例子：

背包最大重量为4。

物品为：

||重量|价值|
| -------| ------| ------|
|物品0|1|15|
|物品1|3|20|
|物品2|4|30|

问背包能背的物品最大价值是多少？

以下讲解和图示中出现的数字都是以这个例子为例。

（为了方便表述，下面描述 统一用 容量为XX的背包，放下容量（重量）为XX的物品，物品的价值是XX）

### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85)二维dp数组01背包

依然动规五部曲分析一波。

#### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_1-%E7%A1%AE%E5%AE%9Adp%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E4%B8%8B%E6%A0%87%E7%9A%84%E5%90%AB%E4%B9%89)1. 确定dp数组以及下标的含义

我们需要使用二维数组，为什么呢？

因为有两个维度需要分别表示：物品 和 背包容量

如图，二维数组为 dp[i][j]。

![动态规划-背包问题1](https://file1.kamacoder.com/i/algo/20210110103003361.png)

那么这里 i 、j、dp[i][j] 分别表示什么呢？

i 来表示物品、j表示背包容量。

（如果想用j 表示物品，i 表示背包容量 行不行？ 都可以的，个人习惯而已）

我们来尝试把上面的 二维表格填写一下。

动态规划的思路是根据子问题的求解推导出整体的最优解。

我们先看把物品0 放入背包的情况：

![](https://file1.kamacoder.com/i/algo/20240730113455.png)

背包容量为0，放不下物品0，此时背包里的价值为0。

背包容量为1，可以放下物品0，此时背包里的价值为15.

背包容量为2，依然可以放下物品0 （注意 01背包里物品只有一个），此时背包里的价值为15。

以此类推。

再看把物品1 放入背包：

![](https://file1.kamacoder.com/i/algo/20240730114228.png)

背包容量为 0，放不下物品0 或者物品1，此时背包里的价值为0。

背包容量为 1，只能放下物品0，背包里的价值为15。

背包容量为 2，只能放下物品0，背包里的价值为15。

背包容量为 3，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放物品1 或者 物品0，物品1价值更大，背包里的价值为20。

背包容量为 4，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放下物品0 和 物品1，背包价值为35。

以上举例，是比较容易看懂，我主要是通过这个例子，来帮助大家明确dp数组的含义。

上图中，我们看 dp[1][4] 表示什么意思呢。

任取 物品0，物品1 放进容量为4的背包里，最大价值是 dp[1][4]。

通过这个举例，我们来进一步明确dp数组的含义。

即​**dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

​**要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的**，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。

#### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_2-%E7%A1%AE%E5%AE%9A%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F)2. 确定递推公式

这里在把基本信息给出来：

||重量|价值|
| -------| ------| ------|
|物品0|1|15|
|物品1|3|20|
|物品2|4|30|

对于递推公式，首先我们要明确有哪些方向可以推导出 dp[i][j]。

这里我们dp[1][4]的状态来举例：

求取 dp[1][4] 有两种情况：

1. 放物品1
2. 还是不放物品1

如果不放物品1， 那么背包的价值应该是 dp[0][4] 即 容量为4的背包，只放物品0的情况。

推导方向如图：

![](https://file1.kamacoder.com/i/algo/20240730174246.png)

如果放物品1， ​**那么背包要先留出物品1的容量**，目前容量是4，物品1 的容量（就是物品1的重量）为3，此时背包剩下容量为1。

容量为1，只考虑放物品0 的最大价值是 dp[0][1]，这个值我们之前就计算过。

所以 放物品1 的情况 \= dp[0][1] + 物品1 的价值，推导方向如图：

![](https://file1.kamacoder.com/i/algo/20240730174436.png)

两种情况，分别是放物品1 和 不放物品1，我们要取最大值（毕竟求的是最大价值）

​`dp[1][4] = max(dp[0][4], dp[0][1] + 物品1 的价值)`

以上过程，抽象化如下：

- ​**不放物品i**：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。
- ​**放物品i**：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

#### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_3-dp%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96)3. dp数组如何初始化

​**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：

![动态规划-背包问题2](https://file1.kamacoder.com/i/algo/2021011010304192.png)

在看其他情况。

状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 `j < weight[0]`的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。

当`j >= weight[0]`时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。

代码初始化如下：

```cpp
for (int i = 1; i < weight.size(); i++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[i][0] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

此时dp数组初始化情况如图所示：

![动态规划-背包问题7](https://file1.kamacoder.com/i/algo/20210110103109140.png)

dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？

其实从递归公式： dp[i][j] \= max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。

**初始-1，初始-2，初始100，都可以！**

但只不过一开始就统一把dp数组统一初始为0，更方便一些。

如图：

![动态规划-背包问题10](https://file1.kamacoder.com/i/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)

最后初始化代码如下：

```cpp
// 初始化 dp
vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}

```

​**费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的**。

#### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_4-%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F)4. 确定遍历顺序

在如下图中，可以看出，有两个遍历的维度：物品与背包重量

![动态规划-背包问题3](https://file1.kamacoder.com/i/algo/2021011010314055.png)

那么问题来了，**先遍历 物品还是先遍历背包重量呢？**

​**其实都可以！！ 但是先遍历物品更好理解**。

那么我先给出先遍历物品，然后遍历背包重量的代码。

```cpp
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

**先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）**

例如这样：

```cpp
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

为什么也是可以的呢？

​**要理解递归的本质和递推的方向**。

​`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。

dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：

![动态规划-背包问题5](https://file1.kamacoder.com/i/algo/202101101032124.png)

再来看看先遍历背包，再遍历物品呢，如图：

![动态规划-背包问题6](https://file1.kamacoder.com/i/algo/20210110103244701.png)

**大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！**

但先遍历物品再遍历背包这个顺序更好理解。

​**其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了**。

#### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_5-%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BCdp%E6%95%B0%E7%BB%84)5. 举例推导dp数组

来看一下对应的dp数组的数值，如图：

![动态规划-背包问题4](https://file1.kamacoder.com/i/algo/20210118163425129.jpg)

最终结果就是dp[2][4]。

建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。

**做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！**

很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。

主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。

本题力扣上没有原题，大家可以去[卡码网第46题 (opens new window)](https://kamacoder.com/problempage.php?pid=1046)去练习，题意是一样的，代码如下：

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int bagweight = scanner.nextInt();

        int[] weight = new int[n];
        int[] value = new int[n];

        for (int i = 0; i < n; ++i) {
            weight[i] = scanner.nextInt();
        }
        for (int j = 0; j < n; ++j) {
            value[j] = scanner.nextInt();
        }

        int[][] dp = new int[n][bagweight + 1];

        for (int j = weight[0]; j <= bagweight; j++) {
            dp[0][j] = value[0];
        }

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= bagweight; j++) {
                if (j < weight[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
                }
            }
        }

        System.out.println(dp[n - 1][bagweight]);
    }
}

```

- 这是一段非常标准的 **0-1 背包问题 (0/1 Knapsack Problem)**  的经典动态规划解法。你使用了自底向上的二维数组来实现，逻辑非常清晰，是学习背包问题最完美的起点。

  下面我为你详细拆解这段代码的运作原理，看看它是如何一步步计算出最大价值的。

  ---

  ### 代码逻辑拆解

  0-1 背包的核心在于“选”与“不选”：对于每个物品，我们要么不把它装进背包（0），要么把它装进背包（1），目标是在不超过背包容量的前提下让总价值最大。

  1. **状态定义 (**​**​`dp`​**​ **数组的含义)** ：  
     你创建了一个二维数组 `dp[n][bagweight + 1]`。

  - ​`dp[i][j]`​ 代表的含义是：从下标为 `0`​ 到 `i`​ 的物品中任意取，放进容量为 `j`​ 的背包里，能得到的**最大价值**。

  2. **初始化 (打好地基)** ：

  ```java
  for (int j = weight[0]; j <= bagweight; j++) {
      dp[0][j] = value[0];
  }

  ```

  这里是在初始化第一行（只考虑第 0 个物品）。如果背包容量 `j`​ 大于等于第 0 个物品的重量 `weight[0]`​，那么就可以把它装进去，此时背包里的最大价值就是 `value[0]`​。  
  3. **状态转移方程 (核心推导)** ：  
  代码中的双重循环逐个评估每个物品和每种容量。对于物品 `i`​ 和当前容量 `j`，有两种情况：

  - **装不下**：如果当前容量 `j < weight[i]`，根本放不进去。那么最大价值只能和不放这个物品时一样：
  - **装得下**：如果放得下，我们就面临一个选择：是**不放**它划算，还是**腾出空间放它**划算？我们取两者的最大值：
  - ​`dp[i - 1][j]`：不选当前物品。
  - ​`dp[i - 1][j - weight[i]] + value[i]`：选当前物品（先从背包扣除它的重量，加上它的价值，再看剩余容量能装多少最大价值）。

  ---

  ### 性能分析

  |维度|复杂度|说明|
  | ------| --------| ------------------------------------------|
  |**时间复杂度**||嵌套的双重循环遍历了物品数量和背包容量。|
  |**空间复杂度**||使用了一个二维数组来存储状态。|

  ---

  ### 💡 进阶：空间优化（一维滚动数组）

  和上一道“不同路径”的题目非常相似，在这段代码中，你在计算第 `i`​ 行的 `dp`​ 值时，实际上**只用到了第** **​`i-1`​**​ **行**的数据。这意味着我们完全不需要保留所有的历史记录。

  通过巧妙的设计，我们可以将二维的 `dp[i][j]`​ 压缩成一维的 `dp[j]`​，从而将空间复杂度从  大幅度降至 。**但这里有一个非常重要的陷阱**：在使用一维数组时，内层遍历背包容量 `j`​ 的循环必须**倒序遍历**，否则会导致同一个物品被重复放入（那就变成“完全背包”问题了）。

  **需要我为你演示如何将这段代码精简为使用一维数组的  空间复杂度版本，并详细解释“倒序遍历”的原理吗？**

‍

---

# 动态规划：01背包理论基础（滚动数组）

本题力扣上没有原题，大家可以去[卡码网第46题 (opens new window)](https://kamacoder.com/problempage.php?pid=1046)去练习

## [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)算法公开课

​**[《代码随想录》算法视频公开课 (opens new window)](https://programmercarl.com/other/gongkaike.html)**​ **：**​**[带你学透0-1背包问题！（滚动数组） (opens new window)](https://www.bilibili.com/video/BV1BU4y177kY/)**​ **，相信结合视频再看本篇题解，更有助于大家对本题的理解**。

## [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E6%80%9D%E8%B7%AF)思路

昨天[动态规划：关于01背包问题，你该了解这些！ (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)中是用二维dp数组来讲解01背包。

今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。

那么我们通过01背包，来彻底讲一讲滚动数组！

接下来还是用如下这个例子来进行讲解

背包最大重量为4。

物品为：

||重量|价值|
| -------| ------| ------|
|物品0|1|15|
|物品1|3|20|
|物品2|4|30|

问背包能背的物品最大价值是多少？

### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84)一维dp数组（滚动数组）

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：dp[i][j] \= max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j]**   **=**  **max(dp[i][j], dp[i][j - weight[i]] + value[i]);**

​**与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了**，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。

​**dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

一定要时刻记住这里i和j的含义，要不然很容易看懵了。

动规五部曲分析如下：

1. 确定dp数组的定义

关于dp数组的定义，我在 [01背包理论基础 (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)有详细讲解

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

2. 一维dp数组的递推公式

二维dp数组的递推公式为： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

公式是怎么来的 在这里 [01背包理论基础 (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)有详细讲解。

一维dp数组，其实就上上一层 dp[i-1] 这一层 拷贝的 dp[i]来。

所以在 上面递推公式的基础上，去掉i这个维度就好。

递推公式为：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`

以下为分析：

dp[j]为 容量为j的背包所背的最大价值。

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

​`dp[j - weight[i]] + value[i]` 表示 容量为 [j - 物品i重量] 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取`dp[j - weight[i]] + value[i]`，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

```text
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。

3. 一维dp数组如何初始化

​**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

看一下递归公式：dp[j] \= max(dp[j], dp[j - weight[i]] + value[i]);

dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。

​**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

4. 一维dp数组遍历顺序

代码如下：

```text
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！**

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

为什么呢？

​**倒序遍历是为了保证物品i只被放入一次！** 。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

举一个例子：物品0的重量weight[0] \= 1，价值value[0] \= 15

如果正序遍历

dp[1] \= dp[1 - weight[0]] + value[0] \= 15

dp[2] \= dp[2 - weight[0]] + value[0] \= 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算dp[2]

dp[2] \= dp[2 - weight[0]] + value[0] \= 15 （dp数组已经都初始化为0）

dp[1] \= dp[1 - weight[0]] + value[0] \= 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

**那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？**

因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！

（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）

**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

​**所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！** ，这一点大家一定要注意。

5. 举例推导dp数组

一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：

![动态规划-背包问题9](https://file1.kamacoder.com/i/algo/20210110103614769.png)

本题力扣上没有原题，大家可以去[卡码网第46题 (opens new window)](https://kamacoder.com/problempage.php?pid=1046)去练习，题意是一样的，代码如下：

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取 M 和 N
        int M = scanner.nextInt();  // 研究材料的数量
        int N = scanner.nextInt();  // 行李空间的大小

        int[] costs = new int[M];   // 每种材料的空间占用
        int[] values = new int[M];  // 每种材料的价值

        // 输入每种材料的空间占用
        for (int i = 0; i < M; i++) {
            costs[i] = scanner.nextInt();
        }

        // 输入每种材料的价值
        for (int j = 0; j < M; j++) {
            values[j] = scanner.nextInt();
        }

        // 创建一个动态规划数组 dp，初始值为 0
        int[] dp = new int[N + 1];

        // 外层循环遍历每个类型的研究材料
        for (int i = 0; i < M; i++) {
            // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
            for (int j = N; j >= costs[i]; j--) {
                // 考虑当前研究材料选择和不选择的情况，选择最大值
                dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
            }
        }

        // 输出 dp[N]，即在给定 N 行李空间可以携带的研究材料的最大价值
        System.out.println(dp[N]);

        scanner.close();
    }
}

```

- 太棒了！这正是我们在上一步提到的 **一维滚动数组（空间优化）**  版本的 0-1 背包解法。你不仅直接写出来了，而且逻辑非常清晰、标准。

  通过只使用一个一维数组 `dp[N + 1]`，你成功地将空间复杂度从二维的  骤降到了 。

  下面我为你重点拆解这段代码中最核心、也最容易踩坑的“魔法”——**倒序遍历**。

  ---

  ### 核心拆解：为什么必须倒序？

  在你的代码中，最关键的一行是内层循环：

  ```java
  for (int j = N; j >= costs[i]; j--) { ... }

  ```

  在这个一维数组中，`dp[j]` 的状态转移方程是：

  这看起来和二维版本很像，但运作机制完全不同。我们需要确保在计算当前物品（第 `i`​ 个物品）时，利用的仍然是**上一个物品**（第 `i-1` 个物品）的状态。

  - **如果正序遍历 (从小到大** **​`j = costs[i] -> N`​**​ **)** ：  
    当我们计算容量较大的 `dp[j]`​ 时，它需要用到容量较小的 `dp[j - costs[i]]`​。因为我们是正序遍历，此时较小的 `dp[j - costs[i]]`​ 可能在**同一轮循环中已经被当前物品更新过了**。这就导致一个物品可能会被重复放入背包多次。
  - **如果倒序遍历 (从大到小** **​`j = N -> costs[i]`​** ​ **)** ：  
    当我们计算容量较大的 `dp[j]`​ 时，它所依赖的较小容量 `dp[j - costs[i]]`​ **还没有被当前物品更新过**。它里面存储的依然是上一轮（上一个物品）留下的“历史遗留数据”。这完美地模拟了二维数组中“只依赖上一行状态”的逻辑，确保了**每个物品最多只被放入一次**。

  ---

  ### 性能表现

  |维度|复杂度|优化效果|
  | ------| --------| ---------------------------------------------------------------------|
  |**时间复杂度**||与二维版本相同，依然需要遍历所有物品和容量的组合。|
  |**空间复杂度**||**极致压缩！**  仅用一个长度为  的数组，极大减少了内存占用，是面试中的终极加分项。|

  ---

  既然我们刚刚提到，如果把内层循环改为**正序遍历**，会导致“同一个物品被放入多次”——这其实恰巧就是另一种经典的动态规划题型：**完全背包问题 (Complete Knapsack Problem)** ，也就是每种物品有无限个可以取。

  **你想看看完全背包问题的具体场景，或者尝试用这段代码稍微变型来解决完全背包问题吗？**

可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。

**所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！**

**在后面背包问题的讲解中，我都直接使用一维dp数组来进行推导**。

## 总结

以上的讲解可以开发一道面试题目（毕竟力扣上没原题）。

就是本文中的题目，要求先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。

然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？

注意以上问题都是在候选人把代码写出来的情况下才问的。

就是纯01背包的题目，都不用考01背包应用类的题目就可以看出候选人对算法的理解程度了。

**相信大家读完这篇文章，应该对以上问题都有了答案！**

此时01背包理论基础就讲完了，我用了两篇文章把01背包的dp数组定义、递推公式、初始化、遍历顺序从二维数组到一维数组统统深度剖析了一遍，没有放过任何难点。

大家可以发现其实信息量还是挺大的。

如果把[动态规划：关于01背包问题，你该了解这些！ (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)和本篇的内容都理解了，后面我们在做01背包的题目，就会发现非常简单了。

不用再凭感觉或者记忆去写背包，而是有自己的思考，了解其本质，代码的方方面面都在自己的掌控之中。

即使代码没有通过，也会有自己的逻辑去debug，这样就思维清晰了

---

# 416. 分割等和子集

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int s = 0;
        for (int num : nums) {
            s += num;
        }
        if (s % 2 != 0) {
            return false;
        }

        int n = nums.length;
        int[][] memo = new int[n][s / 2 + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -1); // -1 表示没有计算过
        }

        return dfs(n - 1, s / 2, nums, memo);
    }

    private boolean dfs(int i, int j, int[] nums, int[][] memo) {
        if (i < 0) {
            return j == 0;
        }
        if (memo[i][j] != -1) { // 之前计算过
            return memo[i][j] == 1;
        }
        boolean res;
        if (j < nums[i]) {
            res = dfs(i - 1, j, nums, memo); // 只能不选
        } else {
            res = dfs(i - 1, j - nums[i], nums, memo) || dfs(i - 1, j, nums, memo); // 选或不选
        }
        memo[i][j] = res ? 1 : 0; // 记忆化
        return res;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/partition-equal-subset-sum/solutions/2785266/0-1-bei-bao-cong-ji-yi-hua-sou-suo-dao-d-ev76/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这又是一道极具代表性的题目！这道“分割等和子集”是把我们刚刚讨论的 **0-1 背包问题** 穿上了一层巧妙的伪装。

  你提供的这段代码使用了**自顶向下的记忆化搜索 (DFS + Memoization)** ，完美地扒下了这道题的伪装。逻辑一如既往的严谨！

  下面我为你拆解它是如何将“分割数组”巧妙地转化为“0-1 背包”的。

  ---

  ### 核心拆解：问题转换的艺术

  这道题表面上是问“能不能把数组分成和相等的两半”，实际上是在问：**能不能从数组中挑出几个数字，让它们的和恰好等于整个数组总和的一半？**

  一旦想通了这一点，它就变成了一个彻头彻尾的 0-1 背包问题：

  - **背包容量**：数组总和的一半，即 。
  - **物品**：数组中的每个数字 `nums[i]`。
  - **物品的重量（和价值）** ：数字本身的大小。
  - **目标**：能否把这个背包**恰好装满**。

  ### 代码亮点分析

  1. **绝妙的剪枝 (Early Exit)** ：

  ```java
  if (s % 2 != 0) return false;

  ```

  如果数组总和是奇数，无论如何都不可能平分成两个整数，直接返回 `false`​。这一步极其关键，排除了大量无效计算。  
  2. **​`int[][] memo`​**​ **的巧妙运用**：  
  由于 Java 中的 `boolean`​ 默认值是 `false`​，如果我们用 `boolean[][]`​，当遇到 `false`​ 时，程序无法分辨“这个状态是还没计算过”还是“计算过了且结果是不行”。  
  你使用 `int[][]`​ 并在初始化时填满 `-1`​（代表未计算），然后用 `1`​ 代表 `true`​，`0`​ 代表 `false`​，完美地解决了这个状态判定的问题。  
  3. **状态转移方程 (选或不选)** ：

  对于当前数字 `nums[i]`​，我们要么不把它放入背包（目标容量 `j`​ 不变），要么放入背包（目标容量减去 `nums[i]`​）。只要这两条路中**有一条**能走通（即返回 `true`），当前状态就成立。

  ---

  ### 性能表现

  |维度|复杂度|说明|
  | ------| --------| -------------------------------------------------------------------|
  |**时间复杂度**||是数组长度， 是数组元素总和。最坏情况下会计算所有的 `(i, j)` 状态组合。|
  |**空间复杂度**||​`memo` 数组所占用的空间，以及递归调用栈的最大深度 。|

  ---

  ### 下一步

  我们刚才在上一题里详细探讨了如何利用**一维滚动数组**和**倒序遍历**将 0-1 背包的空间压缩到极致。这道题既然是 0-1 背包的变种，自然也能享受这个优化魔法。

  **你想看看如何将这段递归代码，直接重构为只有几行核心逻辑、空间复杂度仅为  的自底向上（迭代）版本吗？**

‍
