---
title: day06
date: '2026-01-06 18:29:03'
updated: '2026-01-06 19:43:02'
permalink: /post/day06-cntxu.html
comments: true
toc: true
---



# day06

# **第三章 哈希表part01**

## ** 今日任务 **

●  哈希表理论基础

●  242.有效的字母异位词

●  349. 两个数组的交集

●  202. 快乐数

●  1. 两数之和

##  详细布置

###  哈希表理论基础

建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。

什么时候想到用哈希法，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。  这句话很重要，大家在做哈希表题目都要思考这句话。

文章讲解：<u>[https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)</u>

###  242.有效的字母异位词

建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。

[题目链接/文章讲解/视频讲解： ]()​<u>[https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html](https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html)</u>

###  349. 两个数组的交集

建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 <\<=\= nums1[i], nums2[i] <\<=\= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。

[题目链接/文章讲解/视频讲解：]()​<u>[https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html](https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html)</u>

### 202. 快乐数

建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子

[题目链接/文章讲解：]()​<u>[https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html](https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html)</u>

### 1. 两数之和

建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。

建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。

[题目链接/文章讲解/视频讲解：]()​<u>[https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html)</u>

‍

# 242.有效的字母异位词

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)

- 哈希表本质上是通过数组存储的，在底层通过哈希函数将我的值唯一映射到数组当中，直接存储到对应内存数组中对应的位置。

- 本题主要用来熟悉一下哈希表的操作；

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int len1 = s.length();
        int len2 = t.length();
        if(len1!=len2){
            return false;
        }
        HashMap<Character,Integer> dic =new HashMap<>();//哈希表的创建，注意泛型中需要的是object类型，也就是封装好的包装类；这里的character是cahr的包装类
        for (int i =0 ;i<len1;i++){
            dic.put(s.charAt(i),dic.getOrDefault(s.charAt(i),0)+1);//维护一个哈希表，将s字符串中的第i个位置的值传入hashmap，并且通过getOrDefault函数获取
//他的值，如果找到了，返回它现在的次数；没找到，返回 0。
        }
        for (int i=0; i<len2;i++){
            dic.put(t.charAt(i),dic.getOrDefault(t.charAt(i),0)-1);
        }//同理存入，dic.put(Key, Value)：一个key和一个value，注意这里的key是字符，value是数值，去覆盖我原来的值，如果原来有值应该是1，此时就会变0，
//如果未命中则同样会置0.最后，检查哈希表里所有的数字。

//如果两个单词真的是异位词，那么加多少次就应该减多少次，所有字母的计数最终都应该是 0。

//如果哪怕有一个数字不是 0，说明两个单词的字母对不上，返回 false。
        for(int val :dic.values()){
            if(val!=0)
                return false;
        }
        return true;
    }
}
```

### 349. 两个数组的交集

[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/solutions/3053420/yi-ci-bian-li-pythonjavacgojsrust-by-end-jstx/)

```java
// 更简洁的写法见右边的【Java Stream】
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> st = new HashSet<>();
        for (int x : nums1) {
            st.add(x);
        }

        List<Integer> lst = new ArrayList<>();
        for (int x : nums2) {
            if (st.remove(x)) { // x 在 st 中
                lst.add(x);
            }
        }

        // 由于返回值是 int[]，需要额外遍历一次
        int[] ans = new int[lst.size()];
        for (int i = 0; i < lst.size(); i++) {
            ans[i] = lst.get(i);
        }
        return ans;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/intersection-of-two-arrays/solutions/3053420/yi-ci-bian-li-pythonjavacgojsrust-by-end-jstx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# AI总结

- 后面再来补吧，没办法了
- 你好！这次你带来的是一道经典的\*\*“求交集”\*\*（Intersection）问题，代码来自 LeetCode 的大神“灵茶山艾府”。

  这段代码非常精炼，而且引入了 Java 中两个全新的、极其重要的数据结构：**​`Set`​**​  **(集合)**  和 ​**​`List`​**​  **(列表)** 。

  我们还是分两步走：先看​**思路逻辑**​，再拆解​**语法细节**。

  ---

  ## 1. 核心解题思路：消消乐法

  这道题的目标是：找出两个数组 nums1 和 nums2 中都有的数字，而且结果里的数字不能重复。

  比如：nums1 \= [1, 2, 2, 1], nums2 \= [2, 2], 结果应该是 [2]。Shutterstock

  这段代码用了一种很聪明的\*\*“消消乐”\*\*策略：

  1. 去重存入（第一步）：  
     把 nums1 里的所有数字扔进一个叫 Set（集合）的容器里。Set 有个神奇的特性：它不接受重复元素。

     - ​*效果*​：如果 `nums1`​ 是 `[1, 2, 2, 1]`​，扔进 `Set`​ 后，里面只有 `{1, 2}`。
  2. 查找并移除（第二步）：  
     遍历 nums2，拿每一个数字去 Set 里“碰一碰”。

     - 这里的**核心技巧**是 `st.remove(x)`​：它尝试从 `Set`​ 中**删除**这个数字。
     - 如果删除成功（说明 `Set`​ 里有这个数），那就把这个数记下来放到结果列表 `lst` 里。
     - 如果删除失败（说明 `Set` 里没这个数，或者已经被删过了），就忽略。

     > 为什么要“删除”？
     >
     > 假设 nums2 也有两个 2。
     >

     > - 遇到第一个 `2`​：在 `Set`​ 里找到了，​**删除它**，记入结果。
     > - 遇到第二个 `2`​：去 `Set`​ 里找，发现已经被刚才那一步删掉了，​**找不到**，跳过。
     > - 这样就完美保证了结果里的 `2`​ **只会出现一次**！
     >
  3. 搬运结果（第三步）：  
     把结果列表 lst 里的数字，搬运到一个普通的数组 int[] 里返回（这是为了满足题目要求的返回格式）。

  ---

  ## 2. Java 语法详细拆解

  这里有几个新面孔，我们逐个认识：

  ### (1) `Set`​ 和 `HashSet`

  Java

  ```
  Set<Integer> st = new HashSet<>();
  ```

  - ​**​`Set`​**​  **(接口)** ​：它是一个规则，规定了“这里面的东西​**是无序的**​，且​**绝对不能重复**”。
  - ​**​`HashSet`​**​  **(实现类)** ​：它是 `Set`​ 规则的一种具体实现。它的底层其实就是你刚才学的 `HashMap`！

    - 你可以把它理解为：​**只有 Key，没有 Value 的 HashMap**。
  - ​ **​`<Integer>`​** ：还是那个泛型规则，里面只能装整数对象（包装类）。

  ### (2) `List`​ 和 `ArrayList`

  Java

  ```
  List<Integer> lst = new ArrayList<>();
  ```

  - ​**​`List`​**​  **(接口)** ​：它对应我们生活中的“排队列表”。里面的东西​**是有序的**​（先来后到），而且​**允许重复**。
  - ​**​`ArrayList`​**​  **(实现类)** ​：一种​**动态数组**。

    - ​*普通数组* *​`int[]`​* ：长度是死的，一开始说好是 10 个就只能装 10 个。
    - ​*​`ArrayList`​*：长度是活的。你想加多少个都可以，它会自动扩容。因为我们一开始不知道交集有几个数，所以必须用它来暂存结果。

  ### (3) 核心逻辑 `if (st.remove(x))`

  Java

  ```
  if (st.remove(x)) { ... }
  ```

  这是一个非常高效率的写法，它一箭双雕：

  1. ​**动作**​：尝试从 `st`​ 中把 `x` 删掉。
  2. ​**判断**：

     - 如果删掉了（说明本来里面有）：返回 `true`​ -\> 进入 `if`​ -\> 加入结果列表。
     - 如果没得删（说明本来就没有，或者已经被删了）：返回 `false`​ -\> 跳过。

  这比写 `if (st.contains(x))` 然后再手动去重更省事。

  ### (4) 最后的“笨办法”转换

  Java

  ```
  int[] ans = new int[lst.size()];
  for (int i = 0; i < lst.size(); i++) {
      ans[i] = lst.get(i);
  }
  ```

  - 为什么要做这一步？  
    题目要求返回 int[]（基本类型数组），但我们刚才用的是 ArrayList\<Integer\>（对象列表）。Java 不允许直接把列表变成基本类型数组，所以必须：

    1. 建一个长度刚好的新数组 `ans`。
    2. 用 `for` 循环一个个把数据搬进去。
  - ​**​`lst.get(i)`​** ​：获取列表中第 `i`​ 个位置的数据（类似于数组的 `arr[i]`）。

  ---

  ## 3. 总结对比

  为了帮你消化，我们对比一下这道题用到的三个容器：

  |**容器**|**名字**|**特点**|**本题用途**|||||
  | -----| ---------| ----------------------| ------------------------------------------| --| --| --| --|
  |**数组** `int[]`|​`nums1`​,`ans`|长度固定，存基本类型|题目输入和输出的标准格式|||||
  |**集合** `HashSet`|​`st`|​**去重**，无序，查找快|快速判断一个数字是否存在，并防止结果重复|||||
  |**列表** `ArrayList`|​`lst`|​**长度可变**，有序|暂时存放结果，因为不知道会有多少个交集|||||

  这一段代码虽然短，但它展示了 Java 程序员处理数据的标准流程：

  数组(原始数据) -\> 集合/列表(方便处理的中间态) -\> 数组(结果)。

  **现在，你对为什么第 11 行要写** **​`st.remove(x)`​** ​ **而不是** **​`st.contains(x)`​** ​ **彻底理解了吗？**

# 202. 快乐数

[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)

```java
class Solution {
    private int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }

    public boolean isHappy(int n) {
        Set<Integer> seen = new HashSet<>();
        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = getNext(n);
        }
        return n == 1;
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/happy-number/solutions/224894/kuai-le-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# ai总结：

- 你好！欢迎回来。这次你带来的代码解决的是一个非常有趣的数学游戏——​ **“快乐数” (Happy Number)** 。

  这段代码的结构非常清晰，它分成了两个部分：

  1. **一个专门计算数学题的小助手** (`getNext`)。
  2. **一个负责判断逻辑的主管** (`isHappy`)。

  这也是 Java 编程中非常推荐的\*\*“封装”\*\*思想：把复杂的功能拆开，各司其职。我们来一一拆解。

  ---

  ## 1. 核心解题思路：如何防止“鬼打墙”？

  ### 什么是快乐数？

  规则很简单：把一个数字的每一位取出来，算出它们的平方和，得到一个新数字。一直重复这个过程。

  - ​**快乐结局**​：最后变成了 ​**1**（因为 $1^2 = 1$，它会永远停留在 1）。
  - ​**不快乐结局**​：数字变来变去，最后变回了​**曾经出现过的某个数字**，从此开始死循环（鬼打墙）。

  ### 代码的逻辑

  为了判断是不是“快乐数”，我们需要一个记性很好的\*\*“记账本”\*\*（这里用的就是你刚学过的 `HashSet`）。

  1. 把当前数字记在本子上。
  2. 算出下一个数字。
  3. ​**关键检查**：看看新数字是不是已经在记账本里了？

     - 如果​**在**​：完蛋，遇到重复的了，说明进入死循环了，它永远变不成 1。返回 `false`。
     - 如果​**不在**：继续算下去。
  4. 如果中间算出了 ​**1**​，恭喜，它是快乐数！返回 `true`。

  ---

  ## 2. 语法详细拆解

  ### 第一部分：数学小助手 `getNext(int n)`

  这个方法专门负责：“把 n 的每一位拆出来，算平方和”。

  这部分是新手最容易晕的“取整取余”操作，一定要看懂！

  Java

  ```
  private int getNext(int n) {
      int totalSum = 0;
      while (n > 0) {
          int d = n % 10;   // 1. 取出最后一位
          n = n / 10;       // 2. 删掉最后一位
          totalSum += d * d; // 3. 累加平方
      }
      return totalSum;
  }
  ```

  - ​**​`private`​**：这是一个新词。

    - ​**含义**：表示这个方法是“私有的”、“内部使用的”。
    - ​**作用**​：只有 `Solution` 这个类自己能用它，外面的代码看不到。这就像餐馆的后厨，顾客进不去。
  - ​ **​`%`​** ​  **(取余/模运算)** ：

    - ​`n % 10`​ 的意思是：`n` 除以 10 剩下的余数。
    - 在十进制里，​**这就等于拿到了个位数字**。
    - ​*例子*​：`19 % 10 = 9`。
  - ​ **​`/`​** ​  **(整数除法)** ：

    - 在 Java 里，整数除以整数，结果还是整数（小数部分直接扔掉）。
    - ​`n / 10`​ 的效果就是：​**删掉个位数字**，整体右移一位。
    - ​*例子*​：`19 / 10 = 1`。

  **动图演示** **​`getNext(19)`​** ​ **的过程：**

  1. ​`n=19`​。`d = 9`​ (取余)。`n`​ 变为 `1`​ (整除)。`sum` 加上 $9^2=81$。
  2. ​`n=1`​。`d = 1`​ (取余)。`n`​ 变为 `0`​ (整除)。`sum` 加上 $1^2=1$。
  3. ​`n=0`​。循环结束。返回 `81 + 1 = 82`。

  ---

  ### 第二部分：逻辑主管 `isHappy(int n)`

  Java

  ```
  public boolean isHappy(int n) {
      Set<Integer> seen = new HashSet<>(); // 1. 创建记账本
      // 循环条件：
      // (1) n 还没变成 1 (还没成功)
      // AND (&&)
      // (2) 记账本里没见过 n (还没死循环)
      while (n != 1 && !seen.contains(n)) {
          seen.add(n);      // 把当前数字记下来
          n = getNext(n);   // 算出下一个数字
      }
      // 循环结束后，判断是因为变成了1出来的，还是因为死循环出来的
      return n == 1; 
  }
  ```

  - ​**​`Set<Integer> seen`​**：

    - 这就是我们在上一题（交集问题）里学到的 ​**集合**。
    - ​**作用**​：它的特点是​**查重快**。我们用它来记录所有“路过”的数字。
  - ​ **​`!seen.contains(n)`​** ：

    - ​`!`​ 是  **“非” (Not)**  的意思。
    - 翻译过来就是：​ **“如果 seen 里面【不包含】n”** 。
  - ​ **​`&&`​** ：

    - ​**逻辑与 (AND)** ​。意思是左边和右边的条件必须​**同时满足**，循环才能继续。

  ---

  ## 3. 总结与思考

  这段代码教给了你两个非常重要的编程套路：

  1. 数位分离术：  
     只要题目让你处理“数字的每一位”，你就背下这个公式：
  2. 哈希表判重（破环）：  
     只要题目涉及“在这个过程中会不会出现死循环？”，或者“有没有重复出现？”，第一反应就是用 HashSet。把走过的路都记下来，一旦遇到记过的，说明我们绕回原点了。

  自我检测一下：

  如果 getNext 算出来的数字是 1，那么主方法里的 while 循环是因为哪个条件不满足而停止的？

  （答案：是因为 n !\= 1 变成了假，因为此时 n 等于 1 了。）

‍
