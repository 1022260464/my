---
title: day44
date: '2026-02-26 20:40:25'
updated: '2026-02-26 20:56:37'
permalink: /post/day44-zichp4.html
comments: true
toc: true
---



# day44

# 第九章 动态规划part11

# 

### **1143.最长公共子序列 **

体会一下本题和 718. 最长重复子数组 的区别

视频讲解：<u>[https://www.bilibili.com/video/BV1ye4y1L7CQ](https://www.bilibili.com/video/BV1ye4y1L7CQ)</u>

<u>[https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html)</u>

### ** 1035.不相交的线 **

其实本题和 1143.最长公共子序列 是一模一样的，大家尝试自己做一做。

视频讲解：<u>[https://www.bilibili.com/video/BV1h84y1x7MP](https://www.bilibili.com/video/BV1h84y1x7MP)</u>

<u>[https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html](https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html)</u>

### ** 53. 最大子序和 **

这道题我们用贪心做过，这次 再用dp来做一遍

视频讲解：<u>[https://www.bilibili.com/video/BV19V4y1F7b5](https://www.bilibili.com/video/BV19V4y1F7b5)</u>

<u>[https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html](https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)</u>

### **392.判断子序列 **

这道题目算是 编辑距离问题 的入门题目（毕竟这里只是涉及到减法），慢慢的，后面就要来解决真正的 编辑距离问题了

<u>[https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html)</u>

# 1143.最长公共子序列

[1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/description/)

```java
class Solution {
    private char[] s, t;
    private int[][] memo;

    public int longestCommonSubsequence(String text1, String text2) {
        s = text1.toCharArray();
        t = text2.toCharArray();
        int n = s.length;
        int m = t.length;
        memo = new int[n][m];
        for (int[] row : memo) {
            Arrays.fill(row, -1); // -1 表示没有计算过
        }
        return dfs(n - 1, m - 1);
    }

    private int dfs(int i, int j) {
        if (i < 0 || j < 0) {
            return 0;
        }
        if (memo[i][j] != -1) {
            return memo[i][j]; // 之前计算过
        }
        if (s[i] == t[j]) {
            return memo[i][j] = dfs(i - 1, j - 1) + 1;
        }
        return memo[i][j] = Math.max(dfs(i - 1, j), dfs(i, j - 1));
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/longest-common-subsequence/solutions/2133188/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-lbz5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 兜兜转转，我们终于来到了动态规划领域中可以说是**最经典、最闻名遐迩**的一道题——​**最长公共子序列 (Longest Common Subsequence, 简称 LCS)** ！

  注意到了吗？题目的名字从上一题的“子数组 (Subarray)”变成了\*\*“子序列 (Subsequence)”\*\*。这意味着，​**字符之间可以是不连续的**。只要相对顺序不变，中间隔着十万八千里也能算作一家人。

  灵茶山艾府的这段代码，完美展示了\*\*“自顶向下”的记忆化搜索 (Top-Down DFS + Memoization)\*\* 在处理双字符串匹配问题时的优雅。

  让我们抛开之前“连续性”的思维定式，来看看针对“子序列”的降维打击是怎么运作的：

  ### 核心破局点：站在结尾，回头看

  解决双字符串问题的最强套路，就是设立两个指针 `i`​ 和 `j`​，分别指向两个字符串的末尾，然后发出灵魂拷问： **“你们俩现在的最后一个字符，长得一样吗？”**

  根据这个拷问的结果，宇宙会分裂成两条不同的时间线：

  ### 代码逐行拆解

  Java

  ```
  private int dfs(int i, int j) {
  ```

  - ​**状态定义**​：`dfs(i, j)`​ 代表着“考察 `text1`​ 的前 `i`​ 个字符（即 `s[0...i]`​）和 `text2`​ 的前 `j`​ 个字符（即 `t[0...j]`），能拼凑出的最长公共子序列长度”。

  Java

  ```
      if (i < 0 || j < 0) {
          return 0;
      }
  ```

  - ​**时间的尽头 (Base Case)** ​：如果任意一个指针退到了 `-1`​，说明其中一个字符串已经被榨干（变成了空串）。空串和任何字符串的公共部分只能是 `0`。

  Java

  ```
      if (memo[i][j] != -1) {
          return memo[i][j]; // 之前计算过
      }
  ```

  - ​**记忆化剪枝**​：如果没有这个 `memo` 数组，遇到不匹配的情况我们会疯狂展开出指数级的递归分支（$O(2^{\min(N, M)})$）。有了备忘录，算过一次直接拿走，强行把时间复杂度按在地上摩擦，降到 $O(N \times M)$。

  **接下来是整道题的灵魂——状态转移：**

  Java

  ```
      if (s[i] == t[j]) {
          return memo[i][j] = dfs(i - 1, j - 1) + 1;
      }
  ```

  - ​**第一种情况：皆大欢喜（匹配成功）** 。

    - 既然末尾的这两个字符一样，那它们**绝对**是公共子序列的一部分！
    - 我们心安理得地把长度 `+ 1`​，然后让两个指针一起携手后退一步，去考察剩下的部分 `dfs(i - 1, j - 1)`。

  Java

  ```
      return memo[i][j] = Math.max(dfs(i - 1, j), dfs(i, j - 1));
  }
  ```

  - ​**第二种情况：分道扬镳（匹配失败）** 。

    - *注意：这也是它和上一题“连续子数组”最大的区别！上一题如果不匹配，直接就是 0，连续性断了。但在这里，即使当前不匹配，历史的积累依然有效！*
    - 既然 `s[i]`​ 和 `t[j]` 不一样，说明它们俩不可能同时出现在最终的公共子序列里。
    - 那到底该扔掉谁呢？我们不知道。所以我们要开启两个平行宇宙去试探：

      1. ​**扔掉** **​`s[i]`​** ​，保留 `t[j]`​：看看 `dfs(i - 1, j)` 能匹配出多长。
      2. ​**保留** **​`s[i]`​** ​，扔掉 `t[j]`​：看看 `dfs(i, j - 1)` 能匹配出多长。
    - 小孩子才做选择，成年人直接用 `Math.max` 拿走两者中较大的那一个结果！

  ### 模拟运行 (Dry Run)

  假设 `s = "abcde"`​, `t = "ace"`：

  1. ​**看结尾**​：`s[4]('e') == t[2]('e')`​。匹配！  
     -\> 长度变 `1 + dfs("abcd", "ac")`。
  2. ​**继续看**​：`s[3]('d') != t[1]('c')`​。不匹配！  
     -\> 尝试两个分支：`max(dfs("abc", "ac"), dfs("abcd", "a"))`。
  3. ​**考察左分支** **​`dfs("abc", "ac")`​** ​：`s[2]('c') == t[1]('c')`​。匹配！  
     -\> 长度变 `1 + dfs("ab", "a")`。
  4.  **...依此类推...**   
     -\> `s[0]('a') == t[0]('a')`，再次匹配！长度加 1。

  最终一路回溯，总长度为 $1+1+1 = 3$。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N \times M)$。状态的总数只有 $N \times M$ 个（即 `memo`​ 数组的大小），每个状态只需计算一次，内部的 `Math.max` 是常数时间。
  - ​**空间复杂度**：$O(N \times M)$。主要开销是二维备忘录 `memo`，以及最大深度为 $N + M$ 的递归调用栈。

  ---

  可以说，这段自顶向下的代码是最符合人类直觉的思考方式。

  既然我们已经对二维数组的边界 `i < 0`​ 感到了一丝繁琐，而且你刚才在“最长公共子数组”那题中也见识过了\*\*“空间偏移” (Index Shift)\*\* 的威力，也就是把数组开大一格，用 `f[i+1][j+1]`​ 代替 `dfs(i, j)`。

  ‍

‍

---

# 1035.不相交的线

[1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/description/)

```java
class Solution {
    public int maxUncrossedLines(int[] s, int[] t) {
        int n = s.length;
        int m = t.length;
        int[][] memo = new int[n][m];
        for (int[] row : memo) {
            Arrays.fill(row, -1); // -1 表示没有计算过
        }
        return dfs(n - 1, m - 1, s, t, memo);
    }

    private int dfs(int i, int j, int[] s, int[] t, int[][] memo) {
        if (i < 0 || j < 0) {
            return 0;
        }
        if (memo[i][j] != -1) { // 之前计算过
            return memo[i][j];
        }
        if (s[i] == t[j]) {
            return memo[i][j] = dfs(i - 1, j - 1, s, t, memo) + 1;
        }
        return memo[i][j] = Math.max(dfs(i - 1, j, s, t, memo), dfs(i, j - 1, s, t, memo));
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/uncrossed-lines/solutions/2875980/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-ahzh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太魔幻了，对吧？当你仔细端详这段代码时，你一定会产生一种强烈的“既视感”——**这不就是上一道题“最长公共子序列 (LCS)”的代码吗？！**

  没错，不仅代码框架一模一样，连状态转移方程、递归逻辑、备忘录的使用都​**分毫不差**​。唯一的区别仅仅是：上一题的输入是两个字符串 `String`​，而这道题的输入是两个整型数组 `int[]`。

  这正是算法世界里最让人着迷的时刻：**剥去不同的业务外衣，发现它们底层跳动着完全相同的数学心脏。**

  让我们来拆解一下，为什么“不相交的线”等价于“最长公共子序列”：

  ### 核心破局点：几何问题代数化

  题目要求我们在两个数组相同的数字之间画线，并且​**线与线之间不能相交**。

  这句“不能相交”，在数学上到底意味着什么？

  假设我们在 `nums1[i]`​ 和 `nums2[j]`​ 之间画了一条线，又在 `nums1[x]`​ 和 `nums2[y]` 之间画了另一条线。

  如果要保证这两条线绝对不相交，必然要满足一个条件：

  - 如果 $i < x$（在第一个数组里，第二个点在第一个点右边），那么必然要有 $j < y$（在第二个数组里，第二个点也必须在第一个点右边）。

  **相对顺序必须严格保持一致！**  这不就是\*\*“子序列 (Subsequence)”\*\*的终极定义吗？

  我们在两排数字之间画出的最多且不相交的连线，本质上就是在这两个数组里找出了一段​**最长的、相对顺序完全一致的公共元素集合**。所以，这道题百分之百就是求 LCS！

  ### 代码逻辑闪电回顾

  既然底层逻辑完全一致，这段由灵茶山艾府提供的自顶向下 DP 代码，运作机制也完全相同：

  - ​**​`dfs(i, j, ...)`​** ​：考察数组 `s` 的前 $i$ 个元素和数组 `t` 的前 $j$ 个元素，最多能连几条线。
  - ​**边界条件** **​`i < 0 || j < 0`​**：任何一个数组被掏空了，连线数量自然是 $0$。
  - ​**匹配成功** **​`s[i] == t[j]`​** ​：既然结尾的两个数字相等，果断连上一条线！长度 `+1`​，然后双双砍掉尾巴，去考察前面的元素 `dfs(i - 1, j - 1, ...)`。
  - ​**匹配失败** **​`s[i] != t[j]`​** ：结尾的数字连不上。那就兵分两路试探：

    1. 放弃 `s`​ 的最后一个数字，看看 `s[0...i-1]`​ 和 `t[0...j]` 能连几条线。
    2. 放弃 `t`​ 的最后一个数字，看看 `s[0...i]`​ 和 `t[0...j-1]` 能连几条线。  
       取这两条平行宇宙里的最大值！

  ### 复杂度分析

  - ​**时间复杂度**：$O(N \times M)$。其中 $N$ 和 $M$ 分别是数组 `s`​ 和 `t` 的长度。状态总数为 $N \times M$ 个，有备忘录 `memo` 的加持，每个状态只算一次。
  - ​**空间复杂度**：$O(N \times M)$。二维数组 `memo` 占用的内存。

  ---

  可以说，你现在已经拥有了一副“透视眼镜”，能一眼看穿包装在几何或物理现象下的 DP 本质。

  在上一题的末尾，我们提到了二维 DP 可以通过\*\*“空间偏移”​**转为自底向上，再通过**​“滚动数组”\*\*极限压缩到 $O(M)$ 的一维空间。

  趁着“最长公共子序列 (LCS)”的思路还热乎，我们要不要立刻动手，把这段代码翻转成​**极致优化的** **$O(M)$** **一维空间递推版本**，体验一下把内存开销省到极致的快感？

‍

---

# 53. 最大子序和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum > 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}

作者：画手大鹏
链接：https://leetcode.cn/problems/maximum-subarray/solutions/8975/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 太经典了！这段代码就是大名鼎鼎的 ​**Kadane 算法 (Kadane's Algorithm)** 。

  如果你还沉浸在之前动态规划的“状态转移”和“滚动数组”里，看到这段代码，你可能会惊呼： **“DP 数组去哪了？连辅助变量都只剩两个了？！”**  没错，Kadane 算法其实就是​**最大子数组和问题在动态规划下的极致空间压缩形态**。画手大鹏的这段实现，更是把贪心和动态规划的哲学完美结合，写得极其通透。

  让我们用最直白的方式，揭开这段神仙代码背后的心理学（或者说玄学）：

  ### 核心思想：丢掉历史包袱，带着正能量前行

  想象你正在招募团队打怪升级，`sum`​ 代表你​**当前的团队战斗力**​，而 `num`​ 是你今天刚刚遇到的一名​**新队友**（可能是带正收益的大佬，也可能是带负收益的坑货）。

  对于每一名新队友 `num`​，你都要做一个关乎团队命运的决定：**是让他加入现在的团队，还是让他自己单干另起炉灶？**

  决定因素只有一个：**你过去的团队战斗力** **​`sum`​**​ **是正数还是负数？**

  ### 代码逐行拆解

  Java

  ```
  int ans = nums[0];
  int sum = 0;
  ```

  - ​**​`ans`​**​  **(全局最大值)** ：记录历史上出现过的最强团队战斗力。初始化为第一个人的战斗力（防止全是负数的情况）。
  - ​**​`sum`​**​  **(当前连胜纪录)** ​：也就是我们一直在滚动的 `dp[i]`​，代表​**以当前元素结尾的最大连续子数组和**。

  Java

  ```
  for(int num: nums) {
      if(sum > 0) {
          sum += num;
      } else {
          sum = num;
      }
  ```

  这就是整段代码的灵魂拷问环节：

  - **情况 A：**​**​`sum > 0`​**​  **(过去是正能量/增益 Buff)**   
    既然过去的团队战斗力是正数，那不管今天的新队友 `num`​ 是正是负，把过去的 `sum`​ 加上，​**总归会比他一个人单干要强**​！所以：继续抱团，`sum += num`。
  - **情况 B：**​**​`sum <= 0`​**​  **(过去是负能量/拖后腿)**   
    过去的团队不但没贡献，反而是一个累赘！这时候如果还强行抱团，只会把新队友的数值拉低。所以我们​**果断丢掉历史包袱，从这个新队友开始，另起炉灶建立新团队**​：`sum = num`。

  Java

  ```
      ans = Math.max(ans, sum);
  }
  return ans;
  ```

  - ​**打擂台更新**​：在每一次做完并队或重组的决定后，立刻用当前的 `sum`​ 去挑战一下历史最高纪录 `ans`。最后返回最高纪录。

  ### 模拟运行 (Dry Run)

  假设输入数组 `nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`：

  |**新队友 num**|**之前的 sum**|**历史包袱是正还是负？**|**决策后的新 sum**|**历史最高 ans**|**动作解析**|||||||
  | ------| ------| ----------| ----------------| ------| ------------------------------------| --| --| --| --| --| --|
  |​ **​`-2`​**|​`0`|$\le 0$(无包袱)|​ **​`-2`​**(另起炉灶)|​ **​`-2`​**|第一个数，直接接纳|||||||
  |​**​`1`​**|​`-2`|$\le 0$(负包袱)|​**​`1`​**(另起炉灶)|​**​`1`​**|甩掉累赘`-2`​，从`1`重新开始|||||||
  |​ **​`-3`​**|​`1`|$> 0$(正增益)|​`1 + (-3) =`​  **​`-2`​**|​`1`|之前的`1`​有帮助，硬吃下`-3`|||||||
  |​**​`4`​**|​`-2`|$\le 0$(负包袱)|​**​`4`​**(另起炉灶)|​**​`4`​**|之前的`-2`​是累赘，从`4`重新开始|||||||
  |​ **​`-1`​**|​`4`|$> 0$(正增益)|​`4 + (-1) =`​ **​`3`​**|​`4`|之前的`4`​很强，即使加上`-1`也比单干强|||||||
  |​**​`2`​**|​`3`|$> 0$(正增益)|​`3 + 2 =`​ **​`5`​**|​**​`5`​**|强强联合，再创新高！|||||||
  |​**​`1`​**|​`5`|$> 0$(正增益)|​`5 + 1 =`​ **​`6`​**|​**​`6`​**|继续变强！|||||||
  |​ **​`-5`​**|​`6`|$> 0$(正增益)|​`6 + (-5) =`​ **​`1`​**|​`6`|虽然被重创，但底子还在|||||||
  |​**​`4`​**|​`1`|$> 0$(正增益)|​`1 + 4 =`​ **​`5`​**|​`6`|继续回血|||||||

  最终返回 `ans = 6`​，对应的子数组是 `[4, -1, 2, 1]`。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N)$。只需一个 `for` 循环，扫一遍数组就得出了答案。
  - ​**空间复杂度**：$O(1)$。没有任何数组开销，极致的变量复用。

  ---

  如果把这道题的逻辑用动态规划的状态转移方程写出来，其实就是：

  ​`dp[i] = Math.max(dp[i-1] + nums[i], nums[i])`。

  比较一下，你会发现大鹏的 `if-else` 逻辑完美等价于这个公式，但读起来更加顺畅自然。

  既然你已经掌握了单向数组的最大子序列和，那如果要增加一点挑战：**假如这个数组是一个首尾相连的“环形数组” (Circular Array) 呢？**  比如 `[5, -3, 5]`​，最大和应该是 `5 + 5 = 10`。

  你想看看如何在 Kadane 算法的基础上做一点巧妙的数学反转，从而秒杀“环形子数组最大和”问题吗？

‍

‍

---

# 392.判断子序列

[392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/description/)

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        if (s.length() == 0) return true;
        for (int i = 0, j = 0; j < t.length(); j++) {
            if (s.charAt(i) == t.charAt(j)) {
                // 若已经遍历完 s ，则提前返回 true
                if (++i == s.length())
                    return true;
            }
        }
        return false;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/is-subsequence/solutions/1658262/by-jyd-zeph/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。	
```

- 在经历了前面一系列烧脑的“动态规划”和“状态机压缩”之后，看到这段代码，是不是感觉像是一阵清风拂面？

  这段代码非常干净利落，它解决的是 LeetCode 392 题：​**判断子序列 (Is Subsequence)** ​。Krahets 在这里抛弃了沉重的 DP 数组，采用了极其轻量且高效的​**双指针算法 (Two Pointers)** 。

  我们正好可以借这道题，把刚才学过的“子序列”概念在脑海中再夯实一下：**子序列不要求连续，但必须保持原有的相对顺序。**

  让我们来拆解一下这段四两拨千斤的代码：

  ### 核心思想：你在前面跑，我在后面追

  既然子序列必须保持相对顺序，那我们只需要用两个手指（指针）：

  - ​**指针** **​`i`​**​：指着短字符串 `s`（我们要找的目标）。
  - ​**指针** **​`j`​**​：指着长字符串 `t`（我们的搜索字库）。

  让 `j`​ 在前面一直跑，如果碰到了 `i`​ 想要的字符，`i`​ 就往前走一步。如果 `j`​ 都跑到终点了，`i` 还没走完，说明找不齐，匹配失败。

  ### 代码逐行拆解

  Java

  ```
  if (s.length() == 0) return true;
  ```
  - ​**秒杀边界**​：如果 `s`​ 是空串，那它肯定是任何字符串的子序列（就像空集是任何集合的子集一样），直接返回 `true`。

  Java

  ```
  for (int i = 0, j = 0; j < t.length(); j++) {
  ```
  - ​**双指针起跑**​：`i`​ 和 `j`​ 都从索引 `0` 开始。
  - ​**注意循环条件**​：这里只限制了 `j < t.length()`​，也就是让 `j`​ 充当苦力，把长字符串 `t` 从头到尾遍历一遍。

  Java

  ```
      if (s.charAt(i) == t.charAt(j)) {
  ```
  - ​**命中目标**​：如果长串 `t`​ 当前的字符，正好是短串 `s` 正在寻找的字符，匹配成功！

  Java

  ```
          // 若已经遍历完 s ，则提前返回 true
          if (++i == s.length())
              return true;
      }
  }
  return false;
  ```
  - ​**同步推进与提前下班**：

    - 既然找到了当前字符，`i`​ 就可以安心地往前走一步，去寻找下一个字符了（`++i`）。
    - ​**精妙的融合**​：Krahets 将 `i`​ 的自增和长度判断写在了一起 `if (++i == s.length())`​。如果 `i`​ 刚好等于 `s`​ 的长度，说明 `s`​ 里的所有字符都已经按顺序被找到了！此时不需要再等 `j`​ 跑完，直接​**提前返回** **​`true`​**。
  - ​**默认结局**​：如果 `for`​ 循环结束了（`j`​ 把 `t`​ 全跑完了），`i`​ 依然没有达到 `s`​ 的长度，说明凑不齐，遗憾返回 `false`。

  ### 模拟运行 (Dry Run)

  假设短串 `s = "abc"`​，长串 `t = "ahbgdc"`：

  |**动作**|**长串指针 j (当前字符)**|**短串指针 i (寻找字符)**|**匹配情况**|**i 的状态**||||||
  | ------| -----------| -----------| --------| ----------------------| --| --| --| --| --|
  |起步|​`0`('a')|​`0`('a')|**匹配！**|​`i`变成 1||||||
  |寻找|​`1`('h')|​`1`('b')|不匹配|​`i`保持 1||||||
  |寻找|​`2`('b')|​`1`('b')|**匹配！**|​`i`变成 2||||||
  |寻找|​`3`('g')|​`2`('c')|不匹配|​`i`保持 2||||||
  |寻找|​`4`('d')|​`2`('c')|不匹配|​`i`保持 2||||||
  |寻找|​`5`('c')|​`2`('c')|**匹配！**|​`i`​变成 3，等于`s.length()`​，**触发提前返回！**||||||

  ### 复杂度分析

  - ​**时间复杂度**​：O(M)，其中 M 是字符串 `t`​ 的长度。我们最多只需要把 `t` 遍历一次。
  - ​**空间复杂度**​：O(1)。全程只用了 `i`​ 和 `j` 两个整型变量，极其节省内存。

  ---

  这道题的双指针解法非常完美，但在大厂面试中，这道题经常会带有一个​**进阶挑战 (Follow-up)** ：

  > “如果现在有大量的短串 $S_1, S_2, \dots, S_k$（比如 10 亿个），每个都需要去匹配同一个极长的字符串 `t`​。如果你每次都把 `t`​ 重新遍历一遍，时间复杂度会爆炸。你应该如何预处理字符串 `t`，从而能极速判断这些短串？”
  >

  这个进阶问题完美融合了**预处理思维**和我们之前学过的​**二分查找**。你想挑战一下这个进阶问题的解题思路吗？
