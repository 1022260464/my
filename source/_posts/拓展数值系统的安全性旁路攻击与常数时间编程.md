---
title: 拓展：数值系统的安全性：旁路攻击与常数时间编程
date: '2025-03-30 15:08:33'
updated: '2025-07-05 14:47:42'
permalink: >-
  /post/expand-security-of-numerical-systems-bypass-attacks-and-constant-time-programming-1aoljc.html
comments: true
toc: true
---



# 拓展：数值系统的安全性：旁路攻击与常数时间编程

数值系统还有一个重要的议题，就是安全性（信息安全与功能安全），它已经成为了日益突出的问题。

**旁路攻击**

旁路攻击(side channel attack)是指基于从计算机系统的实现中获得的信息的任何攻击 ，而不是基于算法本身的弱点，比如定时信息，功耗，电磁泄漏甚至声音都可以提供额外的信息来源，被 “黑客” 加以利用，说白了就是以「旁敲侧击」的方式进行攻击。

近些年的 熔断Meltdown漏洞，幽灵Spectre漏洞（两者都是利用现代CPU设计的“漏洞”，例如乱序执行，预测执行，CPU缓存等特性），以及 Row Hammer （利用DRAM的物理漏洞）等都是利用旁路攻击的例子。

这里举一个Timing Attack的例子，为了简化说明，我们考虑以下C函数， 这函数用于比较用户的输入字符串和存放在系统某处的密码是否一致，输入的字符串与密码完全一致才能获得系统权限，否则系统就报错，然后允许用户（过一段时间后）重新输入，这里有什么风险？ 假如我们有办法精确记录这个函数执行所耗费的时间，那不就可以大概知道在哪个字符出现了不匹配吗？这样的话密码破解的难度将大幅降低。

```c
int memcmp(const void *s1, const void *s2, size_t n) {
if (n != 0) {
const unsigned char *p1 = s1, *p2 = s2;
do {
if (*p1++ != *p2++)
return ((*--p1) - (*--p2));
} while (--n != 0);
}
return (0);
}
```

![微信截图_20250330151422](/source/images/微信截图_20250330151422-20250330151431-447gvgp.png)

实际上涉及密码学和处理敏感信息的程序应该引入常数时间的实现，如果我们想要实现一个对整数取绝对值的函数abs，以下的C示例代码，请注意它本身并不保证是常数时间的，但是如果你去看它在x86-64平台上优化之后的汇编代码，可以看出它是没有分支的，按常数时间实现的，比较安全高效。

```c
// 求一个数的绝对值: 1.有分支情况下CPU执行的指令数量不同 2.注意传入整型最小负值的情况
int abs(int num) {
return num < 0 ? -num : num;
}
// x86-64 某一个优化版本：注意这里没有分支，3条汇编指令
abs:
mov eax,edi // 参数保存到eax
neg eax // 求出它的相反数
cmovs eax,edi // 如果符号位=1（即参数是正数）, 原来的参数存入eax
ret
// 你也可以用C语言手写没有分支的版本，例如（仅供参考）
#include <stdint.h>
int32_t abs(int32_t num){
int32_t mask = (num >> 31);
return ((num + mask) ^ mask);
}
```

### **数值系统的安全性：旁路攻击与常数时间编程**

---

#### **1. 旁路攻击（Side-Channel Attack）的核心问题**

旁路攻击通过测量**物理特征**（如时间、功耗、电磁辐射）而非算法漏洞来破解系统。
**示例：基于时间的攻击（Timing Attack）**

```c
int memcmp(const void *s1, const void *s2, size_t n) {
    if (n != 0) {
        const unsigned char *p1 = s1, *p2 = s2;
        do {
            if (*p1++ != *p2++)  // 首次不匹配时立即返回
                return ((*--p1) - (*--p2)); // 泄露不匹配位置
        } while (--n != 0);
    }
    return (0);
}
```

**风险**：

* 攻击者通过测量函数执行时间，可推断出密码在哪个字符处不匹配。
* 例如：密码为 `"secret"`​，输入 `"sxxxxx"`​ 比 `"xxxxxx"`​ 耗时略长（因多比较一个字符）。

---

#### **2. 常数时间编程（Constant-Time Programming）**

安全敏感操作（如密码比较、加密）需保证**执行时间与输入无关**，避免泄露信息。

#####  **(1) 安全版本的** **​`memcmp`​**​

```c
int secure_memcmp(const void *s1, const void *s2, size_t n) {
    const unsigned char *p1 = s1, *p2 = s2;
    int result = 0;
    for (; n > 0; n--) {
        result |= *p1++ ^ *p2++;  // 累积差异，不提前返回
    }
    return result;  // 0表示完全匹配，非0表示不匹配
}
```

**特点**：

* 无论是否匹配，始终遍历全部字符。
* 通过位运算（`^`​ 和 `|`​）避免分支。

#####  **(2) 无分支的** **​`abs`​**​ **函数**

```c
// 无分支实现（常数时间）
int32_t abs(int32_t num) {
    int32_t mask = num >> 31;  // 正数=0，负数=0xFFFFFFFF
    return (num + mask) ^ mask; // 等价于 num < 0 ? -num : num
}
```

**汇编对比**：

```asm
; x86-64 优化版本（无分支）
abs:
    mov   eax, edi
    neg   eax       ; 计算 -num
    cmovs eax, edi  ; 若原数为正，恢复原始值
    ret
```

---

#### **3. 现代CPU漏洞与旁路攻击案例**

|漏洞名称|攻击方式|利用的硬件特性|
| ----------| ------------------------------| ----------------|
|**Meltdown**|通过乱序执行读取内核内存|CPU乱序执行|
|**Spectre**|利用预测执行访问其他进程数据|分支预测|
|**RowHammer**|频繁翻转DRAM行导致位翻转|DRAM物理特性|

**防御措施**：

* **软件**：常数时间算法、禁用危险优化（如 `-fno-strict-aliasing`​）。
* **硬件**：隔离敏感操作（如Intel SGX）、缓存分区（Cache Partitioning）。

---

#### **4. 安全编程实践**

#####  **(1) 密码学库的要求**

* **OpenSSL**：使用常数时间比较（如 `CRYPTO_memcmp`​）。
* **Libsodium**：默认禁用时序攻击敏感操作。

#####  **(2) 代码审查重点**

* 避免基于秘密数据的分支（如 `if (password[0] == 'A')`​）。
* 禁用编译器危险优化（如循环展开可能泄露循环次数）。

#####  **(3) 测试方法**

* **计时分析**：测量函数在不同输入下的执行时间分布。
* **功耗分析**：使用示波器监测芯片功耗波动。

---

#### **5. 关键总结**

|安全原则|不安全示例|安全方案|
| ----------| ------------------------| --------------------|
|**避免提前终止**|​`memcmp`​ 首次不匹配即返回|累积所有比较结果|
|**消除数据依赖分支**|​`if (num < 0) return -num;`​|无分支位运算|
|**禁用危险编译器优化**|自动向量化泄露循环次数|使用 `volatile`​ 或内联汇编|

**最终建议**：

* 在安全关键代码中，优先使用经过审计的库（如 OpenSSL、Libsodium）。
* 对自定义算法进行**旁路攻击测试**（如计时、功耗分析）。
