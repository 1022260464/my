---
title: day41
date: '2026-02-26 20:01:48'
updated: '2026-02-26 20:07:37'
permalink: /post/day41-114bf5.html
comments: true
toc: true
---



# day41

# 第九章 动态规划part08

 股票问题是一个动态规划的系列问题，前两题并不难，第三题有难度。

### ** 121. 买卖股票的最佳时机 **

视频讲解：<u>[https://www.bilibili.com/video/BV1Xe4y1u77q](https://www.bilibili.com/video/BV1Xe4y1u77q)</u>

<u>[https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html](https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)</u>

### **122.买卖股票的最佳时机II  **

视频讲解：<u>[https://www.bilibili.com/video/BV1D24y1Q7Ls](https://www.bilibili.com/video/BV1D24y1Q7Ls)</u>

<u>[https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)</u>

### ** 123.买卖股票的最佳时机III  **

这道题一下子就难度上来了，关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

视频讲解：<u>[https://www.bilibili.com/video/BV1WG411K7AR](https://www.bilibili.com/video/BV1WG411K7AR)</u>

<u>[https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html](https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)</u>

# 121. 买卖股票的最佳时机

[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int cost = Integer.MAX_VALUE, profit = 0;
        for (int price : prices) {
            cost = Math.min(cost, price);
            profit = Math.max(profit, price - cost);
        }
        return profit;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/1692872/by-jyd-cu90/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- # 

  这是一段非常经典且优雅的代码，用于解决 LeetCode 上的  **“买卖股票的最佳时机” (Best Time to Buy and Sell Stock)**  问题。

  它采用的是​**贪心算法**（也可以理解为动态规划的状态压缩版本）的思想，只需要遍历一次数组就能得出结果。

  这里为你详细拆解一下这段代码的运行逻辑：

  ### 核心思路

  要想获得最大利润，我们需要在最低点买入，在最高点卖出。但时间只能向前走，所以对于每一天的股票价格，我们其实只需要关心两件事：

  1. **历史最低价格是多少？**  （作为我们的买入成本 `cost`）
  2. **如果我今天卖出，利润是多少？它能打破之前的最大利润记录吗？**  （作为我们的最大利润 `profit`）

  ### 代码逐行解析

  Java

  ```
  int cost = Integer.MAX_VALUE, profit = 0;
  ```

  - ​`cost`​ (买入成本)：初始化为整型的最大值 (`Integer.MAX_VALUE`)。这样可以保证在遍历第一天时，第一天的价格一定会比它小，从而顺理成章地成为初始的“最低成本”。
  - ​`profit`​ (最大利润)：初始化为 `0`​。因为题目规定如果不能获取任何利润，就返回 `0`（即不买不卖）。

  Java

  ```
  for (int price : prices) {
  ```

  - 开始遍历每一天的股票价格。

  Java

  ```
      cost = Math.min(cost, price);
  ```

  - ​**更新最低成本**​：比较“之前的历史最低价 `cost`​”和“今天的价格 `price`​”。如果今天的价格更低，我们就把今天当作新的买入点（更新 `cost`）。

  Java

  ```
      profit = Math.max(profit, price - cost);
  }
  ```

  - ​**更新最大利润**​：计算“如果今天卖出能赚多少钱 (`price - cost`​)”，并与“之前记录的最大利润 `profit`​”作比较。哪个大，我们就把哪个存入 `profit`。

  ### 模拟运行 (Dry Run)

  假设输入数组 `prices = [7, 1, 5, 3, 6, 4]`：

  |**天数**|**当前价格 (price)**|**最低成本 (cost) 更新**|**最大利润 (profit) 更新**|**状态说明**||||||
  | --| ------| -------------| -------------| ---------------------------| --| --| --| --| --|
  |**初始**|-|​`MAX_VALUE`|​`0`|初始状态||||||
  |**第1天**|​`7`|​`Math.min(MAX, 7)`​\=**​`7`​**|​`Math.max(0, 7-7)`​\=**​`0`​**|记录当前最低价为7||||||
  |**第2天**|​`1`|​`Math.min(7, 1)`​\=**​`1`​**|​`Math.max(0, 1-1)`​\=**​`0`​**|发现更低的价格1，更新成本||||||
  |**第3天**|​`5`|​`Math.min(1, 5)`​\=**​`1`​**|​`Math.max(0, 5-1)`​\=**​`4`​**|今天卖可赚4元，更新利润||||||
  |**第4天**|​`3`|​`Math.min(1, 3)`​\=**​`1`​**|​`Math.max(4, 3-1)`​\=**​`4`​**|赚2元，不如之前赚4元多||||||
  |**第5天**|​`6`|​`Math.min(1, 6)`​\=**​`1`​**|​`Math.max(4, 6-1)`​\=**​`5`​**|**今天卖可赚5元，创下新高！**||||||
  |**第6天**|​`4`|​`Math.min(1, 4)`​\=**​`1`​**|​`Math.max(5, 4-1)`​\=**​`5`​**|赚3元，保持最大利润5||||||

  最终返回 `profit`​，结果为 `5`。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N)$，其中 $N$ 是数组 `prices`​ 的长度。我们只需要使用一个 `for` 循环遍历数组一次。
  - ​**空间复杂度**：$O(1)$。我们只使用了 `cost`​ 和 `profit` 两个整型变量，不需要额外的存储空间。

  ---

  这道题还有一个进阶版本（买卖股票的最佳时机 II），允许你在同一天卖出后再次买入（即进行多次交易）。需要我为你找出来并讲解一下那道题的解法吗？

‍

---

# 122.买卖股票的最佳时机II

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for (int i = 1; i < prices.length; i++) {
            int tmp = prices[i] - prices[i - 1];
            if (tmp > 0) profit += tmp;
        }
        return profit;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/12625/best-time-to-buy-and-sell-stock-ii-zhuan-hua-fa-ji/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这正是上一题的进阶版本——​ **“买卖股票的最佳时机 II” (Best Time to Buy and Sell Stock II)** ！

  这段代码极其精简，它完美诠释了**贪心算法 (Greedy Algorithm)**  在这道题中的巧妙应用。相比于上一题只能买卖一次，这道题允许我们​**多次买卖**（但手中最多只能持有一股）。

  下面为你详细拆解这段令人拍案叫绝的逻辑：

  ### 核心思路：把所有的“上坡”都赚到手

  既然可以无限次交易，我们怎样才能赚得最多？

  答案是：**只要明天比今天涨了，我就今天买、明天卖！**

  哪怕是连续涨了三天（比如价格是 `1 -> 5 -> 6`​），我们在第一天买入、第三天卖出赚的钱 `(6 - 1 = 5)`​，**在数学上完全等价于**每天都进行买卖赚的钱：

  $$
  (5 - 1) + (6 - 5) = 4 + 1 = 5
  $$

  所以，我们根本不需要关心应该在哪里作为一个长线的买入点或卖出点。我们只需要盯着​**相邻的两天**，只要有差价赚（也就是折线图上的“上坡”），我们就把它通通收进囊中。

  ### 代码逐行解析

  Java

  ```
  int profit = 0;
  ```

  - 初始化总利润为 `0`。

  Java

  ```
  for (int i = 1; i < prices.length; i++) {
  ```

  - 从第二天（索引 `i = 1`​）开始遍历数组。因为我们要和前一天（`i - 1`​）进行比较，所以下标从 `1` 开始可以避免数组越界。

  Java

  ```
      int tmp = prices[i] - prices[i - 1];
  ```

  - 计算今天卖出、昨天买入的“单日利润” `tmp`。

  Java

  ```
      if (tmp > 0) profit += tmp;
  }
  ```

  - ​**贪心逻辑体现**​：如果 `tmp > 0`​（说明今天比昨天涨了，有钱赚），我们就把这笔钱加入总利润 `profit`​ 中。如果跌了（`tmp <= 0`），我们就不操作（相当于没买），完美避开亏损。

  ### 模拟运行 (Dry Run)

  同样假设输入数组 `prices = [7, 1, 5, 3, 6, 4]`：

  |**天数 (i)**|**昨天价格**|**今天价格**|**单日利润 (tmp)**|**是否赚钱？**|**总利润 (profit)**|**操作逻辑**||||||||
  | ------| ------| ------| ------| ----| ------| -----------------------| --| --| --| --| --| --| --|
  |​`i=1`|​`7`|​`1`|​`1 - 7 = -6`|否|​`0`|跌了，不买卖||||||||
  |​`i=2`|​`1`|​`5`|​`5 - 1 = 4`|**是**|​`0 + 4 = 4`|昨天买，今天卖，赚4元||||||||
  |​`i=3`|​`5`|​`3`|​`3 - 5 = -2`|否|​`4`|跌了，不买卖||||||||
  |​`i=4`|​`3`|​`6`|​`6 - 3 = 3`|**是**|​`4 + 3 = 7`|昨天买，今天卖，赚3元||||||||
  |​`i=5`|​`6`|​`4`|​`4 - 6 = -2`|否|​`7`|跌了，不买卖||||||||

  最终返回 `profit`​，结果为 `7`。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N)$，其中 $N$ 是数组的长度。我们只需遍历一次数组。
  - ​**空间复杂度**：$O(1)$。只使用了几个整型变量进行常数级别的空间计算。

  ---

  这两道股票题是 LeetCode 上非常经典的贪心/动态规划入门题。接下来还有限制最多交易 2 次的“股票 III”，或者带有冷冻期、手续费的版本，难度会逐渐上升并真正进入**动态规划 (Dynamic Programming)**  的领域。

  需要我为你接着讲解如何用“状态机 DP”的通用模板来秒杀所有股票买卖问题吗？

---

# 123.买卖股票的最佳时机III

[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        final int k = 2;
        int[][] f = new int[k + 2][2];
        for (int j = 1; j <= k + 1; j++) {
            f[j][1] = Integer.MIN_VALUE / 2; // 防止溢出
        }
        f[0][0] = Integer.MIN_VALUE / 2;
        for (int p : prices) {
            for (int j = k + 1; j > 0; j--) {
                f[j][0] = Math.max(f[j][0], f[j][1] + p);
                f[j][1] = Math.max(f[j][1], f[j - 1][0] - p);
            }
        }
        return f[k + 1][0];
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solutions/2974681/188-ti-k2-de-qing-kuang-pythonjavacgojsr-sg1z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- 这道题是股票系列真正的分水岭！如果说前两题还可以用贪心算法巧妙化解，那么从\*\*“买卖股票的最佳时机 III” (限制最多 $2$ 次交易)\*\* 开始，我们就正式踏入了**状态机动态规划 (State Machine DP)**  的领域。

  灵茶山艾府（EndlessCheng）的这段代码写得极其老练，它不仅是一个通用模板（可以轻松应对限制 $k$ 次交易的题目），还使用了​**空间优化（滚动数组）** ​，并且通过巧妙的**下标偏移**省去了大量繁琐的边界条件判断。

  下面为你深度剖析这段代码的“神仙逻辑”：

  ### 核心概念：状态机

  在这类问题中，我们每天都处于某种“状态”中。代码中的 `f`​ 数组就是在记录不同状态下的​**最大利润**。

  - ​`f[j][0]`：表示进行到第 $j$ 个阶段，当前​**手里没有股票**（持有现金）时的最大利润。
  - ​`f[j][1]`：表示进行到第 $j$ 个阶段，当前**手里持有** **$1$** **支股票**时的最大利润。

  ### 令人叫绝的下标设计 (Index Shift)

  你可能会疑惑，既然 $k=2$，为什么数组大小开的是 `k + 2`（也就是 $4$），并且循环是从 `j = 3`​ 递减到 `j = 1`？

  这是为了构造一个​**前置的虚拟状态**​，让整个状态转移方程浑然一体，不需要写任何 `if-else` 来处理第一笔交易的边界。

  我们可以这样理解 `j` 的含义：

  | 变量 `j`​ | 实际代表的含义 | `f[j][0]`​ (不持股/卖出状态) | `f[j][1]` (持股/买入状态) |

  | :--- | :--- | :--- | :--- |

  | **​`j = 1`​**​ | **第** **$0$** **次交易 (占位符)**  | 初始默认是 `0`​，并且永远是 `0`​ | 初始是 `-∞`​，并且永远是 `-∞` |

  | **​`j = 2`​**​ | **第** **$1$** **次交易** | 也就是**第一次卖出**后的最大利润 | 也就是**第一次买入**后的最大利润 |

  | **​`j = 3`​**​ | **第** **$2$** **次交易** | 也就是**第二次卖出**后的最大利润 | 也就是**第二次买入**后的最大利润 |

  最终我们只需要返回 `f[k + 1][0]`​（即 `f[3][0]`），也就是最多完成 $2$ 次交易且手里没股票时的最大利润。

  ### 状态转移方程解析

  对于每一天的价格 `p`，代码执行了以下状态转移：

  Java

  ```
  f[j][0] = Math.max(f[j][0], f[j][1] + p);
  ```

  - **今天不持股的最大利润** \= 比较以下两种情况，取较大值：

    1. **昨天也不持股** (`f[j][0]` 保持不变)。
    2. **昨天持股，今天我把它卖了** (`f[j][1] + p`)。卖出动作发生在同一个阶段 $j$ 内。

  Java

  ```
  f[j][1] = Math.max(f[j][1], f[j - 1][0] - p);
  ```

  - **今天持股的最大利润** \= 比较以下两种情况，取较大值：

    1. **昨天就持股** (`f[j][1]` 保持不变)。
    2. **昨天不持股，今天我买入了** (`f[j - 1][0] - p`​)。注意！​**买入股票意味着开启了一个新的交易阶段**​，所以买入的钱是从上一轮交易结算后的利润 `f[j - 1][0]` 扣除的。

  ### 两个关键的细节优化

  #### 1. 为什么倒序遍历 `j`​？ (`for (int j = k + 1; j > 0; j--)`)

  这是因为代码把二维数组（天数 $\times$ 状态）压缩成了一维（只留状态）。

  在计算今天的 `f[j][1]`​ 时，我们需要用到昨天的 `f[j - 1][0]`​。如果是正序遍历（从小到大），`f[j - 1][0]` 就会先被当天的价格更新掉，导致数据污染（这和 0-1 背包问题中必须倒序遍历容量是一个道理）。倒序遍历完美解决了这个问题。

  #### 2. 为什么要除以 2？ (`Integer.MIN_VALUE / 2`)

  初始状态下，我们把不可能发生的状态（比如还没开始交易手里就有股票）设为负无穷。但在 Java 中，如果直接用 `Integer.MIN_VALUE`​，在执行买入操作 `- p`​ 时，会发生​**整型溢出 (Integer Overflow)** ，变成一个巨大的正数。除以 $2$ 既保证了它足够小，又留出了减去股票价格的安全空间。

  ​`f[0][0] = Integer.MIN_VALUE / 2`​ 这一句更是点睛之笔。它直接封死了 `j = 1`​ 时买入股票的可能（导致 `f[1][1]`​ 永远是极小值），从而死死锁住 `f[1][0] = 0` 这个本金源头。

  ### 复杂度分析

  - ​**时间复杂度**：$O(N \cdot k)$。其中 $N$ 是股票数组的长度，$k$ 是允许的最大交易次数。这里 $k=2$，相当于 $O(N)$，只需遍历一次数组，每次遍历进行有限次常数计算。
  - ​**空间复杂度**：$O(k)$。只使用了一个大小为 $(k+2) \times 2$ 的二维数组，与天数 $N$ 无关，非常节省内存。

  ---

  如果把这道题里的 `k = 2`​ 改成通过方法参数传进来的 `k`，这段代码直接就能秒杀 LeetCode 188 (买卖股票的最佳时机 IV)。

  掌握了这个模板后，如果题目加入了\*\*“冷冻期”​**或者**​“手续费”\*\*，你觉得应该在状态机转移方程中的哪个位置加上限制呢？

‍
