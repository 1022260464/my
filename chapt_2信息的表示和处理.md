---
title: chapt_2:信息的表示和处理
date: '2025-03-29 18:37:55'
updated: '2025-07-05 13:58:13'
permalink: /post/chapt2-information-representation-and-processing-zbbjpj.html
comments: true
toc: true
---



![image](assets/微信截图_20250330141706-20250330141752-9a7t4w4.png)

# chapt_2:信息的表示和处理

[第02章：信息的表示和处理 _ CSAPP重点解读.pdf](assets/第02章：信息的表示和处理%20_%20CSAPP重点解读-20250329194203-9hc1iny.pdf)

<span data-type="text" style="background-color: var(--b3-font-background9);">旁注：怎样阅读本章
    本章我们研究在计算机上如何表示数字和其他形式数据的基本属性，以及计算机对这些数据执行操作的属性。这就要求我们深入研究数学语言，编写公式和方程式，以及展示重要属性的推导。</span>

    <span data-type="text" style="background-color: var(--b3-font-background9);">为了帮助你阅读，这部分内容安排如下:首先给出以数学形式表示的属性，作为原理。然后，用例子和非形式化的讨论来解释这个原理。我们建议你反复阅读原理描述和它的示例与讨论，直到你对该属性的说明内容及其重要性有了牢固的直觉。对于更加复杂的属性，还会提供推导，其结构看上去将会像一个数学证明。虽然最终你应该尝试理解这些推导，但在第一次阅读时你可以跳过它们。
     我们也鼓励你在阅读正文的过程中完成练习题，这会促使你主动学习，帮助你理论联系实际。有了这些例题和练习题作为背景知识，再返回推导，你将发现理解起来会容易许多。同时，请放心，掌握好高中代数知识的人都具备理解这些内容所需要的数学技能。</span>

某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则--最低有效字节在最前面的方式，称为**小端法**(little endian)。后一种规则--最高有效字节在最前面的方式，称为**大端法**(bigendian)。

​#字节序（Byte Order）#​

，又称端序或字节顺序，指的是多字节数据在计算机内存中存储时的排列顺序，主要分为两种：**大端序（Big-Endian）和小端序（Little-Endian）** 。这一概念在网络通信、文件存储和跨平台数据传输中尤为重要。

---

### **1. 大端序（Big-Endian）**

* **定义**：数据的高位字节（Most Significant Byte, MSB）存储在低内存地址，低位字节（Least Significant Byte, LSB）存储在高内存地址。
* **特点**：

  * 符合人类阅读习惯（类似十进制数的书写顺序）。
  * 网络协议（如TCP/IP）默认采用大端序（网络字节序）。
* **示例**：

  * 32位整数 `0x12345678`​ 在内存中的存储（地址从左到右递增）：  
    复制

    ```
    地址：0x100  0x101  0x102  0x103
    数据： 0x12   0x34   0x56   0x78
    ```

---

### **2. 小端序（Little-Endian）**

* **定义**：数据的低位字节（LSB）存储在低内存地址，高位字节（MSB）存储在高内存地址。
* **特点**：

  * 现代x86/x64架构CPU通常采用小端序。
  * 直接读取低地址字节即可获取数据的低位部分，适合逐字节处理。
* **示例**：

  * 同样的 `0x12345678`​ 在小端序下的存储：  
    复制

    ```
    地址：0x100  0x101  0x102  0x103
    数据： 0x78   0x56   0x34   0x12
    ```

---

### **3. 如何判断当前系统的字节序？**

以下是一个简单的C代码示例：

c

复制

```
#include <stdio.h>

int main() {
    int num = 0x12345678;
    char *p = (char *)#
    
    if (*p == 0x78) {
        printf("Little-Endian\n");
    } else {
        printf("Big-Endian\n");
    }
    return 0;
}
```

---

### **4. 实际应用中的注意事项**

* **网络通信**：  
  不同主机可能使用不同字节序，因此网络传输时需统一为大端序（通过`htonl()`​、`ntohl()`​等函数转换）。
* **文件格式**：  
  某些文件格式（如PNG、JPEG）明确要求使用大端序。
* **跨平台开发**：  
  在读取二进制数据（如结构体）时，需考虑字节序差异。

---

### **5. 其他字节序**

* **混合端序（Middle-Endian）** ：  
  极少数架构（如PDP-11）使用混合顺序，现已罕见。
* **BI-Endian**：  
  某些CPU（如ARM、PowerPC）支持通过指令切换字节序。

---

### **总结**

|类型|高位字节位置|常见场景|
| --------| --------------| ----------------------------|
|大端序|低内存地址|网络协议、Java虚拟机|
|小端序|高内存地址|x86/x64 CPU、Windows/Linux|

​#移位运算#​

是计算机中对二进制数按位进行移动的操作，分为 **算术移位** 和 **逻辑移位**，具体包括左移和右移两种方向。移位操作在底层编程、算法优化和硬件控制中非常常见。

---

## **1. 左移运算（&lt;&lt;）**

* **定义**：将二进制数的所有位向左移动指定的位数，低位补 `0`​，高位直接丢弃。
* **数学意义**：左移 `n`​ 位等价于乘以 \(2^n\)（无溢出时）。
* **示例（8位二进制）** ：

  ```plaintext
  十进制：5 << 2
  二进制：00000101 → 左移2位 → 00010100
  结果：20 (5 × 2² = 20)
  ```

### **特点**

* 适用于无符号数和有符号数的 **正数**。
* 如果左移后符号位改变（如 `1`​ 移入符号位），有符号数的结果可能是未定义的（UB）{发生溢出}。

---

## **2. 右移运算（&gt;&gt;）**

右移分为 **逻辑右移** 和 **算术右移**，具体行为取决于数据类型：

###  **(1) 逻辑右移（无符号数）**

* **定义**：高位补 `0`​，低位直接丢弃。
* **示例**：

  ```plaintext
  十进制：20 >> 2
  二进制：00010100 → 右移2位 → 00000101
  结果：5 (20 ÷ 2² = 5)
  ```

###  **(2) 算术右移（有符号数）**

* **定义**：高位补 **符号位**（正数补 `0`​，负数补 `1`​），低位丢弃。
* **示例（负数）** ：

  ```plaintext
  十进制：-8 >> 1  （假设8位存储，-8 = 11111000）
  二进制：11111000 → 算术右移1位 → 11111100
  结果：-4 （保持符号不变，相当于 -8 ÷ 2 = -4）
  ```

### **特点**

* C/C++ 中，**有符号数的右移行为由编译器决定**（通常是算术右移）。
* Java 明确区分 `>>`​（算术右移）和 `>>>`​（逻辑右移）。

---

## **3. 移位运算的用途**

###  **(1) 快速乘除 2 的幂**

```c
int a = 10;
a = a << 3;  // a = 10 * 2³ = 80
a = a >> 2;  // a = 80 / 2² = 20
```

###  **(2) 位掩码操作**

```c
// 提取低4位
uint8_t value = 0xAB;  // 10101011
uint8_t low4 = value & 0x0F;  // 00001011 (0x0B)

// 使用移位组合数据
uint16_t high = 0x12, low = 0x34;
uint16_t combined = (high << 8) | low;  // 0x1234
```

###  **(3) 优化算法**

* **二分查找**：`mid = (low + high) >> 1`​ 比除法更快。
* **哈希计算**：如 Java 的 `HashMap`​ 通过 `(n - 1) & hash`​ 替代取模。

---

## **4. 注意事项**

###  **(1) 移位位数不能超过类型宽度**

* 在 C/C++ 中，如果移位位数 `>=`​ 类型的位数（如 `int32 << 32`​），行为是 **未定义的（UB）** 。
* 安全做法：

  ```c
  uint32_t x = 1;
  if (n < 32) x <<= n;  // 避免UB
  ```

###  **(2) 负数左移是未定义行为**

* C/C++ 中，对有符号负数左移（如 `-1 << 1`​）结果未定义。

###  **(3) 结合赋值运算符**

* ​`<<=`​ 和 `>>=`​ 是复合赋值运算符：

  ```c
  int a = 5;
  a <<= 1;  // a = a << 1;
  ```

---

## **5. 代码示例（C/C++/Java/Python）**

### **C/C++**

```c
#include <stdio.h>
int main() {
    unsigned int a = 5;    // 00000101
    printf("%u\n", a << 2); // 20 (00010100)
    
    int b = -8;            // 11111000（补码）
    printf("%d\n", b >> 1); // -4（算术右移，11111100）
    return 0;
}
```

### **Java（明确区分逻辑/算术右移）**

```java
int a = -8;
System.out.println(a >> 1);   // -4（算术右移）
System.out.println(a >>> 1);  // 2147483644（逻辑右移，高位补0）
```

### **Python（无限精度整数）**

```python
a = 5
print(a << 2)  # 20
print(a >> 1)  # 2
```

---

## **总结**

|运算|符号|规则|适用场景|
| ----------| --------------| ------------------------| ------------------|
|左移|​`<<`​|低位补 `0`​，高位丢弃|快速乘法、位组合|
|算术右移|​`>>`​|高位补符号位，低位丢弃|有符号数除法|
|逻辑右移|​`>>>`​（Java）|高位补 `0`​，低位丢弃|无符号数处理|

移位运算高效且灵活，但需注意 **数据类型** 和 **边界条件**，避免未定义行为。

**符号数（Signed Number）和无符号数（Unsigned Number）** 

是计算机中表示整数的两种基本方式，它们的核心区别在于 **是否用最高位表示符号**，这直接影响数值的表示范围和运算行为。c语言[^1]

---

## **1. 核心区别**

|特性|符号数（Signed）|无符号数（Unsigned）|
| ------| ----------------------------| -----------------------|
|**最高位含义**|符号位（0正，1负）|数据位（始终为正）|
|**表示范围**|有正负（如 `int8: -128~127`​）|仅非负（如 `uint8: 0~255`​）|
|**溢出行为**|未定义行为（UB）或回绕|明确回绕（模运算）|
|**移位操作**|右移时补符号位（算术右移）|右移时补0（逻辑右移）|
|**比较运算**|考虑符号位|直接按二进制比较|

---

## **2. 存储方式**

###  **(1) 无符号数**

* 所有位均表示数值，范围是 \(0 \sim 2^n-1\)（`n`​ 为位数）。
* **示例（8位无符号数）** ：

  ```plaintext
  二进制：11001011 → 十进制：203
  ```

###  **(2) 符号数**

* 最高位为符号位，剩余位表示数值（通常用 **补码** 存储）。
* **补码规则**：

  * 正数：与原码相同。
  * 负数：符号位为 `1`​，数值部分按位取反后加 `1`​。
* **示例（8位符号数）** ：

  ```plaintext
  二进制：11001011 
  → 符号位为1（负数）→ 数值部分取反加1：10110101 = -53
  ```

---

## **3. 关键场景对比**

###  **(1) 数值范围**

* **8位整数**：

  * 无符号：`0 ~ 255`​（`0xFF`​）。
  * 有符号：`-128 ~ 127`​（`0x80~0x7F`​）。

###  **(2) 溢出行为**

* **无符号数**：明确回绕（模 \(2^n\)）。

  ```c
  uint8_t a = 255;
  a += 1; // 结果为 0（256 mod 256）
  ```
* **有符号数**：C/C++ 中为未定义行为（UB），实际可能回绕或崩溃。

  ```c
  int8_t b = 127;
  b += 1; // UB！可能变为 -128 或触发异常。
  ```

###  **(3) 比较运算**

* **无符号数**：直接比较二进制值。

  ```c
  0xFF > 0x00 // true（255 > 0）
  ```
* **有符号数**：符号位影响结果。

  ```c
  0xFF > 0x00 // false（-1 > 0？取决于类型！）
  ```

###  **(4) 移位运算**

* **无符号数**：右移补 `0`​（逻辑右移）。

  ```c
  uint8_t x = 0b10001111; // 143
  x >> 2; // 0b00100011 (35)
  ```
* **有符号数**：右移补符号位（算术右移）。

  ```c
  int8_t y = 0b10001111; // -113
  y >> 2; // 0b11100011 (-29)
  ```

---

## **4. 常见问题与陷阱**

###  **(1) 隐式类型转换**

C（通常表示为有符号数）/C++ 中混合运算时，**有符号数会隐式转换为无符号数**，可能导致意外结果：

```c
int a = -1;
unsigned int b = 100;
if (a < b) {
    // 实际执行 false！因为 -1 被转为 0xFFFFFFFF（远大于 100）
}
```

###  **(2) 循环计数器**

无符号数用于递减循环时，小心 **死循环**：

```c
for (unsigned int i = 10; i >= 0; i--) {
    // 当 i = 0 时，i-- 会变为 0xFFFFFFFF，循环永不终止！
}
```

###  **(3) 数据截断**

将有符号数赋值给更小的无符号类型时，可能丢失符号信息：

```c
int32_t x = -1;
uint8_t y = x; // y = 255（0xFF）
```

---

## **5. 如何选择？**

* **用无符号数**：

  * 表示自然数（如年龄、尺寸）。
  * 需要明确的位操作（如掩码、哈希）。
* **用有符号数**：

  * 需要表示负数（如温度、财务数据）。
  * 避免隐式转换导致的逻辑错误。

---

## **6. 代码示例**

### **C/C++**

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    int8_t signed_num = -128;    // 有符号8位
    uint8_t unsigned_num = 255;  // 无符号8位

    printf("有符号数: %d\n", signed_num);     // 输出 -128
    printf("无符号数: %u\n", unsigned_num);   // 输出 255

    // 隐式转换陷阱
    if (signed_num < unsigned_num) {
        printf("预期成立，但实际不执行！\n");
    }
    return 0;
}
```

### **Java（无符号数需手动处理）**

```java
// Java 没有原生无符号类型，但可通过更大类型模拟
int signed = -1;
long unsigned = Integer.toUnsignedLong(signed); // 转为无符号
System.out.println(unsigned); // 输出 4294967295（32位无符号）
```

### **Python（动态类型，无显式声明）**

```python
# Python 整数自动支持大数，无溢出
x = -1
y = x & 0xFFFF  # 模拟无符号16位
print(y)  # 输出 65535
```

---

## **总结**

* **无符号数**：正数、位操作、明确溢出行为。
* **有符号数**：需负数、避免隐式转换问题。
* **关键点**：

  * 补码表示负数是现代计算机的标准。
  * 混合运算时注意类型转换规则。
  * 移位和比较操作的行为差异需牢记。

‍

**例1:**  带符号数产生意外结果的例子。这个例子会造成无限循环，因为sizeof会返回unsigned int 类型，由此带  
来的结果是，i - sizeof(char)这个表达式的求值结果将会是 unsigned int (隐式转换 !!)，无符号数 0 减 1 会变成  
0xFFFFFFFF，从而产生无限循环，有时候你需要特别留心这种不经意的错

```c
int n = 10, i;
for (i = n - 1 ; i - sizeof(char) >= 0; i--)
printf("i: 0x%x\n",i);
if (-1 > 0U) // 神奇的算术!!
printf("You Surprised me!\n");
```

‍

**源码反码补码**

[第02章：信息的表示和处理 _ CSAPP重点解读.pdf](assets/第02章：信息的表示和处理%20_%20CSAPP重点解读-20250329194203-9hc1iny.pdf)

见上述链接，因以在数字逻辑中学习，且原书中多涉及数学层面理论概述，对于非数字电路工作而言不必过多深入学习理论，故不多做赘述。

综合：整数的表示与运算[^2]

浮点数[^4]

本质就是我们如何使用二进制来表达一个很大或者很小的数 (类似科学计数法，但是编码上有显著的区别)，由于二进制的数值系统在表达能力上存在一定的限制 (位数的限制)，我们实际上没有办法表示所有的数，因此浮点数的设计需要认真的权衡和折中，既要考虑能够表达的范围，也要考虑表达的精度，最好还能够(从硬件设计角度来说)简单直接地比较两个浮点数的大小，因此浮点数的设计可能比你想象的要复杂的多，假如今天由你来设计一个新的浮点数标准，你会怎么设计？你可能会觉得这没有意义，如果你这么想,那就错了，请看看谷歌为什么要花费力气来设计自己的BFloat16.  
IEEE-754浮点数表示法，如果用一张可视化视图来表示的话，就像下面这样，设计的还是比较优雅的：

![微信截图_20250330141706](assets/微信截图_20250330141706-20250330141752-9a7t4w4.png)

编码方式：如下图所示（此处仅以32位浮点数为例）：

![微信截图_20250330143843](assets/微信截图_20250330143843-20250330143856-3y2pca3.png)

‍

### **浮点数（Floating-Point）**

#### **1.**  浮点数[^5]**的基本概念**

浮点数是计算机中用于表示实数（包括小数和极大/极小值）的一种方式，遵循 **IEEE 754** 标准。它通过**科学计数法**的形式存储数值，分为三个部分：

* **符号位（Sign）** ：表示正负（0为正，1为负）
* **指数（Exponent）** ：存储科学计数法的“阶码”
* **尾数（Mantissa/Fraction）** ：存储有效数字

#### **2. IEEE 754 浮点数格式**

##### **单精度（32位）**

|部分|位数|说明|
| --------| ------| ------------------------|
|符号位|1|​`0`​=正，`1`​=负|
|指数|8|采用**偏移表示法**（偏置值127）|
|尾数|23|隐含前导`1.`​（规格化数）|

**计算公式**：  
​$[Value=(−1)$​​<sup>$Sign×(1.Mantissa)×2$</sup>​$Exponent−127]$  

##### **双精度（64位）**

|部分|位数|说明|
| --------| ------| ----------------|
|符号位|1|​`0`​=正，`1`​=负|
|指数|11|偏置值1023|
|尾数|52|隐含前导`1.`​|

---

#### **3. 浮点数的特殊值**

|指数|尾数|含义|
| -------| ---------| ------------------|
|全 `0`​|全 `0`​| **±0**（符号位决定）|
|全 `0`​|非全 `0`​|**非规格化数**（极小值）|
|全 `1`​|全 `0`​| **±∞** （如 `1.0/0.0`​）|
|全 `1`​|非全 `0`​|**NaN**（无效运算结果）|

**示例**：

* ​`+0.0`​ 和 `-0.0`​ 在比较时相等，但运算结果可能不同：

  ```c
  assert(+0.0 == -0.0);  // 成立
  assert(1.0 / +0.0 == 1.0 / -0.0);  // 不成立（+∞ ≠ -∞）
  ```
* ​`NaN`​（Not a Number）表示无效运算：

  ```c
  sqrt(-1.0);  // 返回 NaN
  assert(NaN != NaN);  // NaN 不等于任何值（包括自己）
  ```

---

#### **4.**  浮点数运算规则[^6]

#####  **(1) 加减法**

1. **对阶**：小指数向大指数对齐（右移尾数）
2. **尾数加减**：直接计算
3. **规格化**：调整指数使尾数符合 `1.M`​ 形式
4. **舍入**：就近舍入（Round to Nearest）

**示例**：

```c
float a = 1.0e8f, b = 1.0f;
printf("%f", a + b);  // 输出 1.0e8（b 被丢弃）
```

#####  **(2) 乘法**

1. **指数相加**：\( E = E1 + E2 - \text{Bias} \)
2. **尾数相乘**：\( (1.M1) \times (1.M2) \)
3. **规格化 + 舍入**

#####  **(3) 除法**

1. **指数相减**：\( E = E1 - E2 + \text{Bias} \)
2. **尾数相除**：\( (1.M1) / (1.M2) \)
3. **规格化 + 舍入**

---

#### **5. 浮点数精度问题**

* **大数吃小数**：对阶时小尾数右移丢失有效位
* **舍入误差**：十进制小数无法精确表示（如 `0.1`​）
* **解决方案**：

  * 使用 `double`​ 提高精度
  * 避免直接比较浮点数：

    ```c
    #define EPSILON 1e-6
    if (fabs(a - b) < EPSILON) { /* 视为相等 */ }
    ```

---

#### **6. 特殊运算结果**

|运算|结果|原因|
| ------| ------| ----------------------------|
|​`∞ + ∞`​|​`+∞`​|同号无穷相加|
|​`∞ - ∞`​|​`NaN`​|无穷差值无定义|
|​`∞ × 0`​|​`NaN`​|未定式（极限可能为任意值）|
|​`0.0 / 0.0`​|​`NaN`​|未定义操作|
|​`1.0 / 0.0`​|​`+∞`​|正数除正零|
|​`-1.0 / 0.0`​|​`-∞`​|负数除正零|

---

#### **7. 代码示例**

#####  **(1) 浮点数二进制解析**

```python
import struct
def float_to_bin(f):
    return ''.join(f'{b:08b}' for b in struct.pack('!f', f))

float_to_bin(3.14)  # 输出：01000000010010001111010111000011
```

#####  **(2) 检测特殊值（C语言）**

```c
#include <math.h>
#include <stdio.h>

int main() {
    double x = 1.0 / 0.0;
    if (isinf(x)) {
        printf("x 是无穷大\n");
    }
    if (isnan(x)) {
        printf("x 是 NaN\n");
    }
    return 0;
}
```

---

#### **8. 关键总结**

* **IEEE 754** 通过 **符号+指数+尾数** 表示浮点数。
* **特殊值**（±0、±∞、NaN）需单独处理。
* **运算规则**：对阶 → 计算 → 规格化 → 舍入。
* **避免误差**：使用更高精度或误差容忍比较。

理解这些规则，可以避免数值计算中的常见陷阱！

拓展：信息的处理[^7]

拓展：数值系统的安全性：旁路攻击与常数时间编程[^8]

拓展：未定义行为[^9]

‍

‍

[^1]: # c语言中的符号数和无符号数

    在C语言中，**有符号数（Signed）** 和**无符号数（Unsigned）** 是两种基本的整数表示方式，它们的核心区别在于**是否用最高位表示符号**，这直接影响数值范围、运算行为和编译器优化。以下是详细解析：

    ---

    ### **1. 存储方式与范围**

    ####  **(1) 无符号数（Unsigned）**

    * **最高位是数据位**，不表示符号，所有位均用于表示数值。
    * **范围**：\(0 \sim 2^n-1\)（`n`​为位数）。

      ```c
      uint8_t a = 255;  // 8位无符号：0~255
      ```

    ####  **(2) 有符号数（Signed）**

    * **最高位是符号位**（0正，1负），剩余位表示数值（通常用**补码**存储）。
    * **范围**：\(-2<sup>{n-1} \sim 2</sup>{n-1}-1\)。

      ```c
      int8_t b = -128;  // 8位有符号：-128~127
      ```

    #### **补码表示负数的原理**

    * 正数：与原码相同（如 `+5`​ = `00000101`​）。
    * 负数：符号位为 `1`​，数值部分按位取反后加 `1`​（如 `-5`​ = `11111011`​）。

    ---

    ### **2. 关键区别与行为对比**

    |**行为**|无符号数（Unsigned）|有符号数（Signed）|
    | --| ------------------------------| ----------------------------------|
    |**溢出**|明确回绕（模 \(2^n\)）|未定义行为（UB），可能崩溃或回绕|
    |**右移操作**|逻辑右移（高位补 `0`​）|算术右移（高位补符号位）|
    |**比较运算**|直接按二进制比较|符号位影响结果|
    |**与负数比较**|负数被隐式转换为大正数|正常比较|

    ---

    ### **3. 常见陷阱与示例**

    ####  **(1) 隐式类型转换**

    C语言中，**混合运算时，有符号数会隐式转换为无符号数**，可能导致逻辑错误：

    ```c
    int a = -1;
    unsigned int b = 100;
    if (a < b) { 
        // 实际为 false！因为 -1 被转为 0xFFFFFFFF（远大于 100）
    }
    ```
    ####  **(2) 循环计数器**

    无符号数递减到 `0`​ 后再减 `1`​ 会变为最大值，导致死循环：

    ```c
    for (unsigned int i = 10; i >= 0; i--) {
        // 当 i=0 时，i-- 变为 0xFFFFFFFF，循环永不终止！
    }
    ```
    ####  **(3) 数据截断**

    将有符号数赋值给更小的无符号类型时，符号位被当作数据位：

    ```c
    int32_t x = -1;
    uint8_t y = x; // y = 255（0xFF）
    ```
    ---

    ### **4. 如何安全使用？**

    ####  **(1) 明确类型声明**

    * 需要负数时用 `int`​、`int32_t`​ 等有符号类型。
    * 仅非负值时用 `unsigned int`​、`uint32_t`​。

    ####  **(2) 避免隐式转换**

    * 显式强制类型转换：

      ```c
      int a = -1;
      unsigned int b = 100;
      if ((int)a < (int)b) { ... } // 强制转为有符号比较
      ```

    ####  **(3) 检查溢出**

    * 无符号数加法检查：

      ```c
      unsigned int a = UINT_MAX - 10;
      if (a + 20 < a) { /* 溢出发生 */ }
      ```
    * 有符号数溢出是UB，需手动判断：

      ```c
      int a = INT_MAX - 10;
      if (a > INT_MAX - 20) { /* 可能溢出 */ }
      ```

    ---

    ### **5. 代码示例**

    ####  **(1) 补码验证**

    ```c
    #include <stdio.h>
    #include <stdint.h>

    int main() {
        int8_t x = -5;
        // 输出二进制表示（补码）
        for (int i = 7; i >= 0; i--) {
            printf("%d", (x >> i) & 1);
        }
        // 输出：11111011
        return 0;
    }
    ```
    ####  **(2) 无符号数回绕**

    ```c
    #include <stdio.h>
    #include <limits.h>

    int main() {
        unsigned int a = UINT_MAX;
        printf("%u\n", a + 1); // 输出 0（回绕）
        return 0;
    }
    ```
    ####  **(3) 有符号数右移**

    ```c
    #include <stdio.h>

    int main() {
        int8_t x = -8;      // 二进制：11111000
        int8_t y = x >> 1;  // 算术右移：11111100 (-4)
        printf("%d\n", y);  // 输出 -4
        return 0;
    }
    ```
    ---

    ### **6. 总结**

    * **无符号数**：适合位操作、非负值场景，溢出行为明确。
    * **有符号数**：需表示负数时使用，但需警惕UB和隐式转换。
    * **关键规则**：

      * 混合运算时，有符号数隐式转为无符号数。
      * 右移时，无符号数补 `0`​，有符号数补符号位。
      * 有符号数溢出是未定义行为，需主动避免。

    ![微信截图_20250329213428](assets/微信截图_20250329213428-20250329215056-2t0gkqw.png)

    ![微信截图_20250329213448](assets/微信截图_20250329213448-20250329215056-kpk14eo.png)


[^2]: # 综合：整数的表示与运算

    在计算机中，整数的运算与表示是计算机科学和数字电路设计的核心基础之一。以下是关于整数在计算机中的表示和运算的详细说明：

    ---

    ### 1. **整数的表示**

    计算机通过二进制（0和1）表示整数，具体方式取决于整数的类型（有符号/无符号）和编码方案。

    #### （1）**无符号整数（Unsigned Integers）**

    * **定义**：仅表示非负整数（0及正数）。
    * **表示方法**：

      * 直接使用二进制位权值表示。例如，8位无符号整数的范围是 `0`​（`00000000`​）到 `255`​（`11111111`​）。
    * **范围**：
      若位数为 `n`​，范围为 `0`​ 到 `2^n - 1`​。

    #### （2）**有符号整数（Signed Integers）**

    负数的表示需要通过特定编码方案，常见的有以下三种：

    ##### a. **原码（Sign-Magnitude）**

    * **规则**：最高位表示符号（0正1负），其余位表示绝对值。

      * 例如，8位原码中：
        `+5`​ = `00000101`​，
        `-5`​ = `10000101`​。
    * **问题**：存在 `+0`​（`00000000`​）和 `-0`​（`10000000`​），不利于运算。

    ##### b. **反码（Ones' Complement）**

    * **规则**：正数与原码相同；负数是其绝对值的原码按位取反。

      * 例如，8位反码中：
        `-5`​ = `11111010`​（对 `00000101`​ 取反）。
    * **问题**：仍存在 `+0`​（`00000000`​）和 `-0`​（`11111111`​）。

    ##### c. **补码（Two's Complement）** （现代计算机通用方案）

    * **规则**：

      * 正数与原码相同。
      * 负数 = 其绝对值的原码取反后加 `1`​（忽略溢出）。
      * 例如，8位补码中：
        `-5`​ = `11111011`​（`00000101`​ → 取反 `11111010`​ → 加 `1`​）。
    * **优势**：

      * 唯一表示 `0`​（`00000000`​），`-128`​（8位）可以表示。
      * 加减法可直接用硬件实现，无需额外处理符号。
    * **范围**：
      `n`​ 位补码的范围是 `-2^(n-1)`​ 到 `2^(n-1)-1`​（如8位为 `-128`​ 到 `127`​）。

    ---

    ### 2. 整数的运算[^3]

    计算机通过数字逻辑电路（如加法器）执行整数运算，所有运算最终转换为二进制操作。

    #### （1）**加减法**

    * **补码的统一性**：加减法均使用补码直接运算，无需区分符号。

      * 例如，`5 - 3`​ = `5 + (-3)`​：
        `00000101`​（5） + `11111101`​（-3） = `00000010`​（2）。
    * **溢出（Overflow）** ：
      当结果超出表示范围时，高位进位会被丢弃（或触发溢出异常）。

    #### （2）**乘除法**

    * **乘法**：通过移位-加法实现（如 Booth 算法优化）。
    * **除法**：通过移位-减法实现（如恢复余数法或非恢复余数法）。

    #### （3）**位运算**

    * **与（AND）、或（OR）、非（NOT）、异或（XOR）** ：直接对二进制位操作。
    * **移位**：

      * 逻辑移位（无符号数）：空缺补 `0`​。
      * 算术移位（有符号数）：右移时补符号位（保持符号）。

    ---

    ### 3. **常见问题与注意事项**

    * **溢出检测**：
      若两个正数相加结果为负（或两个负数相加结果为正），说明补码溢出。
    * **符号扩展**：
      短位数扩展为长位数时（如 `int16`​ → `int32`​），需复制符号位填充高位。
    * **字节序（Endianness）** ：
      多字节整数的存储顺序（大端序高位在前，小端序低位在前）影响跨平台数据解析。

    ---

    ### 4. **编程语言中的整数**

    * **C/C++** ：`int`​、`unsigned int`​ 的具体位数由编译器决定（通常32位）。
    * **Java**：明确位数（如 `int`​ 为32位补码，`long`​ 为64位）。
    * **Python**：整数长度动态扩展（无固定位数限制）。

    ---

    ### 示例：8位补码运算

    * **计算**  **​`-7 + 6`​**​：
      `-7`​ = `11111001`​，`6`​ = `00000110`​ →
      `11111001 + 00000110 = 11111111`​（结果为 `-1`​）。
    * **溢出示例**：
      `127 + 1`​ = `01111111 + 00000001 = 10000000`​（补码表示 `-128`​，溢出）。

    ---

    通过理解整数的二进制表示和运算规则，可以更好地处理编程中的数值计算、位操作以及潜在的溢出问题。

    ‍


[^3]: ### **计算机中整数的运算详解**

    在计算机中，整数的运算主要基于二进制表示和数字逻辑电路实现。运算包括**算术运算（加、减、乘、除）** 和**位运算（与、或、非、移位等）** 。由于计算机使用固定位宽存储整数，运算时需考虑**溢出、符号处理**等问题。以下是详细说明：

    ---


[^4]: # 浮点数详解

    ### **浮点数的构成详解（IEEE 754 标准）** 

    浮点数是计算机中用于表示实数（含小数）的一种数据类型，遵循 **IEEE 754 标准**。其核心思想是通过**科学计数法**的二进制形式存储数值，分为三个部分：**符号位（Sign）** 、**指数位（Exponent）**  和 **尾数位（Mantissa/Fraction）** 。

    ---

    ## **1. IEEE 754 浮点数的通用结构**

    以最常见的 **32 位单精度（float）**  和 **64 位双精度（double）**  为例：

    |组成部分|符号位（S）|指数位（E）|尾数位（M）|总位数|
    | --------| -----------| -----------| -----------| -------|
    |**float（单精度）**|1 bit|8 bits|23 bits|32 bits|
    |**double（双精度）**|1 bit|11 bits|52 bits|64 bits|

    ---

    ## **2. 各部分的详细作用**

    ###  **(1) 符号位（Sign）**

    * **1 bit**：`0`​ 表示正数，`1`​ 表示负数。
    * 例如：`-3.14`​ 的符号位为 `1`​。

    ###  **(2) 指数位（Exponent）**

    * **存储科学计数法中的指数**，但采用 **偏移码（Bias）**  表示：

      * **float（8 位）** ：偏移量 = `127`​，实际指数 = `E - 127`​。
      * **double（11 位）** ：偏移量 = `1023`​，实际指数 = `E - 1023`​。
    * **特殊值处理**：

      * ​`E = 0`​：表示非规格化数（Subnormal）或零。
      * ​`E = 全1`​：表示无穷大（Infinity）或 NaN（非数字）。

    ###  **(3) 尾数位（Mantissa）**

    * **存储科学计数法中的小数部分**（隐含开头的 `1.`​）。

      * 例如：二进制数 `1.1011`​ 的尾数存储为 `1011`​（省略 `1.`​）。
    * **非规格化数**（E=0）：尾数不隐含 `1.`​，直接表示为 `0.xxx`​。

    ---

    ## **3. 浮点数的表示公式**

    浮点数的实际值计算公式：
    ​$[ \text{Value} = (-1)$​<sup>$S \times (1 + M) \times 2$</sup>​${E - \text{Bias}}$
    ​$]$

    * **规格化数（E ≠ 0 且 E ≠ 全 1）** ：

      * 尾数隐含 `1.`​，即实际值为 `1.M`​。
    * **非规格化数（E = 0）** ：

      * 尾数为 `0.M`​，指数固定为 `1 - Bias`​（避免下溢）。

    ---

    ## **4. 单精度（float）示例**

    以 `-12.375`​ 为例，转换为 IEEE 754 单精度浮点数：

    #### **步骤 1：转换为二进制**

    * 整数部分：`12`​ → `1100`​
    * 小数部分：`0.375`​ → `0.011`​（因为 `0.5×0 + 0.25×1 + 0.125×1 = 0.375`​）
    * 合并：`12.375`​ → `1100.011`​ → 科学计数法 `1.100011 × 2³`​

    #### **步骤 2：填充三部分**

    1. **符号位（S）** ：`1`​（负数）。
    2. **指数位（E）** ：`3 + 127 = 130`​ → `10000010`​（二进制）。
    3. **尾数位（M）** ：`100011`​（补全到 23 位：`10001100000000000000000`​）。

    #### **步骤 3：最终二进制表示**

    ```
    1 10000010 10001100000000000000000
    ```
    转换为十六进制：`0xC14C0000`​。

    ---

    ## **5. 特殊值**

    |指数（E）|尾数（M）|含义|
    | ---------| ---------| --------------|
    |全 0|全 0| **±0**（符号位决定）|
    |全 0|非全 0|**非规格化数**|
    |全 1|全 0| **±∞** （无穷大）|
    |全 1|非全 0|**NaN**（非数字）|

    ---

    ## **6. 浮点数的精度问题**

    由于二进制浮点数的固有限制，某些十进制小数无法精确表示（如 `0.1`​），导致**舍入误差**。例如：

    ```c
    float a = 0.1 + 0.2;  // 实际存储值可能为 0.30000001192092896
    ```
    ---

    ## **7. 总结**

    * **符号位**：决定正负。
    * **指数位**：存储科学计数法的指数（带偏移量）。
    * **尾数位**：存储小数部分（隐含 `1.`​）。
    * **IEEE 754** 是浮点数的通用标准，但需注意精度限制。

    通过理解浮点数的存储结构，可以更好地处理数值计算、避免精度问题，并在需要时直接操作二进制位（如高性能计算或数据解析）。

    ---

    ### **浮点数运算规则详解（IEEE 754 标准）** 

    浮点数的运算规则是计算机科学中的核心内容，涉及**加减乘除**、**舍入模式**、**特殊值处理**等。以下是基于 **IEEE 754 标准** 的详细说明：

    ---

    ## **1. 浮点数运算的基本步骤**

    所有浮点数运算均遵循以下流程：

    1. **对阶**：统一两个操作数的指数（使指数相同）。
    2. **尾数运算**：对对齐后的尾数进行加减乘除。
    3. **规格化**：将结果调整为标准科学计数法形式（`1.M × 2^E`​）。
    4. **舍入**：根据设定的舍入模式处理多余位数。
    5. **溢出/下溢检查**：判断结果是否超出表示范围。

    ---

    ## **2. 浮点数加减法**

    ### **步骤说明（以加法为例）**

    1. **对阶**：

       * 比较两个数的指数 `E1`​ 和 `E2`​，将较小的指数调整到与较大的相同。
       * 例如：`1.1 × 2^3`​ + `1.01 × 2^1`​ → 对阶后：`1.1 × 2^3`​ + `0.0101 × 2^3`​。
    2. **尾数相加**：

       * 直接对尾数进行加减：`1.1 + 0.0101 = 1.1101`​。
    3. **规格化**：

       * 若结果尾数溢出（如 `10.1101`​），右移尾数并增加指数：`1.01101 × 2^4`​。
    4. **舍入**：

       * 根据模式（如四舍五入）截断多余位。
    5. **检查特殊值**：

       * 若结果为 `NaN`​ 或 `±∞`​，触发异常或返回相应值。

    ### **示例（单精度浮点加法）**

    计算 `0.5`​（`0x3F000000`​） + `0.25`​（`0x3E800000`​）：

    1. 对阶：

       * ​`0.5`​ = `1.0 × 2^-1`​，`0.25`​ = `1.0 × 2^-2`​ → 调整后者为 `0.1 × 2^-1`​。
    2. 尾数相加：`1.0 + 0.1 = 1.1`​。
    3. 结果：`1.1 × 2^-1`​ = `0.75`​（`0x3F400000`​）。

    ---

    ## **3. 浮点数乘法**

    ### **步骤说明**

    1. **指数相加**：

       * ​`E_{\text{result}} = E1 + E2 - \text{Bias}`​（抵消双偏移量）。
    2. **尾数相乘**：

       * 直接相乘（隐含的 `1.`​ 需显式处理）：`(1.M1) × (1.M2)`​。
    3. **规格化**：

       * 若尾数结果 ≥ 2，右移并调整指数（如 `10.1101`​ → `1.01101`​，指数 +1）。
    4. **舍入与符号处理**：

       * 符号位 = `S1 XOR S2`​（异或决定正负）。

    ### **示例（单精度浮点乘法）**

    计算 `1.5`​（`0x3FC00000`​） × `2.0`​（`0x40000000`​）：

    1. 指数相加：`127 + 128 - 127 = 128`​。
    2. 尾数相乘：`1.1`​ × `1.0`​ = `1.1`​。
    3. 结果：`1.1 × 2^1`​ = `3.0`​（`0x40400000`​）。

    ---

    ## **4. 浮点数除法**

    ### **步骤说明**

    1. **指数相减**：

       * ​`E_{\text{result}} = E1 - E2 + \text{Bias}`​。
    2. **尾数相除**：

       * ​`(1.M1) / (1.M2)`​，使用硬件除法器或迭代算法。
    3. **规格化**：

       * 若尾数结果 < 1，左移并减少指数（如 `0.1101`​ → `1.101`​，指数-1）。
    4. **舍入与符号处理**：

       * 符号位 = `S1 XOR S2`​。

    ### **示例（单精度浮点除法）**

    计算 `6.0`​（`0x40C00000`​） / `2.0`​（`0x40000000`​）：

    1. 指数相减：`129 - 128 + 127 = 128`​。
    2. 尾数相除：`1.1`​ / `1.0`​ = `1.1`​。
    3. 结果：`1.1 × 2^1`​ = `3.0`​（`0x40400000`​）。

    ---

    ## **5. 舍入模式（Rounding Modes）**

    |IEEE 754 定义了四种舍入模式：||
    |模式|规则|
    | -----------------------------| ----------------------------------------------|
    |**最近偶数（Round to Nearest, Even）**|默认模式，四舍五入，若居中则向最近的偶数舍入。|
    |**向零舍入（Round Toward Zero）**|直接截断多余位（向零靠近）。|
    |**正向无穷（Round Up）**|向正无穷方向舍入。|
    |**负向无穷（Round Down）**|向负无穷方向舍入。|

    ---

    ## **6. 特殊值处理**

    |运算场景|结果规则|
    | --------| -------------------------------|
    | **∞ 参与运算**|​`±∞ + x = ±∞`​，`∞ × 0 = NaN`​，`∞ / ∞ = NaN`​|
    |**NaN 参与运算**|任何包含 `NaN`​ 的运算结果均为 `NaN`​。|
    |**零除零（0/0）**|结果为 `NaN`​。|
    |**非零数除零（x/0）**|结果为 `±∞`​（符号由分子决定）。|

    ---

    ## **7. 精度问题与注意事项**

    * **精度损失**：
      浮点运算可能因舍入或对阶丢失精度（如 `0.1 + 0.2 ≠ 0.3`​）。
    * **结合律不成立**：
      `(a + b) + c ≠ a + (b + c)`​，因对阶和舍入顺序不同。
    * **避免大数加小数**：
      对阶时小数尾数可能被右移丢弃（如 `1e20 + 1 = 1e20`​）。

    ---

    ## **8. 代码示例（C 语言）**

    ```c
    #include <stdio.h>
    #include <math.h>

    int main() {
        float a = 0.1f, b = 0.2f;
        float c = a + b;
        printf("0.1 + 0.2 = %.20f\n", c); // 输出可能非精确 0.3

        double x = 1e20, y = 1.0;
        printf("1e20 + 1 = %f\n", x + y); // 输出 1e20（精度丢失）
        return 0;
    }
    ```
    ---

    ## **9. 总结**

    |关键点|说明|
    | ------| ---------------------------------------------|
    |**对阶**|统一指数，小指数数尾数右移。|
    |**尾数运算**|加减乘除后需规格化。|
    |**舍入模式**|默认“最近偶数”，影响最终精度。|
    |**特殊值**|​`NaN`​、`±∞`​ 需单独处理。|
    |**精度陷阱**|避免直接比较浮点数，应使用误差范围（如 `fabs(a - b) < 1e-6`​）。|

    理解浮点数运算规则对科学计算、金融系统等场景至关重要，可有效避免隐蔽的错误！

    ### **浮点数精度问题详解**

    浮点数在计算机中的表示和运算存在固有精度限制，这是由 **IEEE 754 标准** 的二进制存储方式决定的。以下是关于浮点数精度问题的全面解析：

    ---

    ## **1. 为什么浮点数会有精度问题？**

    ###  **(1) 二进制无法精确表示某些十进制小数**

    * 例如，十进制的 `0.1`​ 在二进制中是无限循环小数：

      ```
      0.1 (十进制) = 0.00011001100110011... (二进制)
      ```
    * 单精度浮点数（32 位）只能存储 23 位尾数，因此会截断或舍入，导致误差。

    ###  **(2) 浮点数的存储结构限制**

    * **尾数位数有限**：

      * ​`float`​：23 位尾数 → 约 6-7 位有效十进制数字。
      * ​`double`​：52 位尾数 → 约 15-16 位有效十进制数字。
    * **指数范围有限**：

      * 超大（如 `1e30`​）或超小（如 `1e-30`​）的数可能溢出或下溢。

    ---

    ## **2. 典型精度问题示例**

    ###  **(1) 十进制小数运算误差**

    ```c
    #include <stdio.h>
    int main() {
        float a = 0.1f;
        float b = 0.2f;
        float c = a + b;
        printf("0.1 + 0.2 = %.20f\n", c); 
        // 输出：0.1 + 0.2 = 0.30000001192092895508（非精确0.3）
        return 0;
    }
    ```
    ###  **(2) 大数吃小数**

    ```c
    float x = 1e8f;      // 100,000,000
    float y = 1.0f;
    float z = x + y;     // 结果仍是 100,000,000（y被丢弃）
    ```
    ###  **(3) 累积误差**

    ```c
    float sum = 0.0f;
    for (int i = 0; i < 10000; i++) {
        sum += 0.1f;     // 理论值应为1000，实际存在误差
    }
    ```
    ---

    ## **3. 精度问题的根本原因**

    |原因|说明|
    | ----| ------------------------------------------------------|
    |**二进制截断**|无法精确表示某些十进制小数（如 `0.1`​）。|
    |**舍入误差**|运算结果超出尾数位数时需舍入（如四舍五入）。|
    |**对阶损失**|大数加小数时，小数的有效位可能在对阶过程中被右移丢弃。|
    |**非结合性**|​`(a + b) + c ≠ a + (b + c)`​，运算顺序影响结果。|

    ---

    ## **4. 如何避免精度问题？**

    ###  **(1) 使用更高精度的类型**

    * 优先选择 `double`​（64 位）而非 `float`​（32 位）：

      ```c
      double a = 0.1, b = 0.2;
      double c = a + b;  // 误差更小（但仍存在）
      ```

    ###  **(2) 避免直接比较浮点数**

    * 用误差范围（Epsilon）代替严格相等：

      ```c
      #include <math.h>
      if (fabs(a - b) < 1e-6) {  // 判断是否“近似相等”
          printf("a ≈ b\n");
      }
      ```

    ###  **(3) 调整运算顺序**

    * 大数相加时，先加小数后加大数：

      ```c
      float sum = 0.0f;
      for (int i = 0; i < 10000; i++) {
          sum += 0.1f;   // 误差累积
      }
      // 改为分段求和或使用Kahan求和算法
      ```

    ###  **(4) 使用定点数或符号运算**

    * **定点数**：用整数表示小数（如货币计算中 `1.23元`​ → `123分`​）。
    * **符号库**：如 GMP（GNU 多精度算术库）处理高精度需求。

    ---

    ## **5. 特殊值导致的精度问题**

    |值|问题|
    | --| ---------------------------------------|
    |**NaN**|无效操作（如 `0/0`​）会污染后续计算。|
    | **±Inf**|溢出结果不可逆（如 `1e300 * 1e300`​ 返回 `Inf`​）。|
    |**非规格化数**|极小的数（如 `1e-45`​）可能因精度丢失变为零。|

    ---

    ## **6. 实际应用建议**

    1. **科学计算**：优先使用 `double`​，避免多次迭代累积误差。
    2. **金融系统**：改用整数或十进制库（如 Java 的 `BigDecimal`​）。
    3. **游戏开发**：对物理引擎的关键参数使用双精度或固定误差范围。

    ---

    ## **7. 代码示例：Kahan 求和算法**

    减少累加误差的经典方法：

    ```c
    #include <stdio.h>

    float kahanSum(float *arr, int n) {
        float sum = 0.0f, c = 0.0f;  // c为补偿值
        for (int i = 0; i < n; i++) {
            float y = arr[i] - c;     // 修正当前值
            float t = sum + y;        // 临时和
            c = (t - sum) - y;        // 计算误差
            sum = t;
        }
        return sum;
    }

    int main() {
        float data[10000];
        for (int i = 0; i < 10000; i++) data[i] = 0.1f;
        printf("Kahan求和结果: %.10f\n", kahanSum(data, 10000));
        return 0;
    }
    ```
    ---

    ## **8. 总结**

    |关键点|解决方案|
    | ------| ----------------------------|
    |**小数精度丢失**|使用 `double`​ 或符号库。|
    |**大数吃小数**|调整运算顺序，优先处理小数。|
    |**比较浮点数**|使用误差范围（如 `fabs(a - b) < 1e-6`​）。|
    |**累积误差**|采用 Kahan 求和等算法。|

    理解浮点数精度问题的本质，能帮助你在实际开发中选择合适的解决方案，避免隐蔽的数学错误！

    ---

    ### **浮点数的特殊值解析（IEEE 754 标准）** 

    +0 和 -0？+∞ 和 -∞？1.0/0.0 = −1.0/−0.0 = +∞, 1.0/−0.0 = −∞，NaN (Not a Number) => 不是一个数，那是什
    么鬼 ? 请你考虑 ∞ - ∞，∞ × 0，它们的计算结果会是什么？

    ```c
    // Demo_3
    #include <assert.h>
    int main(){
    assert(+0. == -0.); // 断言成功
    assert(1.0/+0. == 1.0/-0.); // 断言失败
    return 0;
    }
    ```
    ---

    #### **1. 为什么存在 +0 和 -0？**

    * **IEEE 754 设计**：符号位独立于数值，允许零的符号保留。
    * **实际意义**：

      * ​`+0`​：趋近于零的正数极限（如 \( \lim_{x \to 0^+} x \)）
      * ​`-0`​：趋近于零的负数极限（如 \( \lim_{x \to 0^-} x \)）
    * **行为差异**：

      ```c
      1.0 / +0.0 == +∞  // 正无穷
      1.0 / -0.0 == -∞  // 负无穷
      ```
    * **比较规则**：

      ```c
      +0.0 == -0.0  // 值为真（但符号不同）
      ```

    ---

    #### **2. +∞ 和 -∞ 的来源**

    * **触发场景**：

      * 溢出：`1e308 * 10.0`​ → `+∞`​
      * 除零：`1.0 / +0.0`​ → `+∞`​，`1.0 / -0.0`​ → `-∞`​
    * |**运算规则**：||
      |运算|结果|
      | ----| ----------------|
      |​`∞ + ∞`​|​`+∞`​|
      |​`∞ - ∞`​|**NaN**|
      |​`∞ × 0`​|**NaN**|
      |​`∞ / ∞`​|**NaN**|
      |​`±∞ > x`​|​`true`​（x 非 NaN）|

    ---

    #### **3. NaN（Not a Number）的本质**

    * **产生原因**：

      * 无效运算：`√(-1.0)`​、`∞ - ∞`​、`0 × ∞`​
      * 未定义操作：`0/0`​
    * **特性**：

      * **传染性**：任何包含 NaN 的运算结果均为 NaN。
      * **无序性**：`NaN != NaN`​，`NaN > 5`​ 均为 `false`​。
    * **检查方法**：

      ```c
      #include <math.h>
      isnan(x);  // 返回1表示x是NaN
      ```

    ---

    #### **4. 特殊运算示例**

    #####  **(1) ∞ - ∞**

    * **结果**：`NaN`​
    * **原因**：无穷大无法确定差值（如 \( \lim_{x \to ∞} (x - x) \) 形式不确定）。

    #####  **(2) ∞ × 0**

    * **结果**：`NaN`​
    * **原因**：属于未定式（如 \( \lim_{x \to ∞} x \times \frac{1}{x} = 1 \)，但 \( \lim_{x \to ∞} x \times 0 = 0 \) 冲突）。

    #####  **(3) 1.0 / 0.0 与 -1.0 / -0.0**

    ```c
    1.0 / +0.0 == +∞  // 断言成功
    1.0 / -0.0 == -∞  // 断言失败（与上行结果不同）
    ```
    ---

    #### **5. 代码示例分析**

    ```c
    #include <assert.h>
    #include <math.h>

    int main() {
        assert(+0. == -0.);          // 成功：值相等
        assert(1.0 / +0. == 1.0 / -0.); // 失败：+∞ != -∞
        assert(isinf(1.0 / +0.));    // 成功：检测+∞
        return 0;
    }
    ```
    * **关键点**：

      * 零的相等性由**值**决定，但符号影响运算结果。
      * 除零的符号决定无穷的符号。

    ---

    #### **6. 编程中的注意事项**

    * **避免除零**：检查分母是否为零。
    * **NaN 处理**：

      ```c
      if (isnan(result)) {
          // 处理无效运算
      }
      ```
    * **比较浮点数**：

      ```c
      #define EPSILON 1e-9
      fabs(a - b) < EPSILON;  // 代替 a == b
      ```

    ---

    ### **总结表**

    |表达式|结果|原因|
    | ------| ----| ----------------|
    |​`+0.0 == -0.0`​|​`true`​|值相同，符号不同|
    |​`1.0 / +0.0`​|​`+∞`​|正数除正零|
    |​`1.0 / -0.0`​|​`-∞`​|正数除负零|
    |​`∞ - ∞`​|​`NaN`​|无穷差值无定义|
    |​`NaN == NaN`​|​`false`​|NaN 具有无序性|

    理解这些规则可避免数值计算中的隐蔽错误！

    ### **浮点数运算的非结合性与非分配性详解**

    特别注意：浮点数加法和乘法不满足结合律 ，也不满足乘法对加法的分配律，以下举例说明：
    (3.14+1e10)-1e10 = 0, 3.14+(1e10-1e10) = 3.14，(1e20 *1e20) * 1e-20= inf, 1e20 * (1e20 * 1e-20)= 1e20
    1e20 * (1e20 - 1e20)= 0.0, 1e20 * 1e20 - 1e20 * 1e20 = NaN
    这些特殊的数学性质对于科学计算程序员和编译器的优化限制都具有重要意义，举例如下：

    ```c
    x = a + b + c;
    y = b + c + d;
    // 编译器可能试图通过产生下列代码来省去一个浮点加法
    t = b + c;
    x = a + t;
    y = t + d;
    // 但是对x来说，这个计算可能会产生于原始值不同的值,因为它使用了加法运算的不同结合方式
    ```
    浮点数在计算机中的存储和运算遵循 IEEE 754 标准，但由于**精度有限**和**舍入误差**，其算术运算与数学中的实数运算存在本质差异。最关键的差异是：
    **浮点数加法和乘法不满足结合律，乘法对加法也不满足分配律**。
    这些特性对科学计算和编译器优化有深远影响。

    ---

    ### **1. 为什么浮点数运算不满足结合律？**

    ####  **(1) 加法结合律失效**

    **数学中的加法结合律**：
    \( (a + b) + c = a + (b + c) \)
    **浮点数中的反例**：

    ```c
    // 案例1：大数吃小数
    float a = 3.14f, b = 1e10f, c = -1e10f;
    float r1 = (a + b) + c; // (3.14 + 1e10) - 1e10 → 0
    float r2 = a + (b + c); // 3.14 + (1e10 - 1e10) → 3.14
    printf("%f vs %f\n", r1, r2); // 输出: 0.000000 vs 3.140000
    ```
    **原因**：

    * ​`a + b`​ 时，`3.14`​ 的精度被 `1e10`​ 吞噬（对阶后尾数丢失）。
    * ​`b + c`​ 时直接抵消，保留 `a`​ 的完整精度。

    ####  **(2) 乘法结合律失效**

    **数学中的乘法结合律**：
    \( (a \times b) \times c = a \times (b \times c) \)
    **浮点数中的反例**：

    ```c
    // 案例2：溢出与精度损失
    float a = 1e20f, b = 1e20f, c = 1e-20f;
    float r1 = (a * b) * c; // (1e20 * 1e20) * 1e-20 → +∞（溢出）
    float r2 = a * (b * c); // 1e20 * (1e20 * 1e-20) → 1e20
    printf("%f vs %f\n", r1, r2); // 输出: inf vs 100000002004087730000.000000
    ```
    **原因**：

    * ​`a * b`​ 超出浮点数表示范围（`1e40`​ → `+∞`​）。
    * ​`b * c`​ 先计算则结果为 `1`​，避免溢出。

    ---

    ### **2. 为什么乘法对加法不满足分配律？**

    **数学中的分配律**：
    \( a \times (b + c) = a \times b + a \times c \)
    **浮点数中的反例**：

    ```c
    // 案例3：分配律失效
    float a = 1e20f, b = 1e20f, c = -1e20f;
    float r1 = a * (b + c);  // 1e20 * (1e20 - 1e20) → 0.0
    float r2 = a * b + a * c; // 1e20*1e20 - 1e20*1e20 → NaN（∞ - ∞）
    printf("%f vs %f\n", r1, r2); // 输出: 0.000000 vs nan
    ```
    **原因**：

    * ​`b + c`​ 先计算得到精确的 `0`​。
    * ​`a * b`​ 和 `a * c`​ 分别溢出为 `∞`​，导致 `∞ - ∞ = NaN`​。

    ---

    ### **3. 对编译器优化的影响**

    由于浮点数运算顺序会影响结果，编译器必须谨慎优化。例如：

    ```c
    // 原始代码
    x = a + b + c;
    y = b + c + d;

    // 潜在优化（可能错误！）
    t = b + c;
    x = a + t;
    y = t + d;
    ```
    **风险**：

    * 若 `a + (b + c)`​ 与 `(a + b) + c`​ 结果不同（如大数吃小数），优化会导致 `x`​ 的值错误。
    * 编译器默认假设浮点数运算符合结合律（除非指定 `-ffast-math`​ 等宽松选项）。

    ---

    ### **4. 科学计算中的应对策略**

    ####  **(1) 避免大数加小数**

    * 调整计算顺序，优先累加小数量级的值：

      ```c
      // 错误：大数优先
      float sum = 1e10f + 3.14f + 2.71f; // 3.14 和 2.71 被吞噬
      // 正确：小数优先
      float sum = 3.14f + 2.71f + 1e10f; // 保留小数精度
      ```

    ####  **(2) 使用更高精度类型**

    * 用 `double`​ 代替 `float`​，减少舍入误差：

      ```c
      double a = 1e20, b = 1e20, c = 1e-20;
      double r = (a * b) * c; // 仍可能溢出，但误差更小
      ```

    ####  **(3) 控制编译器优化**

    * 禁用危险的浮点优化（如 GCC 的 `-fno-associative-math`​）：

      ```bash
      gcc -O2 -fno-associative-math program.c
      ```

    ---

    ### **5. 关键总结**

    |性质|数学规则|浮点数情况|示例|
    | ----| --------------------------| --------------------| ----|
    |**加法结合律**|\( (a+b)+c = a+(b+c) \)|不满足（大数吃小数）|​`(3.14+1e10)-1e10 ≠ 3.14+(1e10-1e10)`​|
    |**乘法结合律**|\( (a×b)×c = a×(b×c) \)|不满足（溢出风险）|​`(1e20*1e20)*1e-20 ≠ 1e20*(1e20*1e-20)`​|
    |**乘法分配律**|\( a×(b+c) = a×b + a×c \)|不满足（NaN 风险）|​`1e20*(1e20-1e20) ≠ 1e20*1e20 - 1e20*1e20`​|

    **编程建议**：

    * 明确运算顺序，避免依赖结合律/分配律。
    * 测试边界条件（如极值、接近零的值）。
    * 谨慎使用编译器优化选项。

      ---

    **浮点数累加误差分析与修正（Kahan 求和算法详解：** 

    ```c
    // 有问题的版本
    #include <stdio.h>
    int main() {
    float sum = 0.0f;
    for (int i = 0; i < 10000; i++) sum += i + 1;
    printf("Sum: %f\n", sum);
    return 0;
    }
    // 1 + 2 + 3 + … + 10000 = 10000 * (10000 + 1) / 2 = 50005000 ?
    // 修正的版本
    #include <stdio.h>
    int main() {
    float sum = 0.0f, corr = 0.0f; /* corrective value for rounding error */
    for (int i = 0; i < 10000; i++) {
    float y = (i + 1) - corr; /* add the correction to specific item */
    float t = sum + y; /* bits might be lost */
    corr = (t - sum) - y; /* recover lost bits */
    sum = t;
    }
    printf("Sum: %f\n", sum);
    return 0;
    }
    ```
    ---

    #### **1. 问题代码分析**

    原始代码直接累加 1 到 10000 的整数，理论上结果应为：
    $[ \text{Sum} = \frac{n(n+1)}{2} = \frac{10000 \times 10001}{2} = 50005000$
    $]$
    但实际运行后，**浮点数版本的结果可能偏离理论值**（如输出 `50005000.000000`​ 但低精度下可能丢失部分位数）。

    **根本原因**：

    * **大数吃小数**：当 `sum`​ 远大于 `i+1`​ 时，`i+1`​ 的低位精度在加法中丢失。
    * **累积舍入误差**：每次加法都会引入微小误差，最终影响总和。

    ---

    #### **2. 修正方案：Kahan 求和算法**

    修正代码使用了 **Kahan 补偿求和法**（Kahan Summation Algorithm），通过动态跟踪并补偿舍入误差，显著提高累加精度。

    ##### **算法核心思想**：

    1. **记录丢失的精度**（`corr`​）：每次加法后，计算实际加进去的值和预期值的差。
    2. **补偿到下一项**：将误差补偿到下一个待加的数上。

    ##### **变量解释**：

    |变量|作用|
    | ----| --------------------------------------------------------|
    |​`sum`​|累加的主值|
    |​`y`​|当前待加的数（已补偿上一轮的误差 `corr`​）|
    |​`t`​|临时存储 `sum + y`​ 的结果（可能丢失精度）|
    |​`corr`​|计算本次加法的误差：`(t - sum) - y`​（理想情况应为 0，实际是舍入误差）|

    ##### **数学推导**：

    * 理想加法：`sum + y = t`​（无误差）。
    * 实际浮点加法：`sum + y = t + err`​（`err`​ 为丢失的精度）。
    * Kahan 算法通过 `corr`​ 捕获 `err`​，并在下一步补偿。

    ---

    #### **3. 代码逐行解析**

    ```c
    float sum = 0.0f, corr = 0.0f; // 初始化累加值和误差补偿
    for (int i = 0; i < 10000; i++) {
        float y = (i + 1) - corr;   // 应用上一轮的误差补偿
        float t = sum + y;          // 尝试加法（可能丢失精度）
        corr = (t - sum) - y;       // 计算本次加法的误差
        sum = t;                    // 更新累加值
    }
    ```
    **示例（单步模拟）** ：
    假设当前 `sum = 10000.0`​, `i + 1 = 1.0`​, `corr = 0.001`​（上一轮的误差）：

    1. ​`y = 1.0 - 0.001 = 0.999`​
    2. ​`t = 10000.0 + 0.999 = 10000.999`​（但浮点数可能存储为 `10001.0`​）
    3. ​`corr = (10001.0 - 10000.0) - 0.999 = 0.001`​（捕获误差）
    4. 下一轮循环中，`y`​ 会减去这个 `corr`​，补偿误差。

    ---

    #### **4. 为什么 Kahan 算法有效？**

    * **误差动态传递**：每次加法后，误差被精确计算并传递到下一项，避免累积。
    * **精度提升**：补偿后的累加误差从 \( O(n) \) 降至 \( O(1) \)（\( n \) 为加法次数）。

    |**对比实验**：|||
    |方法|累加结果（1 到 10000）|误差|
    | ----------| ---------------| ------------|
    |直接累加|50005000.000000|可能丢失低位|
    |Kahan 求和|50005000.000000|接近理论值|

    ---

    #### **5. 其他高精度累加方案**

    #####  **(1) 分块累加**

    ```c
    float sum1 = 0.0f, sum2 = 0.0f;
    for (int i = 0; i < 10000; i++) {
        if (i % 2 == 0) sum1 += i + 1;
        else sum2 += i + 1;
    }
    float sum = sum1 + sum2; // 减少大数吃小数概率
    ```
    #####  **(2) 使用更高精度类型**

    ```c
    double sum = 0.0; // 64位双精度
    for (int i = 0; i < 10000; i++) sum += i + 1;
    ```
    ---

    #### **6. 关键结论**

    * **浮点数累加需谨慎**：直接累加可能导致精度丢失。
    * **Kahan 算法适用场景**：

      * 需要高精度累加大量数值（如科学计算、统计）。
      * 补偿操作仅增加少量计算开销。
    * **替代方案**：分块累加或使用 `double`​ 类型。

    **使用建议**：

    ```c
    // 若无需极端精度，优先使用 double
    double sum = 0.0;
    for (int i = 0; i < 10000; i++) sum += i + 1;

    // 若需单精度且高精度，用 Kahan
    float sum = 0.0f, corr = 0.0f;
    for (int i = 0; i < 10000; i++) {
        float y = (i + 1) - corr;
        float t = sum + y;
        corr = (t - sum) - y;
        sum = t;
    }
    ```

[^5]: ### **浮点数的构成详解（IEEE 754 标准）** 

    浮点数是计算机中用于表示实数（含小数）的一种数据类型，遵循 **IEEE 754 标准**。其核心思想是通过**科学计数法**的二进制形式存储数值，分为三个部分：**符号位（Sign）** 、**指数位（Exponent）**  和 **尾数位（Mantissa/Fraction）** 。

    ---


[^6]: ### **浮点数运算规则详解（IEEE 754 标准）** 

    浮点数的运算规则是计算机科学中的核心内容，涉及**加减乘除**、**舍入模式**、**特殊值处理**等。以下是基于 **IEEE 754 标准** 的详细说明：

    ---


[^7]: # 拓展：信息的处理

    信息的处理（你会如何删除一个单向链表的一个结点，假设节点必定在list之中）  
    Linus Torvalds 2016年TED采访，拿出两个单向链表操作为例， 说明了什么是有品位的程序。

    ```c
    // 初学者版本
    void remove_list_node(List *list, Node *target)
    {
    Node *prev = NULL;
    Node *cur = list->head;
    // Walk the list
    while (cur != target) {
    prev = cur;
    cur = cur->next;
    }
    // Remove the target by updating the head or the previous node.
    if (!prev)
    list->head = target->next;
    else
    prev->next = target->next;
    }
    ```
    ![微信截图_20250330150542](assets/微信截图_20250330150542-20250330150601-qnq85ag.png)

    ‍

    改进后代码

    ```c
    // 有品位的版本，消除特例，简单优雅的代码
    void remove_list_node(List *list, Node *target)
    {
    // The "indirect" pointer points to the *address*
    // of the thing we'll update.
    Node **indirect = &list->head;
    // Walk the list, looking for the thing that
    // points to the node we want to remove.
    while (*indirect != target)
    indirect = &(*indirect)->next;
    *indirect = target->next;
    }
    ```
    ![微信截图_20250330150550](assets/微信截图_20250330150550-20250330150609-lypjj3d.png)

    ### **链表节点删除的两种实现对比与分析**

    ---

    #### **1. 初学者版本的问题**

    ```c
    void remove_list_node(List *list, Node *target) {
        Node *prev = NULL;
        Node *cur = list->head;
        // 遍历链表查找目标节点
        while (cur != target) {
            prev = cur;
            cur = cur->next;
        }
        // 删除目标节点
        if (!prev)
            list->head = target->next;  // 特例：删除头节点
        else
            prev->next = target->next;  // 一般情况
    }
    ```
    **缺点**：

    1. **特例处理**：需要单独判断 `prev`​ 是否为 `NULL`​（即删除头节点的情况）。
    2. **代码冗余**：`if-else`​ 分支增加了逻辑复杂度。
    3. **可读性差**：显式遍历和条件检查让代码意图不够直观。

    ---

    #### **2. 改进版本的优雅设计**

    ```c
    void remove_list_node(List *list, Node *target) {
        Node **indirect = &list->head;  // 指向"需要更新的指针的地址"
        while (*indirect != target)
            indirect = &(*indirect)->next;  // 移动间接指针
        *indirect = target->next;  // 统一更新
    }
    ```
    **优点**：

    1. **消除特例**：通过间接指针（`Node **`​）统一处理头节点和中间节点。
    2. **代码简洁**：无需 `if-else`​，逻辑线性化。
    3. **性能一致**：无论删除哪个节点，操作步骤相同。

    ---

    #### **3. 关键技巧解析**

    #####  **(1) 间接指针（Pointer to Pointer）**

    * ​`indirect`​ 是一个指向指针的指针，初始时指向 `list->head`​ 的地址。
    * 在遍历过程中，它始终指向  **“当前节点的** **​`next`​**​ **字段的地址”** 。

      * 若 `target`​ 是头节点，`indirect`​ 直接指向 `list->head`​。
      * 若 `target`​ 是中间节点，`indirect`​ 指向其前驱节点的 `next`​ 字段。

    #####  **(2) 统一更新逻辑**

    * ​`*indirect = target->next`​ 直接修改目标节点的前驱指针，跳过了 `target`​。

      * 对头节点：`list->head = target->next`​。
      * 对中间节点：`prev->next = target->next`​。

    ---

    #### **4. 示例演示**

    **链表结构**：

    ```
    head -> A -> B -> C -> NULL
    ```
    **删除节点 B**：

    1. ​`indirect`​ 初始指向 `head`​（`&list->head`​）。
    2. 第一次循环：`*indirect`​ 是 `A`​，不等于 `B`​，移动 `indirect`​ 到 `&A->next`​。
    3. 第二次循环：`*indirect`​ 是 `B`​，匹配成功，执行 `*indirect = B->next`​（即 `A->next = C`​）。

    **结果**：

    ```
    head -> A -> C -> NULL
    ```
    ---

    #### **5. 边界条件验证**

    |测试用例|行为|
    | ------------------| -----------------------------|
    |删除头节点（`target = head`​）|​`indirect`​ 直接修改 `list->head`​|
    |删除中间节点|通过前驱节点的 `next`​ 更新|
    |删除尾节点|正常更新前驱节点的 `next`​ 为 `NULL`​|
    |空链表|需外部保证 `target`​ 有效性|

    ---

    #### **6. 进一步优化**

    #####  **(1) 错误处理（防野指针）**

    ```c
    assert(target != NULL);  // 确保目标节点有效
    while (*indirect != target && *indirect != NULL)
        indirect = &(*indirect)->next;
    if (*indirect == NULL) return;  // 未找到目标
    ```
    #####  **(2) 封装为宏（代码复用）**

    ```c
    #define LIST_REMOVE(head, target) do { \
        typeof(head) **indirect__ = &(head); \
        while (*indirect__ != (target)) \
            indirect__ = &(*indirect__)->next; \
        *indirect__ = (target)->next; \
    } while (0)
    ```
    ---

    #### **7. 总结对比**

    |特性|初学者版本|改进版本|
    | ------| --------------------| ----------------------------|
    |**特例处理**|需要 `if-else`​|无特例，统一逻辑|
    |**代码行数**|7行|4行|
    |**可读性**|显式遍历，意图分散|间接指针，意图集中|
    |**性能**|相同|相同|
    |**扩展性**|修改困难|易于适配其他操作（如插入）|

    ---

    ### **关键点**

    * **间接指针技巧**：通过操作指针的地址，统一处理链表操作的边界条件。
    * **Linux 内核的应用**：该模式广泛用于内核链表（如 `list_del`​）。
    * **适用场景**：任何需要修改指针指向的操作（删除、插入、交换节点）。


[^8]: # 拓展：数值系统的安全性：旁路攻击与常数时间编程

    数值系统还有一个重要的议题，就是安全性（信息安全与功能安全），它已经成为了日益突出的问题。

    **旁路攻击**

    旁路攻击(side channel attack)是指基于从计算机系统的实现中获得的信息的任何攻击 ，而不是基于算法本身的弱点，比如定时信息，功耗，电磁泄漏甚至声音都可以提供额外的信息来源，被 “黑客” 加以利用，说白了就是以「旁敲侧击」的方式进行攻击。

    近些年的 熔断Meltdown漏洞，幽灵Spectre漏洞（两者都是利用现代CPU设计的“漏洞”，例如乱序执行，预测执行，CPU缓存等特性），以及 Row Hammer （利用DRAM的物理漏洞）等都是利用旁路攻击的例子。

    这里举一个Timing Attack的例子，为了简化说明，我们考虑以下C函数， 这函数用于比较用户的输入字符串和存放在系统某处的密码是否一致，输入的字符串与密码完全一致才能获得系统权限，否则系统就报错，然后允许用户（过一段时间后）重新输入，这里有什么风险？ 假如我们有办法精确记录这个函数执行所耗费的时间，那不就可以大概知道在哪个字符出现了不匹配吗？这样的话密码破解的难度将大幅降低。

    ```c
    int memcmp(const void *s1, const void *s2, size_t n) {
    if (n != 0) {
    const unsigned char *p1 = s1, *p2 = s2;
    do {
    if (*p1++ != *p2++)
    return ((*--p1) - (*--p2));
    } while (--n != 0);
    }
    return (0);
    }
    ```
    ![微信截图_20250330151422](assets/微信截图_20250330151422-20250330151431-447gvgp.png)

    实际上涉及密码学和处理敏感信息的程序应该引入常数时间的实现，如果我们想要实现一个对整数取绝对值的函数abs，以下的C示例代码，请注意它本身并不保证是常数时间的，但是如果你去看它在x86-64平台上优化之后的汇编代码，可以看出它是没有分支的，按常数时间实现的，比较安全高效。

    ```c
    // 求一个数的绝对值: 1.有分支情况下CPU执行的指令数量不同 2.注意传入整型最小负值的情况
    int abs(int num) {
    return num < 0 ? -num : num;
    }
    // x86-64 某一个优化版本：注意这里没有分支，3条汇编指令
    abs:
    mov eax,edi // 参数保存到eax
    neg eax // 求出它的相反数
    cmovs eax,edi // 如果符号位=1（即参数是正数）, 原来的参数存入eax
    ret
    // 你也可以用C语言手写没有分支的版本，例如（仅供参考）
    #include <stdint.h>
    int32_t abs(int32_t num){
    int32_t mask = (num >> 31);
    return ((num + mask) ^ mask);
    }
    ```
    ### **数值系统的安全性：旁路攻击与常数时间编程**

    ---

    #### **1. 旁路攻击（Side-Channel Attack）的核心问题**

    旁路攻击通过测量**物理特征**（如时间、功耗、电磁辐射）而非算法漏洞来破解系统。
    **示例：基于时间的攻击（Timing Attack）**

    ```c
    int memcmp(const void *s1, const void *s2, size_t n) {
        if (n != 0) {
            const unsigned char *p1 = s1, *p2 = s2;
            do {
                if (*p1++ != *p2++)  // 首次不匹配时立即返回
                    return ((*--p1) - (*--p2)); // 泄露不匹配位置
            } while (--n != 0);
        }
        return (0);
    }
    ```
    **风险**：

    * 攻击者通过测量函数执行时间，可推断出密码在哪个字符处不匹配。
    * 例如：密码为 `"secret"`​，输入 `"sxxxxx"`​ 比 `"xxxxxx"`​ 耗时略长（因多比较一个字符）。

    ---

    #### **2. 常数时间编程（Constant-Time Programming）**

    安全敏感操作（如密码比较、加密）需保证**执行时间与输入无关**，避免泄露信息。

    #####  **(1) 安全版本的** **​`memcmp`​**​

    ```c
    int secure_memcmp(const void *s1, const void *s2, size_t n) {
        const unsigned char *p1 = s1, *p2 = s2;
        int result = 0;
        for (; n > 0; n--) {
            result |= *p1++ ^ *p2++;  // 累积差异，不提前返回
        }
        return result;  // 0表示完全匹配，非0表示不匹配
    }
    ```
    **特点**：

    * 无论是否匹配，始终遍历全部字符。
    * 通过位运算（`^`​ 和 `|`​）避免分支。

    #####  **(2) 无分支的** **​`abs`​**​ **函数**

    ```c
    // 无分支实现（常数时间）
    int32_t abs(int32_t num) {
        int32_t mask = num >> 31;  // 正数=0，负数=0xFFFFFFFF
        return (num + mask) ^ mask; // 等价于 num < 0 ? -num : num
    }
    ```
    **汇编对比**：

    ```asm
    ; x86-64 优化版本（无分支）
    abs:
        mov   eax, edi
        neg   eax       ; 计算 -num
        cmovs eax, edi  ; 若原数为正，恢复原始值
        ret
    ```
    ---

    #### **3. 现代CPU漏洞与旁路攻击案例**

    |漏洞名称|攻击方式|利用的硬件特性|
    | ----------| ------------------------------| ----------------|
    |**Meltdown**|通过乱序执行读取内核内存|CPU乱序执行|
    |**Spectre**|利用预测执行访问其他进程数据|分支预测|
    |**RowHammer**|频繁翻转DRAM行导致位翻转|DRAM物理特性|

    **防御措施**：

    * **软件**：常数时间算法、禁用危险优化（如 `-fno-strict-aliasing`​）。
    * **硬件**：隔离敏感操作（如Intel SGX）、缓存分区（Cache Partitioning）。

    ---

    #### **4. 安全编程实践**

    #####  **(1) 密码学库的要求**

    * **OpenSSL**：使用常数时间比较（如 `CRYPTO_memcmp`​）。
    * **Libsodium**：默认禁用时序攻击敏感操作。

    #####  **(2) 代码审查重点**

    * 避免基于秘密数据的分支（如 `if (password[0] == 'A')`​）。
    * 禁用编译器危险优化（如循环展开可能泄露循环次数）。

    #####  **(3) 测试方法**

    * **计时分析**：测量函数在不同输入下的执行时间分布。
    * **功耗分析**：使用示波器监测芯片功耗波动。

    ---

    #### **5. 关键总结**

    |安全原则|不安全示例|安全方案|
    | ----------| ------------------------| --------------------|
    |**避免提前终止**|​`memcmp`​ 首次不匹配即返回|累积所有比较结果|
    |**消除数据依赖分支**|​`if (num < 0) return -num;`​|无分支位运算|
    |**禁用危险编译器优化**|自动向量化泄露循环次数|使用 `volatile`​ 或内联汇编|

    **最终建议**：

    * 在安全关键代码中，优先使用经过审计的库（如 OpenSSL、Libsodium）。
    * 对自定义算法进行**旁路攻击测试**（如计时、功耗分析）。


[^9]: # 拓展：未定义行为

    关于这个话题，LLVM 之父 Chris Lattner 写了一个系列的文章 “What Every C Programmer Should KnowAbout Unde

    ```c
    // Demo_6：Unspecified Behavior
    int f() {
    printf("f()\n");
    return 1;
    }
    int g() {
    printf("g()\n");
    return 2;
    }
    int sum(int i, int j) {
    return i + j;
    }
    int main() {
    return sum(f(), g());
    }
    ```
    C语言char类型是signed char还是unsigned char？不一定，取决于编译器（甚至可以在编译时决定）。

    参照GNU gcc中的说明：https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html （unsigned-char

    ### **C语言中的未定义行为（Undefined Behavior, UB）与未指定行为（Unspecified Behavior）详解**

    ---

    #### **1. 未指定行为（Unspecified Behavior）示例分析**

    **代码示例**：

    ```c
    int f() {
        printf("f()\n");
        return 1;
    }
    int g() {
        printf("g()\n");
        return 2;
    }
    int sum(int i, int j) {
        return i + j;
    }
    int main() {
        return sum(f(), g());  // f()和g()的调用顺序未指定
    }
    ```
    **问题**：

    * **函数调用顺序未指定**：`sum(f(), g())`​ 中，`f()`​ 和 `g()`​ 的调用顺序由编译器决定，可能输出：

      * ​`f() g()`​（先调用 `f()`​）
      * ​`g() f()`​（先调用 `g()`​）
    * **标准依据**：C11标准 §6.5.2.2.10 规定，函数参数的求值顺序是未指定的（Unspecified Behavior）。

    **影响**：

    * 若 `f()`​ 和 `g()`​ 有副作用（如修改全局变量），程序行为可能因编译器而异。

    ---

    #### **2. 未定义行为（Undefined Behavior, UB）**

    |UB 比未指定行为更危险，编译器可任意处理（如崩溃、产生任意结果、优化删除代码）。|||
    |**常见UB示例**：|||
    |代码|UB类型|后果示例|
    | ---------------------------------------------------------------------------------| ----------------| --------------------------|
    |​`int a = 1; a = a++ + a++;`​|序列点违规|结果不可预测|
    |​`int x = *((int*)NULL);`​|解引用空指针|程序崩溃或被优化删除|
    |​`char c = 256;`​|有符号整数溢出|截断或编译器假设永不执行|

    ---

    #### **3.**  **​`char`​**​ **的符号性（Implementation-Defined Behavior）**

    **问题**：`char`​ 是 `signed char`​ 还是 `unsigned char`​？
    **答案**：由编译器实现定义（Implementation-Defined），需查阅文档。

    **GCC 编译选项**：

    ```bash
    gcc -funsigned-char  # 强制char为unsigned
    gcc -fsigned-char    # 强制char为signed（默认通常为signed）
    ```
    **影响**：

    * 若 `char`​ 为 `signed`​，`char c = 0xFF;`​ 的值是 `-1`​。
    * 若 `char`​ 为 `unsigned`​，`char c = 0xFF;`​ 的值是 `255`​。

    **安全编程建议**：

    * 明确使用 `signed char`​ 或 `unsigned char`​，避免直接写 `char`​。
    * 处理二进制数据时，优先用 `uint8_t`​（C99标准）。

    ---

    #### **4. 未定义行为的编译器优化案例**

    **示例代码**：

    ```c
    int foo(int *p) {
        *p = 1;
        *p = 2;  // 编译器可能合并写入，直接跳过*p=1
        return *p;
    }
    ```
    **优化结果**（假设无别名）：

    ```asm
    foo:
        mov DWORD PTR [rdi], 2  # 直接写入2，忽略*p=1
        mov eax, 2              # 返回值恒为2
        ret
    ```
    **原因**：编译器假设 `p`​ 不指向其他有效地址（No Strict Aliasing），可自由优化。

    ---

    #### **5. 如何避免UB和未指定行为？**

    1. **启用编译器警告**：

        ```bash
        gcc -Wall -Wextra -pedantic
        ```
        * 检测部分UB（如未初始化变量、序列点违规）。
    2. **静态分析工具**：

        * Clang Static Analyzer、Coverity、Cppcheck。
    3. **遵循规范**：

        * 避免依赖未指定行为（如函数参数求值顺序）。
        * 使用标准库替代危险操作（如 `memcpy`​ 代替指针强制转换）。
    4. **阅读编译器文档**：

        * GCC/Clang 对UB的具体处理方式。

    ---

    #### **6. 关键总结**

    |行为类型|定义|示例|应对措施|
    | ----------| ------------------------------| ------------------------------| ------------------------|
    |**未定义行为（UB）**|标准未规定，编译器可自由处理|空指针解引用、有符号整数溢出|静态分析、启用警告|
    |**未指定行为**|标准允许多种实现，但需文档化|函数参数求值顺序、`char`​符号性|避免依赖，明确指定行为|
    |**实现定义行为**|编译器需文档化具体行为|​`>>`​ 右移符号位扩展|查阅编译器文档|

    **最终建议**：

    * 在安全关键代码中，**明确所有依赖的行为**（如使用 `-fwrapv`​ 禁止有符号溢出优化）。
    * 参考 CERT C 安全编码标准（[SEI CERT C Coding Standard](https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard)）。
